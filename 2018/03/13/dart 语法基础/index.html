<!DOCTYPE html><html><head><meta charset="utf-8"><title>dart 语法基础 | LOVAE BLOG</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="Lovae"><meta name="designer" content="minfive"><meta name="keywords" content="lovae, shichao blog, 前端博客, 前端, 程序员, 前端开发, 全栈开发, node.js, javascript"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://littlechao.top/2018/03/13/dart 语法基础/index.html"><link rel="icon" type="image/png" href="http://oo12ugek5.bkt.clouddn.com/blog/images/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Hexo"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(http://oo12ugek5.bkt.clouddn.com/blog/images/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Hexo" alt="Hexo"><img src="http://oo12ugek5.bkt.clouddn.com/images/logo-text-white.png" alt="Hexo"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archive" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="http://image.littlechao.top/20180224115242000010.jpg" alt="dart 语法基础"></div><header class="post__info"><h1 class="post__title">dart 语法基础</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">Lovae</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-03-13</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/dart/">Dart</a></li></ul></div></div></header><div class="post__content"><blockquote><p>本文是对 Dart 语言的官方文档做了简单的翻译和总结，有不当之处敬请指正。<br>如果有时间和精力建议通读<a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><pre><code>// Define a function.
printNumber(num aNumber) {
  print(&apos;The number is $aNumber.&apos;); // Print to console.
}

// This is where the app starts executing.
main() {
  var number = 42; // Declare and initialize a variable.
  printNumber(number); // Call a function.
}
</code></pre><hr><h3 id="重要的概念"><a href="#重要的概念" class="headerlink" title="重要的概念"></a>重要的概念</h3><ul><li>能赋值给变量的所以东西都是对象，包括 numbers, null, function, 都是继承自 Object 内置类</li><li>尽量给变量定义一个类型，会更安全，没有显示定义类型的变量在 debug 模式下会类型会是 dynamic（动态的）</li><li>dart 在 running 之前解析你的所有代码，指定数据类型和编译时的常量，可以提高运行速度</li><li>dart 提供了顶级函数(如：main())</li><li>dart 没有 public、private、protected 这些关键字，变量名以”_”开头意味着对它的 lib 是私有的</li></ul><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>没有初始化的变量都会被赋予默认值 null</p></blockquote><pre><code>var name = &apos;Bob&apos;;
var unInitializeValue1;   //未给初值的变量，默认值为 null
Int unInitializeValue2;   //即使是Int 型，默认值也是 null
</code></pre><p>程序中只当数据类型是为了指出自己的使用意图，并帮助语言进行语法检查。但是，指定类型不是必须的</p><h6 id="num"><a href="#num" class="headerlink" title="num"></a>num</h6><ul><li><p>int 取值范围：-2^53 to 2^53</p><pre><code>// String -&gt; int
var one = int.parse(&apos;1&apos;);

// String -&gt; double
var onePointOne = double.parse(&apos;1.1&apos;);

// int -&gt; String
String oneAsString = 1.toString();

// double -&gt; String 注意括号中要有小数点位数，否则报错
String piAsString = 3.14159.toStringAsFixed(2);
</code></pre></li></ul><h6 id="string"><a href="#string" class="headerlink" title="string"></a>string</h6><ul><li>‘’’…’’’，”””…”””表示多行字符串</li><li>r’…’,r”…”表示“raw”字符串</li><li>用 $ 或 ${} 来计算字符串中变量的值</li></ul><h6 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h6><ul><li>Dart 是强 bool 类型检查，<strong>只有bool 类型的值是true 才被认为是true</strong></li></ul><h6 id="list"><a href="#list" class="headerlink" title="list"></a>list</h6><blockquote><p>list 基本和 JavaScript 数组一样，它的方法如下：</p></blockquote><pre><code>// 使用List的构造函数，也可以添加int参数，表示List固定长度，不能进行添加 删除操作
var vegetables = new List();

// 或者简单的用List来赋值
var fruits = [&apos;apples&apos;, &apos;oranges&apos;];

// 添加元素
fruits.add(&apos;kiwis&apos;);

// 添加多个元素
fruits.addAll([&apos;grapes&apos;, &apos;bananas&apos;]);

// 获取第一个元素
fruits.first;

// 获取元素最后一个元素
fruits.last;

// 查找某个元素的索引号
assert(fruits.indexOf(&apos;apples&apos;) == 0);

// 删除指定位置的元素，返回删除的元素
fruits.removeAt(index);

// 删除指定元素,成功返回true，失败返回false
fruits.remove(&apos;apples&apos;);

// 删除最后一个元素，返回删除的元素
fruits.removeLast();

// 删除指定范围元素，含头不含尾，成功返回null
fruits.removeRange(start,end);

// 删除指定条件的元素，成功返回null
fruits.removeWhere((item) =&gt; item.length &gt;6)；

// 删除所有的元素
fruits.clear();

// sort()对元素进行排序，传入一个函数作为参数，return &lt;0表示由小到大， &gt;0表示由大到小
fruits.sort((a, b) =&gt; a.compareTo(b));
</code></pre><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><blockquote><p>类似 JavaScript map</p></blockquote><pre><code>// Map的声明
var hawaiianBeaches = {
    &apos;oahu&apos; : [&apos;waikiki&apos;, &apos;kailua&apos;, &apos;waimanalo&apos;],
    &apos;big island&apos; : [&apos;wailea bay&apos;, &apos;pololu beach&apos;],
    &apos;kauai&apos; : [&apos;hanalei&apos;, &apos;poipu&apos;]
};
var searchTerms = new Map();

// 指定键值对的参数类型
var nobleGases = new Map&lt;int, String&gt;();

// Map的赋值，中括号中是Key，这里可不是数组
nobleGase[54] = &apos;dart&apos;;

//Map中的键值对是唯一的
//同Set不同，第二次输入的Key如果存在，Value会覆盖之前的数据
nobleGases[54] = &apos;xenon&apos;;
assert(nobleGases[54] == &apos;xenon&apos;);

// 检索Map是否含有某Key
assert(nobleGases.containsKey(54));

//删除某个键值对
nobleGases.remove(54);
assert(!nobleGases.containsKey(54));
</code></pre><p>注：如果定义了一个 map 常量，那么value 也必须是常量</p><h6 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h6><h2 id="gt-symbol字面量是编译时常量，在标识符前面加-。如果是动态确定，则使用Symbol构造函数，通过new来实例化"><a href="#gt-symbol字面量是编译时常量，在标识符前面加-。如果是动态确定，则使用Symbol构造函数，通过new来实例化" class="headerlink" title="&gt;symbol字面量是编译时常量，在标识符前面加#。如果是动态确定，则使用Symbol构造函数，通过new来实例化"></a>&gt;symbol字面量是编译时常量，在标识符前面加#。如果是动态确定，则使用Symbol构造函数，通过new来实例化</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><p>所有的函数都会有返回值。如果没有指定函数返回值，则默认的返回值是null。没有返回值的函数，系统会在最后添加隐式的return 语句。</p></blockquote><h6 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h6><p>函数可以有两种类型的参数：</p><ul><li>必须的——必须的参数放在参数列表的前面。</li><li>可选的——可选的参数跟在必须的参数后面。</li></ul><p>注：可选参数必须放在最后</p><blockquote><p>通过【】来表示可选参数</p></blockquote><pre><code>String say(String from, String msg, [String device]) {
  var result = &apos;$from says $msg&apos;;
  if (device != null) {
    result = &apos;$result with a $device&apos;;
  }
  return result;
}
</code></pre><blockquote><p>还可以设置默认参数值</p></blockquote><pre><code>String say(String from, String msg,
    [String device = &apos;carrier pigeon&apos;, String mood]) {
  var result = &apos;$from says $msg&apos;;
  if (device != null) {
    result = &apos;$result with a $device&apos;;
  }
  if (mood != null) {
    result = &apos;$result (in a $mood mood)&apos;;
  }
  return result;
}
</code></pre><blockquote><p>函数还可以作为另一个函数的参数</p></blockquote><pre><code>printElement(element) {
  print(element);
}

var list = [1, 2, 3];

// Pass printElement as a parameter.
list.forEach(printElement);
</code></pre><blockquote><p>函数可以匿名，但是不像 JavaScript， 匿名函数不用加上 function 关键字</p></blockquote><pre><code>var list = [&apos;apples&apos;, &apos;oranges&apos;, &apos;grapes&apos;, &apos;bananas&apos;, &apos;plums&apos;];
list.forEach((i) {
  print(list.indexOf(i).toString() + &apos;: &apos; + i);
});
</code></pre><h6 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h6><pre><code>Function makeAdder(num addBy) {
  return (num i) =&gt; addBy + i;
}

main() {
  // Create a function that adds 2.
  var add2 = makeAdder(2);

  // Create a function that adds 4.
  var add4 = makeAdder(4);

  assert(add2(3) == 5);
  assert(add4(3) == 7);
}
</code></pre><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>除了常见的，还有如下运算符：</p><ul><li>is 运算符，a is b，用于判断 a 对象是否是 b 类的实例，返回 bool 值</li><li>is！意义与上面相反</li><li><p>as 运算符；用于检查类型</p><pre><code>(emp as Person).firstName = &apos;Bob&apos;;
</code></pre></li></ul><p>如果 emp 为空或者不是 Person 的实例，会抛出异常</p><ul><li><p>??= 运算符</p><pre><code>b ??= value; // 如果 b 为空，把 value 赋值给 b;
             // 否则，b 不变
</code></pre></li><li><p>?? 运算符</p><pre><code>String toString() =&gt; msg ?? super.toString();
//如果 msg 不为空，返回 msg；否则返回后面的
</code></pre></li><li><p>.. 运算符，把对同一对象的不同操作串联起来</p><pre><code>final addressBook = (new AddressBookBuilder()
      ..name = &apos;jenny&apos;
      ..email = &apos;jenny@example.com&apos;
      ..phone = (new PhoneNumberBuilder()
            ..number = &apos;415-555-0100&apos;
            ..label = &apos;home&apos;)
          .build())
    .build();
</code></pre></li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><ul><li>if…else</li><li>for</li><li>while do-while</li><li>break continue</li><li>switch…case 如果 case 后面有表达式但是没有 break，会抛出异常</li><li>assert（仅在checked模式有效），如果条件为假，抛出异常</li></ul><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><ul><li><p>抛出固定类型的异常：</p><pre><code>throw new FormatException(&apos;Expected at least 1 section&apos;);
</code></pre></li><li><p>抛出任意类型的异常：</p><pre><code>throw &apos;out of llamas！&apos;
</code></pre></li><li><p>因为抛出异常属于表达式，可以将throw语句放在=&gt;语句中，或者其它可以出现表达式的地方：</p><pre><code>distanceTo(Point other) =&gt;
    throw new UnimplementedError();
</code></pre><h5 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h5></li><li><p>可以通过 on语句来指定需要捕获的异常类型，使用catch来处理异常</p><pre><code>try {
  breedMoreLlamas();
} on OutOfLlamasException {
  // A specific exception
  buyMoreLlamas();
} on Exception catch (e) {
  // Anything else that is an exception
  print(&apos;Unknown exception: $e&apos;);
} catch (e, s) {
  print(&apos;Exception details:\n $e&apos;);
  print(&apos;Stack trace:\n $s&apos;);
}
</code></pre></li></ul><p>可以向catch()传递1个或2个参数。第一个参数表示：捕获的异常的具体信息，第二个参数表示：异常的堆栈跟踪(stack trace)</p><h5 id="rethrow"><a href="#rethrow" class="headerlink" title="rethrow"></a>rethrow</h5><blockquote><p>rethrow语句用来处理一个异常，同时希望这个异常能够被其它调用的部分使用</p></blockquote><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><blockquote><p>Dart 的finally用来执行那些无论异常是否发生都执行的操作。</p></blockquote><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><blockquote><p>使用new语句来构造一个类。构造函数的名字可能是ClassName，也可以是ClassName.identifier</p></blockquote><pre><code>var jsonData = JSON.decode(&apos;{&quot;x&quot;:1, &quot;y&quot;:2}&apos;);

// Create a Point using Point().
var p1 = new Point(2, 2);

// Create a Point using Point.fromJson().
var p2 = new Point.fromJson(jsonData);
</code></pre><ul><li>使用.来调用实例的变量或者方法。</li><li>使用 ?. 来避免左边操作数为null引发异常。</li><li>使用const替代new来创建编译时的常量构造函数。</li><li>两个使用const构建的同一个构造函数，实例相等。</li><li>获取对象的运行时类型使用：o.runtimeType</li></ul><blockquote><p>所有实例变量会生成一个隐式的getter方法，不是final或const的实例变量也会生成一个隐式的setter方法</p></blockquote><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><pre><code>class Point {
  num x;
  num y;

  // 推荐方式
  Point(this.x, this.y);
}
</code></pre><blockquote><p>构造函数不能被继承</p></blockquote><p>子类不会继承父类的构造函数。如果不显式提供子类的构造函数，系统就提供默认的构造函数。</p><blockquote><p>命名构造函数</p></blockquote><pre><code>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // 命名构造函数
  Point.fromJson(Map json) {
    x = json[&apos;x&apos;];
    y = json[&apos;y&apos;];
  }
}
</code></pre><p>使用命名构造函数可以实现一个类多个构造函数。构造函数不能被继承，父类中的命名构造函数不能被子类继承。如果想要子类也拥有一个父类一样名字的构造函数，必须在子类实现这个构造函数</p><blockquote><p>如果父类不显式提供无参的非命名构造函数，在子类中必须手动调用父类的一个构造函数。在子类构造函数名后，大括号{前，使用super.调用父类的构造函数，中间使用:分割</p></blockquote><pre><code>class Person {
  String firstName;

  Person.fromJson(Map data) {
    print(&apos;in Person&apos;);
  }
}

class Employee extends Person {
  // 父类没有无参数的非命名构造函数，必须手动调用一个构造函数 super.fromJson(data)
  Employee.fromJson(Map data) : super.fromJson(data) {
    print(&apos;in Employee&apos;);
  }
}
</code></pre><blockquote><p>当在构造函数初始化列表中使用super()时，要把它放在最后。</p></blockquote><pre><code>View(Style style, List children)
    : _children = children,
      super(style) {}
</code></pre><blockquote><p>除了调用父类的构造函数，也可以通过初始化列表 在子类的构造函数体前（大括号前）来初始化实例的变量值，使用逗号,分隔</p></blockquote><pre><code>class Point {
  num x;
  num y;

  Point(this.x, this.y);

  // 在构造函数体前 初始化列表 设置实例变量
  Point.fromJson(Map jsonMap)
      : x = jsonMap[&apos;x&apos;],
        y = jsonMap[&apos;y&apos;] {
    print(&apos;In Point.fromJson(): ($x, $y)&apos;);
  }
}
</code></pre><h5 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h5><blockquote><p>当实例化了一个构造函数后，不想每次都创建该类的一个新的实例的时候使用factory关键字，定义工厂构造函数，从缓存中返回一个实例，或返回一个子类型的实例</p></blockquote><pre><code>class Logger {
  final String name;
  bool mute = false;
  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{}; // 缓存保存对象
  factory Logger(String name) {
    if (_cache.containsKey(name)) {
      return _cache[name];
    } else {
      final logger = new Logger._internal(name);
      _cache[name] = logger;
      return logger;
    }
  }
  Logger._internal(this.name);// 命名构造函数
  void log(String msg) {
    if (!mute) {
      print(msg);
    }
  }
}

main() {
  var p1 = new Logger(&quot;1&quot;);
  p1.log(&quot;2&quot;);

  var p2 = new Logger(&apos;22&apos;);
  p2.log(&apos;3&apos;);
  var p3 = new Logger(&apos;1&apos;);// 相同对象直接访问缓存
}
</code></pre><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="Getters-and-setters"><a href="#Getters-and-setters" class="headerlink" title="Getters and setters"></a>Getters and setters</h6><blockquote><p>get()和set()方法是Dart 语言提供的专门用来读取和写入对象的属性的方法。每一个类的实例变量都有一个隐式的getter和可能的setter（如果字段为final或const，只有getter）</p></blockquote><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><blockquote><p>使用abstract关键字定义一个抽象类，抽象类不能实例化。抽象类通常用来定义接口。</p></blockquote><h5 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h5><blockquote><p>每一个类都隐式的定义一个接口，这个接口包含了这个类的所有实例成员和它实现的所有接口</p><p>一个类可以实现一个或多个（用,隔开）接口，通过implements关键字。</p></blockquote><pre><code>class Person {
  final _name;
  Person(this._name);
  String greet(who) =&gt; &apos;hello,$who,i am $_name&apos;;
}

class Imposter implements Person {
  final _name = &apos;&apos;;
  String greet(who) =&gt; &apos;hi $who.do you know who i am.&apos;;
}

greetBob(Person p) =&gt; p.greet(&apos;bob&apos;);
main(List&lt;String&gt; args) {
  print(greetBob(new Person(&apos;lili&apos;)));
  print(greetBob(new Imposter()));
}
</code></pre><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><blockquote><p>使用extends来创造子类，使用super来指向父类</p></blockquote><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><blockquote><p>枚举类型是一种特殊的类，通常用来表示一组固定数字的常量值。</p><p>每个枚举类型都有一个index的getter，返回以0开始的位置索引，每次加1。</p><p>在switch语句中使用枚举，必须在case语句中判断所有的枚举，否则会获得警告。</p></blockquote><p>枚举类型有以下限制：</p><ul><li>不能继承，mixin，或实现一个枚举。</li><li>不能显式的实例化一个枚举。</li></ul><hr><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><blockquote><p>使用&lt;…&gt; 的方式来定义泛型</p><p>虽然Dart 语言中类型是可选的，但是明确的指明使用的是泛型，会让代码更好理解</p></blockquote><pre><code>abstract class Cache&lt;T&gt; {
   T getByKey(String key);
   setByKey(String key, T value);
 }
</code></pre><h5 id="用于集合类型"><a href="#用于集合类型" class="headerlink" title="用于集合类型"></a>用于集合类型</h5><blockquote><p>泛型用于List 和 Map 类型参数化</p></blockquote><pre><code>var names = &lt;String&gt;[&apos;Seth&apos;, &apos;Kathy&apos;, &apos;Lars&apos;];
var pages = &lt;String, String&gt;{
  &apos;index.html&apos;: &apos;Homepage&apos;,
  &apos;robots.txt&apos;: &apos;Hints for web robots&apos;,
  &apos;humans.txt&apos;: &apos;We are people, not machines&apos;
};
</code></pre><h5 id="泛型集合及它们所包含的类型"><a href="#泛型集合及它们所包含的类型" class="headerlink" title="泛型集合及它们所包含的类型"></a>泛型集合及它们所包含的类型</h5><blockquote><p>dart的泛型类型是具体的，在运行时包含它们的类型信息。</p></blockquote><hr><h3 id="库和可见性"><a href="#库和可见性" class="headerlink" title="库和可见性"></a>库和可见性</h3><blockquote><p>使用import 和 library 指令可以方便的创建一个模块或分享代码。一个Dart 库不仅能够提供相应的API，还可以包含一些以_开头的私有变量仅在库内部可见</p><p>如果导入的库拥有相互冲突的名字，使用as为其中一个或几个指定不一样的前缀。</p></blockquote><pre><code>import &apos;package:lib1/lib1.dart&apos;;
import &apos;package:lib2/lib2.dart&apos; as lib2;
// ...
Element element1 = new Element();           // Uses Element from lib1.
lib2.Element element2 = new lib2.Element(); // Uses Element from lib2.
</code></pre><blockquote><p>如果只需要使用库的一部分内容，使用show或hide有选择的导入。</p></blockquote><pre><code>// 仅导入foo.
import &apos;package:lib1/lib1.dart&apos; show foo;

// 除了foo都导入
import &apos;package:lib2/lib2.dart&apos; hide foo;
</code></pre><blockquote><p>要延迟加载一个库，首先必须使用deferred as导入它。</p></blockquote><pre><code>import &apos;package:deferred/hello.dart&apos; deferred as hello;

greet() async {
  // 使用await关键字暂停执行，直到库加载
  await hello.loadLibrary();
  hello.printGreeting();
}
</code></pre><p>可以在代码中多次调用loadLibrary()方法。但是实际上它只会被执行一次。</p><p>使用延迟加载的注意事项：</p><ul><li>延迟加载的内容只有在加载后才存在。</li><li>Dart 隐式的将deferred as改为了deferred as namespace。loadLibrary()返回值是Future</li></ul><hr><h3 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h3><p>使用async函数和await表达式实现异步操作。</p><p>当需要使用一个从Future返回的值时，有两个选择：</p><ul><li>使用async和await。</li><li>使用Future API。</li></ul><p>当需要从一个Stream获取值时，有两个选择：</p><ul><li>使用async和异步的循环(await for)。</li><li><p>使用Stream API。<br>代码使用了async和await就是异步的，虽然看起来像同步代码。</p><pre><code>checkVersion() async {          //注意这里 async 在小括号后面，和 JavaScript 不一样
  var version = await lookUpVersion();
  if (version == expectedVersion) {
    // Do something.
  } else {
    // Do something else.
  }
}
</code></pre></li></ul><blockquote><p>给函数添加async关键字将使函数返回一个Future类型。</p></blockquote><pre><code>// 修改前是同步的
String lookUpVersionSync() =&gt; &apos;1.0.0&apos;;

// 修改后 是异步的 函数体不需要使用Future API
// dart会在必要的时候创建Future对象
Future&lt;String&gt; lookUpVersion() async =&gt; &apos;1.0.0&apos;;
</code></pre><blockquote><p>在Stream中使用异步循环</p></blockquote><pre><code> // expression的值必须是Stram类型
await for (variable declaration in expression) {
  // Executes each time the stream emits a value.
}
</code></pre><p>异步循环的执行流程如下：</p><ul><li>等待 stream 发出数据。</li><li>执行循环体，并将变量的值设置为发出的数据。</li><li>重复1.，2.直到stream 对象被关闭</li></ul><p>注：这个过程类似于 JavaScript 的 Rxjs</p><hr><h3 id="可调用类"><a href="#可调用类" class="headerlink" title="可调用类"></a>可调用类</h3><blockquote><p>Dart 语言中为了能够让类像函数一样能够被调用，可以实现call()方法。</p></blockquote><pre><code>class WannabeFunction {
  call(String a, String b, String c) =&gt; &apos;$a $b $c!&apos;;
}

main() {
  var wf = new WannabeFunction();
  var out = wf(&quot;Hi&quot;,&quot;there,&quot;,&quot;gang&quot;);
  print(&apos;$out&apos;); // Hi there, gang!
  print(wf.runtimeType); // WannabeFunction
  print(out.runtimeType); // String
  print(wf is Function); // true
}
</code></pre><div class="post-announce">感谢您的阅读，本文由 <a href="http://littlechao.top">Hexo</a> 版权所有。如若转载，请注明出处：Hexo（<a href="http://littlechao.top/2018/03/13/dart 语法基础/">http://littlechao.top/2018/03/13/dart 语法基础/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/03/13/byte/" title="Go bytes.go"><i class="iconfont icon-prev"></i>Go bytes.go</a></div><div class="post__prev post__prev--right"><a href="/2018/03/13/正则表达式入门/" title="正则表达式入门">正则表达式入门<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/04/01/tcp_keepalive/" title="TCP 保活机制"><div class="item__cover"><img src="http://oo12ugek5.bkt.clouddn.com/images/default_cover.png" alt="TCP 保活机制"></div><div class="item__info"><h3 class="item__title">TCP 保活机制</h3><span class="item__text">2018-04-01</span></div></a></li><li class="latest-post-item"><a href="/2018/04/01/tcp_retransmission/" title="TCP 超时重传"><div class="item__cover"><img src="http://oo12ugek5.bkt.clouddn.com/images/default_cover.png" alt="TCP 超时重传"></div><div class="item__info"><h3 class="item__title">TCP 超时重传</h3><span class="item__text">2018-04-01</span></div></a></li><li class="latest-post-item"><a href="/2018/03/29/node_async_io/" title="Node 异步 I/O"><div class="item__cover"><img src="/images/async/async_pic.png" alt="Node 异步 I/O"></div><div class="item__info"><h3 class="item__title">Node 异步 I/O</h3><span class="item__text">2018-03-29</span></div></a></li><li class="latest-post-item"><a href="/2018/03/29/node_commonJS/" title="node 模块机制"><div class="item__cover"><img src="/images/node_module/cover.jpg" alt="node 模块机制"></div><div class="item__info"><h3 class="item__title">node 模块机制</h3><span class="item__text">2018-03-29</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/dart/">dart</a></li><li class="tag-item"><a class="tag-link" href="/tags/golang/">golang</a></li><li class="tag-item"><a class="tag-link" href="/tags/net/">net</a></li><li class="tag-item"><a class="tag-link" href="/tags/node/">node</a></li><li class="tag-item"><a class="tag-link" href="/tags/react/">react</a></li><li class="tag-item"><a class="tag-link" href="/tags/redux/">redux</a></li><li class="tag-item"><a class="tag-link" href="/tags/regex/">regex</a></li><li class="tag-item"><a class="tag-link" href="/tags/tcp/">tcp</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Baoding, Hebei Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>shichao1996@gmail.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="http://oo12ugek5.bkt.clouddn.com/images/qrcode.png" alt="logo" title="Hexo"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>