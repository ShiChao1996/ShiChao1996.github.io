<!DOCTYPE html><html><head><meta charset="utf-8"><title>Go net/dial.go（I） | LOVAE BLOG</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="Lovae"><meta name="designer" content="minfive"><meta name="keywords" content="lovae, shichao blog, 前端博客, 前端, 程序员, 前端开发, 全栈开发, node.js, javascript, 后台, golang, 网络编程"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://littlechao.top/2018/03/01/golang net:dial.go/index.html"><link rel="icon" type="image/png" href="https://image.littlechao.top/20180512113931000007.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Hexo"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(http://oo12ugek5.bkt.clouddn.com/blog/images/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Hexo" alt="Hexo"><img src="https://image.littlechao.top/20180506131200000003.jpg" alt="Hexo"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://image.littlechao.top/20180301160118000011.jpg" alt="Go net/dial.go（I）"></div><header class="post__info"><h1 class="post__title">Go net/dial.go（I）</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">Lovae</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-03-01</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/golang/">Golang</a></li><li class="mark__item"><a href="/tags/net/">Net</a></li></ul></div></div></header><div class="post__content"><blockquote><p>实际上dial.go这个文件中并没有实际发起连接的部分，基本上是在为真正发起连接做一系列的准备，比如：解析网络类型、从addr解析ip地址。。。实际发起连接的函数在<code>tcpsock_posix.go</code>、<code>udpsock_posix.go</code>。。。</p></blockquote><p>首先看一下最主要的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dialer <span class="keyword">struct</span> &#123;</span><br><span class="line">	Timeout time.Duration</span><br><span class="line">  </span><br><span class="line">	Deadline time.Time</span><br><span class="line"></span><br><span class="line">  	LocalAddr Addr <span class="comment">//真正dial时的本地地址，兼容各种类型(TCP、UDP...),如果为nil，则系统自动选择一个地址</span></span><br><span class="line"></span><br><span class="line">	DualStack <span class="keyword">bool</span> <span class="comment">// 双协议栈，即是否同时支持ipv4和ipv6.当network值为tcp时，dial函数会向host主机的v4和v6地址都发起连接</span></span><br><span class="line"></span><br><span class="line">	FallbackDelay time.Duration <span class="comment">// 当DualStack为真，ipv6会延后于ipv4发起，此字段即为延迟时间，默认为300ms</span></span><br><span class="line"></span><br><span class="line">	KeepAlive time.Duration </span><br><span class="line"></span><br><span class="line">	Resolver *Resolver</span><br><span class="line"></span><br><span class="line">  	Cancel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 用于取消dial</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dial是最主要的函数，看一下源码注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dial connects to the address on the named network.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only),</span></span><br><span class="line"><span class="comment">// "udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4"</span></span><br><span class="line"><span class="comment">// (IPv4-only), "ip6" (IPv6-only), "unix", "unixgram" and</span></span><br><span class="line"><span class="comment">// "unixpacket".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For TCP and UDP networks, the address has the form "host:port".</span></span><br><span class="line"><span class="comment">// The host must be a literal IP address, or a host name that can be</span></span><br><span class="line"><span class="comment">// resolved to IP addresses.</span></span><br><span class="line"><span class="comment">// The port must be a literal port number or a service name.</span></span><br><span class="line"><span class="comment">// If the host is a literal IPv6 address it must be enclosed in square</span></span><br><span class="line"><span class="comment">// brackets, as in "[2001:db8::1]:80" or "[fe80::1%zone]:80".</span></span><br><span class="line"><span class="comment">// The zone specifies the scope of the literal IPv6 address as defined</span></span><br><span class="line"><span class="comment">// in RFC 4007.</span></span><br><span class="line"><span class="comment">// The functions JoinHostPort and SplitHostPort manipulate a pair of</span></span><br><span class="line"><span class="comment">// host and port in this form.</span></span><br><span class="line"><span class="comment">// When using TCP, and the host resolves to multiple IP addresses,</span></span><br><span class="line"><span class="comment">// Dial will try each IP address in order until one succeeds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//	Dial("tcp", "golang.org:http")</span></span><br><span class="line"><span class="comment">//	Dial("tcp", "192.0.2.1:http")</span></span><br><span class="line"><span class="comment">//	Dial("tcp", "198.51.100.1:80")</span></span><br><span class="line"><span class="comment">//	Dial("udp", "[2001:db8::1]:domain")</span></span><br><span class="line"><span class="comment">//	Dial("udp", "[fe80::1%lo0]:53")</span></span><br><span class="line"><span class="comment">//	Dial("tcp", ":80")</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For IP networks, the network must be "ip", "ip4" or "ip6" followed</span></span><br><span class="line"><span class="comment">// by a colon and a literal protocol number or a protocol name, and</span></span><br><span class="line"><span class="comment">// the address has the form "host". The host must be a literal IP</span></span><br><span class="line"><span class="comment">// address or a literal IPv6 address with zone.</span></span><br><span class="line"><span class="comment">// It depends on each operating system how the operating system</span></span><br><span class="line"><span class="comment">// behaves with a non-well known protocol number such as "0" or "255".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//	Dial("ip4:1", "192.0.2.1")</span></span><br><span class="line"><span class="comment">//	Dial("ip6:ipv6-icmp", "2001:db8::1")</span></span><br><span class="line"><span class="comment">//	Dial("ip6:58", "fe80::1%lo0")</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For TCP, UDP and IP networks, if the host is empty or a literal</span></span><br><span class="line"><span class="comment">// unspecified IP address, as in ":80", "0.0.0.0:80" or "[::]:80" for</span></span><br><span class="line"><span class="comment">// TCP and UDP, "", "0.0.0.0" or "::" for IP, the local system is</span></span><br><span class="line"><span class="comment">// assumed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For Unix networks, the address must be a file system path.</span></span><br></pre></td></tr></table></figure><blockquote><p>从注释可以看出，Dial 支持多种网络类型；支持ipv4、ipv6；还支持用host名代替ip地址。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> d Dialer</span><br><span class="line">	<span class="keyword">return</span> d.Dial(network, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTimeout</span><span class="params">(network, address <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">	d := Dialer&#123;Timeout: timeout&#125;</span><br><span class="line">	<span class="keyword">return</span> d.Dial(network, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dialer)</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> d.DialContext(context.Background(), network, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上前两个是导出的主要函数，都调用了d.dial()，d.DialContext()。d.DialContext()可以传入一个context，如果context的生命周期在connect完成之前结束，那么会立即返回错误。如果context在连接建立完成之后结束，则不会影响连接。另外如果addr是一组ip地址的话，会把当前剩下的所有时间均分到每个ip上去尝试连接。只要有一个成功，就会立即返回成功的连接并取消其他尝试。具体看代码(有删减)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dialer)</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">  	deadline := d.deadline(ctx, time.Now()) </span><br><span class="line">  	<span class="comment">//d.deadline() 比较d.deadline、ctx.deadline、now+timeout，返回其中最小.如果都为空，返回0</span></span><br><span class="line">  	...</span><br><span class="line">  	subCtx, cancel := context.WithDeadline(ctx, deadline) <span class="comment">//设置新的超时context</span></span><br><span class="line">  	<span class="keyword">defer</span> cancel()</span><br><span class="line">  	...</span><br><span class="line">	<span class="comment">// Shadow the nettrace (if any) during resolve so Connect events don't fire for DNS lookups.</span></span><br><span class="line">	resolveCtx := ctx</span><br><span class="line">	...<span class="comment">//给resolveCtx带上一些value</span></span><br><span class="line"></span><br><span class="line">	addrs, err := d.resolver().resolveAddrList(resolveCtx, <span class="string">"dial"</span>, network, address, d.LocalAddr) <span class="comment">// 解析IP地址，返回值是一个切片</span></span><br><span class="line"></span><br><span class="line">	dp := &amp;dialParam&#123;</span><br><span class="line">		Dialer:  *d,</span><br><span class="line">		network: network,</span><br><span class="line">		address: address,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> primaries, fallbacks addrList</span><br><span class="line">	<span class="keyword">if</span> d.DualStack &amp;&amp; network == <span class="string">"tcp"</span> &#123; <span class="comment">//表示同时支持ipv4和ipv6</span></span><br><span class="line">		primaries, fallbacks = addrs.partition(isIPv4) <span class="comment">// 将addrs分成两个切片，前者包含ipv4地址，后者包含ipv6地址</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		primaries = addrs</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c Conn</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(fallbacks) &gt; <span class="number">0</span> &#123;<span class="comment">//有ipv6的情况，v4和v6一起dial</span></span><br><span class="line">		c, err = dialParallel(ctx, dp, primaries, fallbacks)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		c, err = dialSerial(ctx, dp, primaries)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码看到，DialContext最终调用的是<code>dialParallel</code>和<code>dialSerial</code>,先看dialParallel，该函数将v4地址和v6地址分开，先尝试v4地址组，在dialer.fallbackDelay 时间后开始尝试v6地址组，每一组都是调用dialSerial(),让两组竞争：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialParallel</span><span class="params">(ctx context.Context, dp *dialParam, primaries, fallbacks addrList)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(fallbacks) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> dialSerial(ctx, dp, primaries)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">type</span> dialResult <span class="keyword">struct</span> &#123;</span><br><span class="line">		Conn</span><br><span class="line">		error</span><br><span class="line">		primary <span class="keyword">bool</span></span><br><span class="line">		done    <span class="keyword">bool</span></span><br><span class="line">	&#125;</span><br><span class="line">	results := <span class="built_in">make</span>(<span class="keyword">chan</span> dialResult) <span class="comment">// unbuffered</span></span><br><span class="line"></span><br><span class="line">	startRacer := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, primary <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">		ras := primaries <span class="comment">// ras 意思是 remote addresses</span></span><br><span class="line">		<span class="keyword">if</span> !primary &#123;</span><br><span class="line">			ras = fallbacks</span><br><span class="line">		&#125;</span><br><span class="line">		c, err := dialSerial(ctx, dp, ras)</span><br><span class="line">      	...</span><br><span class="line">		results &lt;- dialResult&#123;Conn: c, error: err, primary: primary, done: <span class="literal">true</span>&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> primary, fallback dialResult</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the main racer.</span></span><br><span class="line">	primaryCtx, primaryCancel := context.WithCancel(ctx)</span><br><span class="line">	<span class="keyword">defer</span> primaryCancel()</span><br><span class="line">	<span class="keyword">go</span> startRacer(primaryCtx, <span class="literal">true</span>)	<span class="comment">//先尝试ipv4地址组</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start the timer for the fallback racer.</span></span><br><span class="line">	fallbackTimer := time.NewTimer(dp.fallbackDelay())</span><br><span class="line">	<span class="keyword">defer</span> fallbackTimer.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-fallbackTimer.C: <span class="comment">// ipv6延迟时间到，开始尝试ipv6地址组</span></span><br><span class="line">			fallbackCtx, fallbackCancel := context.WithCancel(ctx)</span><br><span class="line">			<span class="keyword">defer</span> fallbackCancel()</span><br><span class="line">			<span class="keyword">go</span> startRacer(fallbackCtx, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> res := &lt;-results: <span class="comment">//表示至少有一组已经建立连接</span></span><br><span class="line">			<span class="keyword">if</span> res.error == <span class="literal">nil</span> &#123; <span class="comment">//</span></span><br><span class="line">				<span class="keyword">return</span> res.Conn, <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> res.primary &#123;</span><br><span class="line">				primary = res</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				fallback = res</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> primary.done &amp;&amp; fallback.done &#123;<span class="comment">//同时建立连接，抛弃</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, primary.error</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> res.primary &amp;&amp; fallbackTimer.Stop() &#123;</span><br><span class="line">				<span class="comment">// If we were able to stop the timer, that means it</span></span><br><span class="line">				<span class="comment">// was running (hadn't yet started the fallback), but</span></span><br><span class="line">				<span class="comment">// we just got an error on the primary path, so start</span></span><br><span class="line">				<span class="comment">// the fallback immediately (in 0 nanoseconds).</span></span><br><span class="line">				fallbackTimer.Reset(<span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看<code>dialSerial</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialSerial</span><span class="params">(ctx context.Context, dp *dialParam, ras addrList)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> firstErr error <span class="comment">// The error from the first address is most relevant.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, ra := <span class="keyword">range</span> ras &#123; <span class="comment">// ra =&gt; remote address</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//表示</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: dp.LocalAddr, Addr: ra, Err: mapErr(ctx.Err())&#125;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		deadline, _ := ctx.Deadline()</span><br><span class="line">		partialDeadline, err := partialDeadline(time.Now(), deadline, <span class="built_in">len</span>(ras)-i)</span><br><span class="line">        <span class="comment">// 这里表示前 i 个IP地址的连接失败，然后将剩下的时间均分到剩余的IP地址</span></span><br><span class="line">		...<span class="comment">//判断是否超时并处理</span></span><br><span class="line">      </span><br><span class="line">		dialCtx := ctx</span><br><span class="line">        dialCtx, cancel := context.WithDeadline(ctx, partialDeadline)</span><br><span class="line">		<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">		c, err := dialSingle(dialCtx, dp, ra)<span class="comment">// 对单个IP地址发起连接</span></span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> firstErr == <span class="literal">nil</span> &#123;</span><br><span class="line">			firstErr = err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> firstErr == <span class="literal">nil</span> &#123;</span><br><span class="line">		firstErr = &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: <span class="literal">nil</span>, Addr: <span class="literal">nil</span>, Err: errMissingAddress&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, firstErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终所有的对单个IP地址发起链接的任务是由dialSingle分配的（此处简单看下就好），该函数解决了兼容不同网络类型的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialSingle</span><span class="params">(ctx context.Context, dp *dialParam, ra Addr)</span> <span class="params">(c Conn, err error)</span></span> &#123;</span><br><span class="line">	trace, _ := ctx.Value(nettrace.TraceKey&#123;&#125;).(*nettrace.Trace)</span><br><span class="line">	<span class="keyword">if</span> trace != <span class="literal">nil</span> &#123;</span><br><span class="line">		raStr := ra.String()</span><br><span class="line">		<span class="keyword">if</span> trace.ConnectStart != <span class="literal">nil</span> &#123;</span><br><span class="line">			trace.ConnectStart(dp.network, raStr)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> trace.ConnectDone != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; trace.ConnectDone(dp.network, raStr, err) &#125;()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	la := dp.LocalAddr</span><br><span class="line">	<span class="keyword">switch</span> ra := ra.(<span class="keyword">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> *TCPAddr:</span><br><span class="line">		la, _ := la.(*TCPAddr)</span><br><span class="line">		c, err = dialTCP(ctx, dp.network, la, ra)</span><br><span class="line">	<span class="keyword">case</span> *UDPAddr:</span><br><span class="line">		la, _ := la.(*UDPAddr)</span><br><span class="line">		c, err = dialUDP(ctx, dp.network, la, ra)</span><br><span class="line">	<span class="keyword">case</span> *IPAddr:</span><br><span class="line">		la, _ := la.(*IPAddr)</span><br><span class="line">		c, err = dialIP(ctx, dp.network, la, ra)</span><br><span class="line">	<span class="keyword">case</span> *UnixAddr:</span><br><span class="line">		la, _ := la.(*UnixAddr)</span><br><span class="line">		c, err = dialUnix(ctx, dp.network, la, ra)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: la, Addr: ra, Err: &amp;AddrError&#123;Err: <span class="string">"unexpected address type"</span>, Addr: dp.address&#125;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: la, Addr: ra, Err: err&#125; <span class="comment">// c is non-nil interface containing nil pointer</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，dial.go基本就这么多内容，真正通过socket建立连接的部分下篇再写吧(其实是偷懒)。</p><h4 id="待续"><a href="#待续" class="headerlink" title="(待续)"></a>(待续)</h4><div class="post-announce">感谢您的阅读，本文由 <a href="http://littlechao.top">Hexo</a> 版权所有。如若转载，请注明出处：Hexo（<a href="http://littlechao.top/2018/03/01/golang net:dial.go/">http://littlechao.top/2018/03/01/golang net:dial.go/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/02/05/byte/" title="Go bytes.go"><i class="iconfont icon-prev"></i>Go bytes.go</a></div><div class="post__prev post__prev--right"><a href="/2018/03/02/Go net:dial.go 阅读笔记(二)/" title="Go net/dial.go (II)">Go net/dial.go (II)<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/网络/">网络</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/netstack-tcp/">netstack_tcp</a><span class="block-list-count">4</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/06/01/go_http_server_2/" title="Go http server (II)"><div class="item__cover"><img src="https://image.littlechao.top/20180301160118000011.jpg" alt="Go http server (II)"></div><div class="item__info"><h3 class="item__title">Go http server (II)</h3><span class="item__text">2018-06-01</span></div></a></li><li class="latest-post-item"><a href="/2018/05/29/go_http_server_1/" title="Go http server (I)"><div class="item__cover"><img src="https://image.littlechao.top/20180301160118000011.jpg" alt="Go http server (I)"></div><div class="item__info"><h3 class="item__title">Go http server (I)</h3><span class="item__text">2018-05-29</span></div></a></li><li class="latest-post-item"><a href="/2018/05/17/netstack_tcp_receive/" title="netstack TCP(IV) 收发数据(下)"><div class="item__cover"><img src="/images/netstack/cover.jpg" alt="netstack TCP(IV) 收发数据(下)"></div><div class="item__info"><h3 class="item__title">netstack TCP(IV) 收发数据(下)</h3><span class="item__text">2018-05-17</span></div></a></li><li class="latest-post-item"><a href="/2018/05/15/netstack_tcp_send/" title="netstack TCP(III) 收发数据(上)"><div class="item__cover"><img src="/images/netstack/cover.jpg" alt="netstack TCP(III) 收发数据(上)"></div><div class="item__info"><h3 class="item__title">netstack TCP(III) 收发数据(上)</h3><span class="item__text">2018-05-15</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Intellij/">Intellij</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/dart/">dart</a></li><li class="tag-item"><a class="tag-link" href="/tags/golang/">golang</a></li><li class="tag-item"><a class="tag-link" href="/tags/net/">net</a></li><li class="tag-item"><a class="tag-link" href="/tags/netstack/">netstack</a></li><li class="tag-item"><a class="tag-link" href="/tags/node/">node</a></li><li class="tag-item"><a class="tag-link" href="/tags/react/">react</a></li><li class="tag-item"><a class="tag-link" href="/tags/redux/">redux</a></li><li class="tag-item"><a class="tag-link" href="/tags/tcp/">tcp</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Baoding, Hebei Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>shichao1996@gmail.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="https://image.littlechao.top/20180512113439000006.jpg" alt="logo" title="Hexo"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>