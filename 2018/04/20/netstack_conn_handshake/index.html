<!DOCTYPE html><html><head><meta charset="utf-8"><title>netstack TCP(II) 连接管理与三次握手 | LOVAE BLOG</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="Lovae"><meta name="designer" content="minfive"><meta name="keywords" content="lovae, shichao blog, 前端博客, 前端, 程序员, 前端开发, 全栈开发, node.js, javascript, 后台, golang, 网络编程"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://littlechao.top/2018/04/20/netstack_conn_handshake/index.html"><link rel="icon" type="image/png" href="https://image.littlechao.top/20180512113931000007.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Hexo"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(http://oo12ugek5.bkt.clouddn.com/blog/images/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Hexo" alt="Hexo"><img src="https://image.littlechao.top/20180506131200000003.jpg" alt="Hexo"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/netstack/cover.jpg" alt="netstack TCP(II) 连接管理与三次握手"></div><header class="post__info"><h1 class="post__title">netstack TCP(II) 连接管理与三次握手</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">Lovae</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-04-20</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/tcp/">Tcp</a></li><li class="mark__item"><a href="/tags/netstack/">Netstack</a></li></ul></div></div></header><div class="post__content"><h2 id="Netsatck-TCP-II-连接的建立与三次握手"><a href="#Netsatck-TCP-II-连接的建立与三次握手" class="headerlink" title="Netsatck TCP(II) 连接的建立与三次握手"></a>Netsatck TCP(II) 连接的建立与三次握手</h2><h4 id="protocolListenLoop"><a href="#protocolListenLoop" class="headerlink" title="protocolListenLoop"></a>protocolListenLoop</h4><p>当新建一个 endpoint 并且将其 Bind 到一个端口后，这个endpoint 进入 protocolListenLoop，负责监听与连接建立。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">e.protocolListenLoop(seqnum.Size(e.receiveBufferAvailable()))&#123;<span class="comment">// 同时设置了 rcvBuf 的大小</span></span><br><span class="line">    ctx := newListenContext(e.stack, rcvWnd, v6only, e.netProto)<span class="comment">// 只是为了带一些参数</span></span><br><span class="line"></span><br><span class="line">	s := sleep.Sleeper&#123;&#125;</span><br><span class="line">	s.AddWaker(&amp;e.notificationWaker, wakerForNotification)</span><br><span class="line">	s.AddWaker(&amp;e.newSegmentWaker, wakerForNewSegment)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> index, _ := s.Fetch(<span class="literal">true</span>); index &#123;</span><br><span class="line">		<span class="keyword">case</span> wakerForNotification:</span><br><span class="line">			n := e.fetchNotifications()</span><br><span class="line">			<span class="keyword">if</span> n&amp;notifyClose != <span class="number">0</span> &#123;	<span class="comment">// 表示收到退出通知</span></span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> wakerForNewSegment:</span><br><span class="line">			<span class="comment">// Process at most maxSegmentsPerWake segments.</span></span><br><span class="line">			mayRequeue := <span class="literal">true</span></span><br><span class="line">			<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxSegmentsPerWake; i++ &#123; </span><br><span class="line">                <span class="comment">// maxSegmentsPerWake==100,因为收到一个通知可能对应受到了多个数据包，所以每次 wake</span></span><br><span class="line">                <span class="comment">// 都处理多次</span></span><br><span class="line">				s := e.segmentQueue.dequeue()</span><br><span class="line">                <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">				e.handleListenSegment(ctx, s)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> mayRequeue &amp;&amp; !e.segmentQueue.empty() &#123;</span><br><span class="line">				e.newSegmentWaker.Assert()</span><br><span class="line">				<span class="comment">// maxSegmentsPerWake 次循环仍然没有处理完所有的包，再次唤醒 waker，继续处理</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/netstack/tcp_listenLoop.png" alt=""></p><p>handleListenSegment 处理收到的数据包，优先判定是否有 SYN 标识。如果改数据包没有 SYN 而有 ACK 标识的话，那么根据三次握手，它属于第三步，验证其合法后，该数据包对应的连接已经建立，那么为该连接创建一个新的 endpoint，将其发给 Accept 队列。</p><p>只要包含 SYN标识，那么说明该连接处于三步握手的第一步。为什么不是第二步？因为这是 Listen 函数，当前处于连接的被动方。这里会有一个队列，称为 SYN_RCVD 队列或半连接队列。长度为 max(64,/proc/sys/net/ipv4/tcp_max_syn_backlog) ，在机器的tcp_max_syn_backlog值在/proc/sys/net/ipv4/tcp_max_syn_backlog下配置。</p><p><img src="/images/netstack/handshake.png" alt=""></p><p>当这个队列满了，不开启 syncookies 的时候，Server 会丢弃新来的 SYN 包，而 Client 端在多次重发 SYN 包得不到响应而返回（<code>connection time out</code>）错误。但是，当 Server 端开启了 syncookies=1，那么 SYN 半连接队列就没有逻辑上的最大值了，并且 /proc/sys/net/ipv4/tcp_max_syn_backlog 设置的值也会被忽略。在 netstack 中开启了 syncookies。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">handleListenSegment</span><span class="params">(ctx *listenContext, s *segment)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> s.flags &#123;</span><br><span class="line">	<span class="keyword">case</span> flagSyn:</span><br><span class="line">		opts := parseSynSegmentOptions(s)</span><br><span class="line">		<span class="keyword">if</span> incSynRcvdCount() &#123; <span class="comment">// 半连接队列长度 +1，成功返回 true，队列已满返回 false</span></span><br><span class="line">			<span class="keyword">go</span> e.handleSynSegment(ctx, s, &amp;opts)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里采用 SYNCookies 策略，SYN 半连接队列就没有逻辑上的最大值</span></span><br><span class="line">			cookie := ctx.createCookie(s.id, s.sequenceNumber, encodeMSS(opts.MSS))</span><br><span class="line">			...</span><br><span class="line">			sendSynTCP(&amp;s.route, s.id, flagSyn|flagAck, cookie, s.sequenceNumber+<span class="number">1</span>, ctx.rcvWnd, synOpts)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> flagAck:</span><br><span class="line">		<span class="keyword">if</span> data, ok := ctx.isCookieValid(s.id, s.ackNumber<span class="number">-1</span>, s.sequenceNumber<span class="number">-1</span>); ok &amp;&amp; <span class="keyword">int</span>(data) &lt; <span class="built_in">len</span>(mssTable) &#123; <span class="comment">// 验证 ACK 的正确性</span></span><br><span class="line">			...</span><br><span class="line">			n, err := ctx.createConnectedEndpoint(s, s.ackNumber<span class="number">-1</span>, s.sequenceNumber<span class="number">-1</span>, rcvdSynOptions)</span><br><span class="line">			<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">				e.deliverAccepted(n)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e.handleSynSegment 做的事情就是创建 handshake 结构体，执行三步握手，然后将完成握手的新的 endpoint 传入 Accept 队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">handleSynSegment</span><span class="params">(ctx *listenContext, s *segment, opts *header.TCPSynOptions)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> decSynRcvdCount() <span class="comment">// 不论最后有没有成功建立连接，把半连接数量 -1</span></span><br><span class="line">	</span><br><span class="line">	n, err := ctx.createEndpointAndPerformHandshake(s, opts)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	e.deliverAccepted(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *listenContext)</span> <span class="title">createEndpointAndPerformHandshake</span><span class="params">(s *segment, opts *header.TCPSynOptions)</span> <span class="params">(*endpoint, *tcpip.Error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Create new endpoint.</span></span><br><span class="line">    irs := s.sequenceNumber <span class="comment">// irs: initial remote sequenceNUmber</span></span><br><span class="line">	cookie := l.createCookie(s.id, irs, encodeMSS(opts.MSS)) <span class="comment">// 同样需要使用 cookie 来实现验证</span></span><br><span class="line">	ep, err := l.createConnectedEndpoint(s, cookie, irs, opts)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Perform the 3-way handshake.</span></span><br><span class="line">	h, err := newHandshake(ep, l.rcvWnd)</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> err := h.execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		ep.Close()</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> ep, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看下 handshake 的 excute 方法，也就是具体执行握手的方法。在看代码之前我们要做到心中有 B 树，哦不，是连接状态机：</p><p><img src="/images/netstack/tcp_state.png" alt=""></p><p>注意这个函数可以在被动的 Listen 函数里调用，也可以在主动的 Connect 里被调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">execute</span><span class="params">()</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">	<span class="comment">// Initialize the resend timer.</span></span><br><span class="line">	resendWaker := sleep.Waker&#123;&#125;</span><br><span class="line">	timeOut := time.Duration(time.Second) <span class="comment">// 设置初始 RTO 为 1s</span></span><br><span class="line">	rt := time.AfterFunc(timeOut, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		resendWaker.Assert() <span class="comment">// RTO 后触发超时重传</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">defer</span> rt.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set up the wakers.</span></span><br><span class="line">	s := sleep.Sleeper&#123;&#125;</span><br><span class="line">	s.AddWaker(&amp;resendWaker, wakerForResend)</span><br><span class="line">	s.AddWaker(&amp;h.ep.notificationWaker, wakerForNotification)</span><br><span class="line">	s.AddWaker(&amp;h.ep.newSegmentWaker, wakerForNewSegment)</span><br><span class="line">	<span class="keyword">defer</span> s.Done()</span><br><span class="line"></span><br><span class="line">	synOpts := header.TCPSynOptions&#123;</span><br><span class="line">		WS:    h.rcvWndScale, <span class="comment">// 这里设置的是自己这一端的 wndScale</span></span><br><span class="line">		TS:    <span class="literal">true</span>,</span><br><span class="line">		TSVal: h.ep.timestamp(),</span><br><span class="line">		TSEcr: h.ep.recentTS,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> h.state == handshakeSynRcvd &#123;</span><br><span class="line">		synOpts.TS = h.ep.sendTSOk </span><br><span class="line">        <span class="comment">// handshakeSynRcvd 说明当前是由 Listen 调用的被动连接，由对方决定是否使用 TS 选项</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 注意以下的 ACK 序列号，如果是主动发起连接，该值为 0，相反，则值为 irs + 1</span></span><br><span class="line">	sendSynTCP(&amp;h.ep.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> h.state != handshakeCompleted &#123;</span><br><span class="line">		<span class="keyword">switch</span> index, _ := s.Fetch(<span class="literal">true</span>); index &#123;</span><br><span class="line">		<span class="keyword">case</span> wakerForResend: <span class="comment">// SYN+ACK 超时重传的情况</span></span><br><span class="line">			timeOut *= <span class="number">2</span> <span class="comment">// 指数退避行为</span></span><br><span class="line">			<span class="keyword">if</span> timeOut &gt; <span class="number">60</span>*time.Second &#123; <span class="comment">// 最大超时时间</span></span><br><span class="line">				<span class="keyword">return</span> tcpip.ErrTimeout</span><br><span class="line">			&#125;</span><br><span class="line">			rt.Reset(timeOut)</span><br><span class="line">			sendSynTCP(&amp;h.ep.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> wakerForNotification: <span class="comment">// 收到关闭信号</span></span><br><span class="line">			n := h.ep.fetchNotifications()</span><br><span class="line">			<span class="keyword">if</span> n&amp;notifyClose != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> tcpip.ErrAborted</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> wakerForNewSegment: <span class="comment">// 等待并处理新的 SYN 数据包或握手第三步的 ACK</span></span><br><span class="line">			<span class="keyword">if</span> err := h.processSegments(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> err</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，excute 首先发送一个 SYN + ACK 报文（注意这里对应主动和被动两种情况），然后进入循环直到建立连接。同理，h.processSegments 也对应两种情况。如果自己是主动连接，那么自己目前处于 SYN_SENT 状态，等待一个 SYN + ACK 报文并执行 synSentState：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">synSentState</span><span class="params">(s *segment)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">	<span class="comment">// RFC 793, page 37, states that in the SYN-SENT state, a reset is</span></span><br><span class="line">	<span class="comment">// acceptable if the ack field acknowledges the SYN.</span></span><br><span class="line">	<span class="keyword">if</span> s.flagIsSet(flagRst) &#123;</span><br><span class="line">		<span class="keyword">if</span> s.flagIsSet(flagAck) &amp;&amp; s.ackNumber == h.iss+<span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> tcpip.ErrConnectionRefused</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !h.checkAck(s) || !s.flagIsSet(flagSyn) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rcvSynOpts := parseSynSegmentOptions(s)</span><br><span class="line">	h.ep.maybeEnableTimestamp(&amp;rcvSynOpts) <span class="comment">// 设置是否允许时间戳选项</span></span><br><span class="line"></span><br><span class="line">	h.ackNum = s.sequenceNumber + <span class="number">1</span></span><br><span class="line">	h.flags |= flagAck</span><br><span class="line">	h.mss = rcvSynOpts.MSS</span><br><span class="line">	h.sndWndScale = rcvSynOpts.WS</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.flagIsSet(flagAck) &#123; <span class="comment">// 发出 SYN 后收到了 SYN + ACK，再发送一个 ACK，连接就完成建立了</span></span><br><span class="line">		h.state = handshakeCompleted</span><br><span class="line">		h.ep.sendRaw(<span class="literal">nil</span>, flagAck, h.iss+<span class="number">1</span>, h.ackNum, h.rcvWnd&gt;&gt;h.effectiveRcvWndScale())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以下这一端对应的是状态机那张图里的‘同时连接’的情况，此时作为主动方已经发出了一个 SYN，然后又收到了一个 SYN，此时只要发送一个 SYN + ACK，对于对方来说这个连接就已经建立了，对于自己来说，再收到一个 SYN + ACK 也算完成连接。</span></span><br><span class="line">	h.state = handshakeSynRcvd</span><br><span class="line">	synOpts := header.TCPSynOptions&#123;</span><br><span class="line">		WS:    h.rcvWndScale,</span><br><span class="line">		TS:    rcvSynOpts.TS,</span><br><span class="line">		TSVal: h.ep.timestamp(),</span><br><span class="line">		TSEcr: h.ep.recentTS,</span><br><span class="line">	&#125;</span><br><span class="line">	sendSynTCP(&amp;s.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是被动连接，那么自己目前处于 SYN_RCVD 状态，等待一个 ACK：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">synRcvdState</span><span class="params">(s *segment)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> s.flagIsSet(flagRst) &#123; <span class="comment">//</span></span><br><span class="line">		<span class="keyword">if</span> s.sequenceNumber.InWindow(h.ackNum, h.rcvWnd) &#123;</span><br><span class="line">			<span class="keyword">return</span> tcpip.ErrConnectionRefused</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !h.checkAck(s) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.flagIsSet(flagSyn) &amp;&amp; s.sequenceNumber != h.ackNum<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// 之前已经收到过了一个 SYN，然后又收到了一个 SYN，并且两次 seq 不同，那么认为对方抽风，发送 RST 关闭连接。</span></span><br><span class="line">		ack := s.sequenceNumber.Add(s.logicalLen())</span><br><span class="line">		seq := seqnum.Value(<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">if</span> s.flagIsSet(flagAck) &#123;</span><br><span class="line">			seq = s.ackNumber</span><br><span class="line">		&#125;</span><br><span class="line">		h.ep.sendRaw(<span class="literal">nil</span>, flagRst|flagAck, seq, ack, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> !h.active &#123;</span><br><span class="line">			<span class="keyword">return</span> tcpip.ErrInvalidEndpointState</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := h.resetState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		synOpts := header.TCPSynOptions&#123;</span><br><span class="line">			WS:    h.rcvWndScale,</span><br><span class="line">			TS:    h.ep.sendTSOk,</span><br><span class="line">			TSVal: h.ep.timestamp(),</span><br><span class="line">			TSEcr: h.ep.recentTS,</span><br><span class="line">		&#125;</span><br><span class="line">		sendSynTCP(&amp;s.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> s.flagIsSet(flagAck) &#123;</span><br><span class="line">		<span class="comment">// 如果之前协商好了要带上 timeStamp 选项，但是握手第三步没有带上时间戳，那么丢弃这个 ACK 数据包</span></span><br><span class="line">		<span class="keyword">if</span> h.ep.sendTSOk &amp;&amp; !s.parsedOptions.TS &#123;</span><br><span class="line">			atomic.AddUint64(&amp;h.ep.stack.MutableStats().DroppedPackets, <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新时间戳</span></span><br><span class="line">		h.ep.updateRecentTimestamp(s.parsedOptions.TSVal, h.ackNum, s.sequenceNumber)</span><br><span class="line"></span><br><span class="line">		h.state = handshakeCompleted </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="post-announce">感谢您的阅读，本文由 <a href="http://littlechao.top">Hexo</a> 版权所有。如若转载，请注明出处：Hexo（<a href="http://littlechao.top/2018/04/20/netstack_conn_handshake/">http://littlechao.top/2018/04/20/netstack_conn_handshake/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/04/16/netstack_tcp_overview/" title="netstack TCP(I) 总览"><i class="iconfont icon-prev"></i>netstack TCP(I) 总览</a></div><div class="post__prev post__prev--right"><a href="/2018/05/07/netstack_linklayer/" title="Netstack(II) 链路层">Netstack(II) 链路层<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/网络/">网络</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/netstack-tcp/">netstack_tcp</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/IP/">IP</a><span class="block-list-count">2</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/06/10/internet_protocol/" title="IP(II) 协议"><div class="item__cover"><img src="/images/ip/ip.jpg" alt="IP(II) 协议"></div><div class="item__info"><h3 class="item__title">IP(II) 协议</h3><span class="item__text">2018-06-10</span></div></a></li><li class="latest-post-item"><a href="/2018/06/04/ip_addr/" title="IP(I) 地址"><div class="item__cover"><img src="/images/ip/ip.jpg" alt="IP(I) 地址"></div><div class="item__info"><h3 class="item__title">IP(I) 地址</h3><span class="item__text">2018-06-04</span></div></a></li><li class="latest-post-item"><a href="/2018/06/02/go_http_server_3/" title="Go http server (III)"><div class="item__cover"><img src="/images/http/go_web_cover.jpg" alt="Go http server (III)"></div><div class="item__info"><h3 class="item__title">Go http server (III)</h3><span class="item__text">2018-06-02</span></div></a></li><li class="latest-post-item"><a href="/2018/06/01/go_http_server_2/" title="Go http server (II)"><div class="item__cover"><img src="/images/http/go_web_cover.jpg" alt="Go http server (II)"></div><div class="item__info"><h3 class="item__title">Go http server (II)</h3><span class="item__text">2018-06-01</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/IP/">IP</a></li><li class="tag-item"><a class="tag-link" href="/tags/Intellij/">Intellij</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/dart/">dart</a></li><li class="tag-item"><a class="tag-link" href="/tags/golang/">golang</a></li><li class="tag-item"><a class="tag-link" href="/tags/net/">net</a></li><li class="tag-item"><a class="tag-link" href="/tags/netstack/">netstack</a></li><li class="tag-item"><a class="tag-link" href="/tags/node/">node</a></li><li class="tag-item"><a class="tag-link" href="/tags/react/">react</a></li><li class="tag-item"><a class="tag-link" href="/tags/redux/">redux</a></li><li class="tag-item"><a class="tag-link" href="/tags/tcp/">tcp</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Baoding, Hebei Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>shichao1996@gmail.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="https://image.littlechao.top/20180512113439000006.jpg" alt="logo" title="Hexo"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>