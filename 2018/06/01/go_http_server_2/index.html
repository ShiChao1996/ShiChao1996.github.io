<!DOCTYPE html><html><head><meta charset="utf-8"><title>Go http server (II) | LOVAE BLOG</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="Lovae"><meta name="designer" content="minfive"><meta name="keywords" content="lovae, shichao blog, 前端博客, 前端, 程序员, 前端开发, 全栈开发, node.js, javascript, 后台, golang, 网络编程"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://littlechao.top/2018/06/01/go_http_server_2/index.html"><link rel="icon" type="image/png" href="https://image.littlechao.top/20180512113931000007.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Hexo"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(http://oo12ugek5.bkt.clouddn.com/blog/images/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Hexo" alt="Hexo"><img src="https://image.littlechao.top/20180506131200000003.jpg" alt="Hexo"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/http/go_web_cover.jpg" alt="Go http server (II)"></div><header class="post__info"><h1 class="post__title">Go http server (II)</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">Lovae</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-06-01</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"></ul></div></div></header><div class="post__content"><h2 id="GO-http-server-II-Server-Handler"><a href="#GO-http-server-II-Server-Handler" class="headerlink" title="GO http server (II) Server.Handler"></a>GO http server (II) Server.Handler</h2><blockquote><p>上一篇里讨论了 go 官方库里提供的 http 服务框架，使用者需要关心的是 Server 的 handler 域。当 Server 调用 Serve 函数时 Server.Handler 为 nil，则默认使用 http.DefaultServeMux 作为 handler。</p></blockquote><h3 id="DefaultServeMux"><a href="#DefaultServeMux" class="headerlink" title="DefaultServeMux"></a>DefaultServeMux</h3><p>来看一下它的定义和描述：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeMux is an HTTP request multiplexer.</span></span><br><span class="line"><span class="comment">// It matches the URL of each incoming request against a list of registered</span></span><br><span class="line"><span class="comment">// patterns and calls the handler for the pattern that</span></span><br><span class="line"><span class="comment">// most closely matches the URL.</span></span><br></pre></td></tr></table></figure><p>简单的说，它就是一个路由分发器。</p><h5 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu    sync.RWMutex</span><br><span class="line">	m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">  	<span class="comment">//路由规则，一个string对应一个mux实例对象，map的key就是注册的路由表达式(string类型的)</span></span><br><span class="line">	hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123; <span class="comment">// 代表着一个 路由-处理函数 组合</span></span><br><span class="line">	explicit <span class="keyword">bool</span> <span class="comment">//表示 patern 是否已经被明确注册过了</span></span><br><span class="line">	h        Handler</span><br><span class="line">	pattern  <span class="keyword">string</span> <span class="comment">//路由表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前提到过，Server.Handler 需要有路由功能，并且可以执行路由对应的处理函数。当注册路由时，调用<code>mux.Handle</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">	mux.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: invalid pattern "</span> + pattern)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> mux.m[pattern].explicit &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">		mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">	&#125;</span><br><span class="line">	mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">		mux.hosts = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 以下是很有用的功能:当pattern == “/tree/”时,</span></span><br><span class="line">  	<span class="comment">// 会插入一条永久的重定向到“/tree”,注意最后的斜杠。</span></span><br><span class="line">  	<span class="comment">// 当然前提是在这之前没有“/tree”这条路由</span></span><br><span class="line">	n := <span class="built_in">len</span>(pattern)</span><br><span class="line">	<span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; pattern[n<span class="number">-1</span>] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]].explicit &#123;</span><br><span class="line">		<span class="comment">//如果包含host，</span></span><br><span class="line">		path := pattern</span><br><span class="line">		<span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">			<span class="comment">// In pattern, at least the last character is a '/', so</span></span><br><span class="line">			<span class="comment">// strings.Index can't be -1.</span></span><br><span class="line">			path = pattern[strings.Index(pattern, <span class="string">"/"</span>):]</span><br><span class="line">		&#125;</span><br><span class="line">		url := &amp;url.URL&#123;Path: path&#125;</span><br><span class="line">		mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码挺多，其实主要就做了一件事，向<code>DefaultServeMux</code>的<code>map[string]muxEntry</code>中增加对应的路由规则和<code>handler</code>。注意这里每条路由并没有包含我们常说的 GET、POST 等等区别，主要有两个原因：一是为了简洁，很多开发者偏好不同的处理方法，官方库只提供最基本的功能；二是不直接和请求方法绑定起来便于写 RESTful API。</p><p>但是这里还要注意路径结尾的<code>/</code>,这时候该路径为一个子树，如果能完全匹配到其子路由，那么也能匹配到这个子树，不过路由越长，优先级越大；如果不能完全匹配到其子路由，会匹配到这个子树的路由。比如有一个根路由<code>/</code>、<code>/example/</code>和 <code>/example/1</code>，那么访问<code>/example/2</code>时，会匹配到<code>/example/</code>，访问<code>/nothing</code>会匹配到<code>/</code>。</p><h5 id="处理路由请求"><a href="#处理路由请求" class="headerlink" title="处理路由请求"></a>处理路由请求</h5><p>注册好路由，并且没有使用别的 handler 时，DefaultServerMux 的 ServeHTTP 就会在接收到 request 时被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">   handler := sh.srv.Handler</span><br><span class="line">   <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">      handler = DefaultServeMux </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">      handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServeHTTP 主要从之前注册好的路由表中获取对应的 handler：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   h, _ := mux.Handler(r) <span class="comment">// 匹配和 request 最接近的路由，拿到对应的 handler</span></span><br><span class="line">   h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   host := stripHostPort(r.Host)</span><br><span class="line">   path := cleanPath(r.URL.Path)</span><br><span class="line">   <span class="keyword">if</span> path != r.URL.Path &#123;</span><br><span class="line">      _, pattern = mux.handler(host, path)</span><br><span class="line">      url := *r.URL</span><br><span class="line">      url.Path = path</span><br><span class="line">      <span class="keyword">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">      <span class="comment">//注意这里的重定向 handler</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	mux.mu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line">	<span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">		h, pattern = mux.match(host + path)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h, pattern = mux.match(path) <span class="comment">// match 做的是字符串匹配的工作</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">		h, pattern = NotFoundHandler(), <span class="string">""</span> </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有找到匹配的路由时，返回 NotFoundHandler， 默认只是写入 404 not found，但通常我们会自定义它，然后返回一个专门的好看的 404 页面。</p><p>如果需要重定向，则会通过返回的 redirectHandler 调用 Redirect：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Redirect</span><span class="params">(w ResponseWriter, r *Request, url <span class="keyword">string</span>, code <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> u, err := parseURL(url); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// If url was relative, make absolute by</span></span><br><span class="line">      <span class="comment">// combining with request path.</span></span><br><span class="line">      <span class="comment">// The browser would probably do this for us,</span></span><br><span class="line">      <span class="comment">// but doing it ourselves is more reliable.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// NOTE(rsc): RFC 2616 says that the Location</span></span><br><span class="line">      <span class="comment">// line must be an absolute URI, like</span></span><br><span class="line">      <span class="comment">// "http://www.google.com/redirect/",</span></span><br><span class="line">      <span class="comment">// not a path like "/redirect/".</span></span><br><span class="line">      <span class="comment">// Unfortunately, we don't know what to</span></span><br><span class="line">      <span class="comment">// put in the host name section to get the</span></span><br><span class="line">      <span class="comment">// client to connect to us again, so we can't</span></span><br><span class="line">      <span class="comment">// know the right absolute URI to send back.</span></span><br><span class="line">      <span class="comment">// Because of this problem, no one pays attention</span></span><br><span class="line">      <span class="comment">// to the RFC; they all send back just a new path.</span></span><br><span class="line">      <span class="comment">// So do we.</span></span><br><span class="line">      <span class="keyword">if</span> u.Scheme == <span class="string">""</span> &amp;&amp; u.Host == <span class="string">""</span> &#123;</span><br><span class="line">         oldpath := r.URL.Path</span><br><span class="line">         <span class="keyword">if</span> oldpath == <span class="string">""</span> &#123; <span class="comment">// should not happen, but avoid a crash if it does</span></span><br><span class="line">            oldpath = <span class="string">"/"</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// no leading http://server</span></span><br><span class="line">         <span class="keyword">if</span> url == <span class="string">""</span> || url[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">            <span class="comment">// make relative path absolute</span></span><br><span class="line">            olddir, _ := path.Split(oldpath)</span><br><span class="line">            url = olddir + url</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> query <span class="keyword">string</span></span><br><span class="line">         <span class="keyword">if</span> i := strings.Index(url, <span class="string">"?"</span>); i != <span class="number">-1</span> &#123;</span><br><span class="line">            url, query = url[:i], url[i:]</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// clean up but preserve trailing slash</span></span><br><span class="line">         trailing := strings.HasSuffix(url, <span class="string">"/"</span>)</span><br><span class="line">         url = path.Clean(url)</span><br><span class="line">         <span class="keyword">if</span> trailing &amp;&amp; !strings.HasSuffix(url, <span class="string">"/"</span>) &#123;</span><br><span class="line">            url += <span class="string">"/"</span></span><br><span class="line">         &#125;</span><br><span class="line">         url += query</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   w.Header().Set(<span class="string">"Location"</span>, hexEscapeNonASCII(url))</span><br><span class="line">   w.WriteHeader(code)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// RFC 2616 recommends that a short note "SHOULD" be included in the</span></span><br><span class="line">   <span class="comment">// response because older user agents may not understand 301/307.</span></span><br><span class="line">   <span class="comment">// Shouldn't send the response for POST or HEAD; that leaves GET.</span></span><br><span class="line">   <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">      note := <span class="string">"&lt;a href=\""</span> + htmlEscape(url) + <span class="string">"\"&gt;"</span> + statusText[code] + <span class="string">"&lt;/a&gt;.\n"</span></span><br><span class="line">      fmt.Fprintln(w, note)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，DefaultServerMux 只有一个最基本的路由功能，是一个最简单的 HTTP 服务框架。可是这通常不能满足我们的需求，于是我们可以根据我们自己的需要自定义一个简单通用的 HTTP Server 框架。</p><div class="post-announce">Thank you for reading, this article belongs to <a href="http://littlechao.top">Hexo</a> copyright, if reproduced, please indicate the source：Hexo（<a href="http://littlechao.top/2018/06/01/go_http_server_2/">http://littlechao.top/2018/06/01/go_http_server_2/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/05/29/go_http_server_1/" title="Go http server (I)"><i class="iconfont icon-prev"></i>Go http server (I)</a></div><div class="post__prev post__prev--right"><a href="/2018/06/02/go_http_server_3/" title="Go http server (III)">Go http server (III)<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/网络/">网络</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/netstack-tcp/">netstack_tcp</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/IP/">IP</a><span class="block-list-count">2</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/06/10/internet_protocol/" title="IP(II) 协议"><div class="item__cover"><img src="/images/ip/ip.jpg" alt="IP(II) 协议"></div><div class="item__info"><h3 class="item__title">IP(II) 协议</h3><span class="item__text">2018-06-10</span></div></a></li><li class="latest-post-item"><a href="/2018/06/04/ip_addr/" title="IP(I) 地址"><div class="item__cover"><img src="/images/ip/ip.jpg" alt="IP(I) 地址"></div><div class="item__info"><h3 class="item__title">IP(I) 地址</h3><span class="item__text">2018-06-04</span></div></a></li><li class="latest-post-item"><a href="/2018/06/02/go_http_server_3/" title="Go http server (III)"><div class="item__cover"><img src="/images/http/go_web_cover.jpg" alt="Go http server (III)"></div><div class="item__info"><h3 class="item__title">Go http server (III)</h3><span class="item__text">2018-06-02</span></div></a></li><li class="latest-post-item"><a href="/2018/06/01/go_http_server_2/" title="Go http server (II)"><div class="item__cover"><img src="/images/http/go_web_cover.jpg" alt="Go http server (II)"></div><div class="item__info"><h3 class="item__title">Go http server (II)</h3><span class="item__text">2018-06-01</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/IP/">IP</a></li><li class="tag-item"><a class="tag-link" href="/tags/Intellij/">Intellij</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/dart/">dart</a></li><li class="tag-item"><a class="tag-link" href="/tags/golang/">golang</a></li><li class="tag-item"><a class="tag-link" href="/tags/net/">net</a></li><li class="tag-item"><a class="tag-link" href="/tags/netstack/">netstack</a></li><li class="tag-item"><a class="tag-link" href="/tags/node/">node</a></li><li class="tag-item"><a class="tag-link" href="/tags/react/">react</a></li><li class="tag-item"><a class="tag-link" href="/tags/redux/">redux</a></li><li class="tag-item"><a class="tag-link" href="/tags/tcp/">tcp</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Baoding, Hebei Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>shichao1996@gmail.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="https://image.littlechao.top/20180512113439000006.jpg" alt="logo" title="Hexo"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>