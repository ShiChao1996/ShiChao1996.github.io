<!DOCTYPE html><html><head><meta charset="utf-8"><title>Go http server (III) | LOVAE BLOG</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="Lovae"><meta name="designer" content="minfive"><meta name="keywords" content="lovae, shichao blog, 前端博客, 前端, 程序员, 前端开发, 全栈开发, node.js, javascript, 后台, golang, 网络编程"><meta name="description" content="日常学习与兴趣交流的个人博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://littlechao.top/2018/06/02/go_http_server_3/index.html"><link rel="icon" type="image/png" href="https://image.littlechao.top/20180512113931000007.jpg" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="Hexo"><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(http://oo12ugek5.bkt.clouddn.com/blog/images/loader.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="Hexo" alt="Hexo"><img src="https://image.littlechao.top/20180506131200000003.jpg" alt="Hexo"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/images/http/go_web_cover.jpg" alt="Go http server (III)"></div><header class="post__info"><h1 class="post__title">Go http server (III)</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">Lovae</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-06-02</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"></ul></div></div></header><div class="post__content"><h2 id="GO-http-server-III-组建简易-HTTP-Server-框架"><a href="#GO-http-server-III-组建简易-HTTP-Server-框架" class="headerlink" title="GO http server (III) 组建简易 HTTP Server 框架"></a>GO http server (III) 组建简易 HTTP Server 框架</h2><blockquote><p>上篇提到 DefaultServerMux 作为默认的 HTTP Server 框架太过简单，缺少很多功能。这篇我们利用官方库和一些三方库来定制一个简易合用的 HTTP Server 框架。完整代码见<a href="https://github.com/TechcatsLab/apix" target="_blank" rel="noopener">这里</a></p></blockquote><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>首先要有 router 模块，这里我使用第三方 gorilla 框架的最小化路由模块 mux，它的作用和 DefaultServerMux 差不多，只不过支持了 RESTful API。</p><p>在添加路由和对应 handler 时，很可能我们写的处理函数有 bug，导致没有往 response 里写入内容就返回，这会造成客户端阻塞等待，所以当出现错误提前返回时，需要一个默认的错误处理函数，给客户端返回默认错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">struct</span> &#123;</span><br><span class="line">   router     *mux.Router</span><br><span class="line">   ctxPool    sync.Pool</span><br><span class="line">   errHandler <span class="function"><span class="keyword">func</span><span class="params">(w http.responseWriter, r *http.request)</span> </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>很多时候，执行路由对应 handler 时我们并不想直接操作 http.responseWriter 和 *http.request，并且希望有一些简单的封装，提供更多的功能。再者，这两个对象并不能很好的携带中间件处理过程中产生的一些参数。所以我们会定义一个 Context （下一节）来封装它们。每一个请求都应该有一个 Context，为了方便的管理，使用 sync.Pool 做一个 context 池。</p><p>创建新的 Router：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewRouter returns a router.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">   r := &amp;Router&#123;</span><br><span class="line">      router:     mux.NewRouter(),</span><br><span class="line">      errHandler: <span class="function"><span class="keyword">func</span><span class="params">(_ *Context)</span></span> &#123;&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   r.ctxPool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">      <span class="keyword">return</span> NewContext(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   r.router.NotFoundHandler = http.NotFoundHandler()</span><br><span class="line">   r.router.MethodNotAllowedHandler = MethodNotAllowedHandler()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>router 注册路由，由于使用 gorilla.mux，调用其 HandleFunc ，返回 router 本身，在调用 Method 即可指定请求方法。不过我们还可以在自己的 handler 执行之前，提供一些钩子，这里我们可以添加一些 filter 函数，以便功能扩展。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(rt *Router)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc, filters ...FilterFunc)</span></span> &#123;</span><br><span class="line">   rt.router.HandleFunc(pattern, rt.wrapHandlerFunc(handler, filters...)).Methods(<span class="string">"GET"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post adds a route path access via POST method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *Router)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc, filters ...FilterFunc)</span></span> &#123;</span><br><span class="line">   rt.router.HandleFunc(pattern, rt.wrapHandlerFunc(handler, filters...)).Methods(<span class="string">"POST"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wraps a HandlerFunc to a http.HandlerFunc.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *Router)</span> <span class="title">wrapHandlerFunc</span><span class="params">(f HandlerFunc, filters ...FilterFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">      c := rt.ctxPool.Get().(*Context)</span><br><span class="line">      <span class="keyword">defer</span> rt.ctxPool.Put(c)</span><br><span class="line">      c.Reset(w, r)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(filters) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> _, filter := <span class="keyword">range</span> filters &#123;</span><br><span class="line">            <span class="keyword">if</span> passed := filter(c); !passed &#123;</span><br><span class="line">               c.LastError = errFilterNotPassed</span><br><span class="line">               <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err := f(c); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         c.LastError = err</span><br><span class="line">         rt.errHandler(c)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>前面提到可以用一个 Context 包装 http.responseWriter 和 *http.request，并且提供一些额外的功能。额外的功能如 validator，用来对请求做参数验证。这个 validator 我们可以直接用一个第三方库，也可以做成 Interface 以便升级。</p><p>另外我们可能需要 Context 能够携带额外的信息，所以可以加一个 map 用来存储。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">   responseWriter http.ResponseWriter</span><br><span class="line">   request        *http.Request</span><br><span class="line">   Validator      *validator.Validate</span><br><span class="line">   store          <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要忘了在 Router 里面我们是用一个线程安全的池来管理 context ，也就是每次用完 context 需要还回去来避免临时分配带来的开销。所以别忘了还回去之前需要把 context 重置成原来的样子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Reset</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   c.responseWriter = w</span><br><span class="line">   c.request = r</span><br><span class="line">   c.store = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>有了 router 和 context，我们还需要封装一个 server。首先定义一个 EntryPoiont 结构体，当然名字随意。非常确认的是我们需要用到 http 包的 Server，还可以加上可能用到的 net.Listener。另外，我们需要方便的添加一些即插即用的工具，所以需要中间件，这里我使用第三方库 negroni 。然后我们可能需要一个通知关闭所有连接的机制，用一个 channel 可以做到。所以 EntryPoint 大致如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entrypoint <span class="keyword">struct</span> &#123;</span><br><span class="line">   server        *http.Server</span><br><span class="line">   listener      net.Listener</span><br><span class="line">   middlewares   []negroni.Handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="negroni"><a href="#negroni" class="headerlink" title="negroni"></a>negroni</h4><p>其实 negroni 的核心代码也很简单，就只是把多个 middleware 串起来使其能够串行调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Negroni <span class="keyword">struct</span> &#123;</span><br><span class="line">   middleware middleware</span><br><span class="line">   handlers   []Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> middleware <span class="keyword">struct</span> &#123;</span><br><span class="line">	handler Handler</span><br><span class="line">	next    *middleware</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">	ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键就是 Handler 接口，所有第三方实现的中间件要和 negroni 一起用的话，都要实现它，并且每个中间件执行完自己的功能后，要去调用 next 触发下一个中间件的执行。</p><p>添加中间件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Negroni)</span> <span class="title">Use</span><span class="params">(handler Handler)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"handler cannot be nil"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   n.handlers = <span class="built_in">append</span>(n.handlers, handler)</span><br><span class="line">   n.middleware = build(n.handlers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(handlers []Handler)</span> <span class="title">middleware</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> next middleware</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(handlers) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> voidMiddleware()</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(handlers) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		next = build(handlers[<span class="number">1</span>:])</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		next = voidMiddleware()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> middleware&#123;handlers[<span class="number">0</span>], &amp;next&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加中间件的时候，递归地调用 build ，把所有 middlewares 串起来。必然的，negroni 实现了 http.Handler 接口，这使得 Negroni 可以当做 http.Handler 传给 Server.Serve()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Negroni)</span> <span class="title">ServeHTTP</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   n.middleware.ServeHTTP(NewResponseWriter(rw), r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m middleware)</span> <span class="title">ServeHTTP</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	m.handler.ServeHTTP(rw, r, m.next.ServeHTTP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整合-router"><a href="#整合-router" class="headerlink" title="整合 router"></a>整合 router</h4><p>当所有中间件执行完了以后，应该把 context 传给 router 去执行对应的路由，所以把 router 作为最后一个中间件传到 negroni 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ep *Entrypoint)</span> <span class="title">buildRouter</span><span class="params">(router http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	n := negroni.New()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, mw := <span class="keyword">range</span> ep.middlewares &#123;</span><br><span class="line">		n.Use(mw)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n.Use(negroni.Wrap(http.HandlerFunc(router.ServeHTTP)))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然在启动 Server.Serve() 之前，还要把 ep.buildRouter 返回的对象赋给 ep.Server.Handler，使这个对象代替 DefaultServerMux。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ep *Entrypoint)</span> <span class="title">prepare</span><span class="params">(router http.Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      err       error</span><br><span class="line">      listener  net.Listener</span><br><span class="line">   ）</span><br><span class="line"></span><br><span class="line">   listener, err = net.Listen(<span class="string">"tcp"</span>, ep.configuration.Address)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ep.listener = listener</span><br><span class="line">   ep.server = &amp;http.Server&#123;</span><br><span class="line">      Addr:      ep.configuration.Address,</span><br><span class="line">      Handler:   ep.buildRouter(router),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以调用 start 跑起服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ep *Entrypoint)</span> <span class="title">Start</span><span class="params">(router http.Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> router == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errNoRouter</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := ep.prepare(router); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> ep.startServer()</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"Serving on:"</span>, ep.configuration.Address)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中间件封装"><a href="#中间件封装" class="headerlink" title="中间件封装"></a>中间件封装</h3><p>有的时候有一些现成的中间件，但是不能直接放到 negroni 里面用，就需要我们给它加一层封装。</p><p>例如，我们要做 jwt 验证，使用第三方的 <em>jwtmiddleware.JWTMiddleware，但是有的路径我们不需要 token，需要跳过 jwt 中间件。不方便改别人的代码，可以这样封装来代替原来的 </em>jwtmiddleware.JWTMiddleware：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Skipper <span class="function"><span class="keyword">func</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">JWTMiddleware</span> <span class="title">is</span> <span class="title">a</span> <span class="title">wrapper</span> <span class="title">of</span> <span class="title">go</span>-<span class="title">jwt</span>-<span class="title">middleware</span>, <span class="title">but</span> <span class="title">added</span> <span class="title">a</span> <span class="title">skipper</span> <span class="title">func</span> <span class="title">on</span> <span class="title">it</span>.</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">JWTMiddleware</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">   *jwtmiddleware.JWTMiddleware</span><br><span class="line">   skipper Skipper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <em>jwtmiddleware.JWTMiddleware 作为一个匿名变量，这样可以在自定义的 JWTMiddleware 上直接调用 </em>jwtmiddleware.JWTMiddleware 的函数。然后用 handler 函数覆盖原有的 HandlerWithNext 函数，这样就能通过调用时传入的 skipper 函数判断是否需要跳过 jwt：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *JWTMiddleware)</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request, next http.HandlerFunc)</span></span> &#123;</span><br><span class="line">   path := r.URL.Path</span><br><span class="line">   <span class="keyword">if</span> skip := jm.skipper(path); skip &#123;</span><br><span class="line">      next(w, r)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   jm.HandlerWithNext(w, r, next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后用 negroni 包装一下，使它能够直接被 negroni 使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NegroniJwtHandler</span><span class="params">(key <span class="keyword">string</span>, skipper Skipper, signMethod *jwt.SigningMethodHMAC, errHandler <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request, err <span class="keyword">string</span>)</span>) <span class="title">negroni</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> signMethod == <span class="literal">nil</span> &#123;</span><br><span class="line">      signMethod = jwt.SigningMethodHS256</span><br><span class="line">   &#125;</span><br><span class="line">   jm := jwtmiddleware.New(jwtmiddleware.Options&#123;</span><br><span class="line">      ValidationKeyGetter: <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">         <span class="keyword">return</span> []<span class="keyword">byte</span>(key), <span class="literal">nil</span></span><br><span class="line">      &#125;,</span><br><span class="line">      SigningMethod: signMethod,</span><br><span class="line">      ErrorHandler:  errHandler,</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> skipper == <span class="literal">nil</span> &#123;</span><br><span class="line">      skipper = defaulSkiper</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   JM := JWTMiddleware&#123;</span><br><span class="line">      jm,</span><br><span class="line">      skipper,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> negroni.HandlerFunc(JM.handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前为止我们实现了一个简易通用的 HTTP server 框架，虽然功能还不是很完善，不过好在可扩展性比较高，我们可以在此基础上任意扩展，可以添加上缓存、数据库、监控等等模块。</p><p>如果有兴趣的话，可以去看看 echo 的实现，其实也是大同小异。</p><p>最后，再放一遍项目<a href="https://github.com/TechCatsLab/apix" target="_blank" rel="noopener">地址</a>，还有一些别的库，欢迎 star 和 pr 啦！</p><div class="post-announce">Thank you for reading, this article belongs to <a href="http://littlechao.top">Hexo</a> copyright, if reproduced, please indicate the source：Hexo（<a href="http://littlechao.top/2018/06/02/go_http_server_3/">http://littlechao.top/2018/06/02/go_http_server_3/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/06/01/go_http_server_2/" title="Go http server (II)"><i class="iconfont icon-prev"></i>Go http server (II)</a></div><div class="post__prev post__prev--right"><a href="/2018/06/04/ip_addr/" title="IP(I) 地址">IP(I) 地址<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">日常学习与兴趣交流的个人博客</p></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/network-protocol/">network protocol</a><span class="block-list-count">10</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/netstack-tcp/">netstack_tcp</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/go-sdk/">go sdk</a><span class="block-list-count">5</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/06/17/dhcp/" title="DHCP 和自动配置"><div class="item__cover"><img src="/images/ip/ip.jpg" alt="DHCP 和自动配置"></div><div class="item__info"><h3 class="item__title">DHCP 和自动配置</h3><span class="item__text">2018-06-17</span></div></a></li><li class="latest-post-item"><a href="/2018/06/15/go_sdk_runtime_string/" title="Go String 笔记"><div class="item__cover"><img src="https://image.littlechao.top/20180301160118000011.jpg" alt="Go String 笔记"></div><div class="item__info"><h3 class="item__title">Go String 笔记</h3><span class="item__text">2018-06-15</span></div></a></li><li class="latest-post-item"><a href="/2018/06/12/arp/" title="ARP 地址解析协议"><div class="item__cover"><img src="/images/ip/ip.jpg" alt="ARP 地址解析协议"></div><div class="item__info"><h3 class="item__title">ARP 地址解析协议</h3><span class="item__text">2018-06-12</span></div></a></li><li class="latest-post-item"><a href="/2018/06/10/internet_protocol/" title="IP(II) 协议"><div class="item__cover"><img src="/images/ip/ip.jpg" alt="IP(II) 协议"></div><div class="item__info"><h3 class="item__title">IP(II) 协议</h3><span class="item__text">2018-06-10</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/IP/">IP</a></li><li class="tag-item"><a class="tag-link" href="/tags/Intellij/">Intellij</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/dart/">dart</a></li><li class="tag-item"><a class="tag-link" href="/tags/golang/">golang</a></li><li class="tag-item"><a class="tag-link" href="/tags/net/">net</a></li><li class="tag-item"><a class="tag-link" href="/tags/netstack/">netstack</a></li><li class="tag-item"><a class="tag-link" href="/tags/node/">node</a></li><li class="tag-item"><a class="tag-link" href="/tags/react/">react</a></li><li class="tag-item"><a class="tag-link" href="/tags/redux/">redux</a></li><li class="tag-item"><a class="tag-link" href="/tags/tcp/">tcp</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，主要用于分享日常学习、生活及工作的一些心得总结。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Baoding, Hebei Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>shichao1996@gmail.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="https://image.littlechao.top/20180512113439000006.jpg" alt="logo" title="Hexo"></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>