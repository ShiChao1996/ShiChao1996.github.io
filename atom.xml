<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://littlechao.top/"/>
  <updated>2018-06-30T03:33:18.830Z</updated>
  <id>https://littlechao.top/</id>
  
  <author>
    <name>Lovae</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>防火墙和网络地址转换</title>
    <link href="https://littlechao.top/network-protocol/nat_firewall.html"/>
    <id>https://littlechao.top/network-protocol/nat_firewall.html</id>
    <published>2018-06-21T16:00:00.000Z</published>
    <updated>2018-06-30T03:33:18.830Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防火墙和网络地址转换"><a href="#防火墙和网络地址转换" class="headerlink" title="防火墙和网络地址转换"></a>防火墙和网络地址转换</h2><blockquote><p>互联网发展到现在，最主要有两点问题：</p><ul><li>一是容易遭受攻击，通常使用防火墙来限制和控制互联网中流量的流向</li><li>二是 IPv4 地址数量已经枯竭，虽然 IPv6 的进程在加快，但在完全应用之前，还是需要 NAT 地址转换来缓解 IPv4 地址不足的压力</li></ul></blockquote><h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>常见的防火墙分为两种，<em>包过滤防火墙</em> 和 <em>代理防火墙</em>。它们主要的区别是操作的协议层次不同。包过滤防火墙是一个互联网路由器，可以丢弃符合（或不符合）一定条件的数据包，而代理防火墙可以看作一个多宿主的服务器主机。</p><h4 id="包过滤防火墙"><a href="#包过滤防火墙" class="headerlink" title="包过滤防火墙"></a>包过滤防火墙</h4><p>简单的过滤包括网络层或传输层报头中各个部分的比较，如 IP 地址、IP 选项、ICMP 报文的类型，或是根据端口确定的各种服务。</p><p>这里还可将其分为无状态和有状态的。无状态即对每个数据包单独处理，而有状态要考虑该报文是否为分片，能够关联已经到达或即将到达的数据包来推断流的信息。</p><p>通常来说，对于外出的规则很少，而为了防范各种攻击，只允许很少流量进入。</p><p><img src="/images/ip/nat/filter_firewall.png" alt=""></p><h4 id="代理防火墙"><a href="#代理防火墙" class="headerlink" title="代理防火墙"></a>代理防火墙</h4><p>代理防火墙并不是真正意义上的路由器，它只是运行一个火多个<em>应用层网关</em>的主机，不转发 IP 报文，但能在应用层中继两个连接之间的特定类型的流量。</p><p><img src="/images/ip/nat/proxy_firewall.png" alt=""></p><p>最常见的有两种，HTTP 代理防火墙和 SOCKS 代理防火墙</p><ul><li>HTTP 代理防火墙</li></ul><p>也叫 Web 代理，只支持 HTTP 和 HTTPS。对于客户端来说，它是服务器，对于服务器来说，它是客户端。这种代理往往提供 Web 缓存功能，保存网页副本，减少延迟。也能作为<em>内容过滤器</em>，基于“黑名单”来阻止用户访问某些网站。相反的，有一些<em>隧道代理服务器</em>可以避免用户的访问被“黑名单”所过滤。</p><ul><li>SOCKS 协议</li></ul><p>SOCKS 协议可以用于 Web 之外的服务，通常用作科学上网。<a href="https://en.wikipedia.org/wiki/SOCKS" target="_blank" rel="noopener">more</a></p><h3 id="NAT-地址转换"><a href="#NAT-地址转换" class="headerlink" title="NAT 地址转换"></a>NAT 地址转换</h3><blockquote><p>NAT （Network Address Translation），本质上是允许在互联网不同地方重复使用相同的 IP 地址的机制。当所有进出的流量通过 NAT 设备时，该设备把内部的地址空间和外部全球地址空间分割开。</p></blockquote><p><img src="/images/ip/nat/nat.png" alt=""></p><h4 id="基本-NAT-和-NAPT"><a href="#基本-NAT-和-NAPT" class="headerlink" title="基本 NAT 和 NAPT"></a>基本 NAT 和 NAPT</h4><p>基本 NAT 只执行 IP 地址的重写，本质上将私有 IP 改写为一个公共地址，一个内部地址对应一个外部地址。</p><p><img src="/images/ip/nat/addr_trans.png" alt=""></p><p>比较流行的方式是使用端口号来作为标识，通常使用一个外部地址(也可以是一个 IP 地址池)：</p><p><img src="/images/ip/nat/addr_port_trans.png" alt=""></p><p>很明显 NAPT 可以减少对公共 IP 地址的需求。</p><p>不过注意，并不是说，NAT 内部的地址一定是私有地址范围，也可以是公网地址。原理上是可以接受的，但如果私有地址内部要访问一个远端地址，而这个地址正好呗内部某个主机使用，则造成屏蔽，永远到达不了远端系统。</p><p>通常我们说的 NAT 同时包含传统 NAT 和 NAPT。</p><h5 id="NAT-和-TCP"><a href="#NAT-和-TCP" class="headerlink" title="NAT 和 TCP"></a>NAT 和 TCP</h5><p>对于 TCP 连接来说，需要保持 源 IP、源端口、目标 IP、目标端口 的四元组，NAT 会创建一个内部状态记住一个新的连接，以便收到该链接数据的时候，能够正确的返回给内部主机，这种状态叫 NAT 映射。</p><p>当连接正常断开（交换 FIN 包）时，这条映射会被清除。但如果连接没有正常关闭，会造成 NAT 映射无法删除。</p><p>NAT 在发出 SYN 报文后激活一个<em>连接计时器</em>，如果超时没有收到 ACK，那么删除映射。在建立连接后也激活一个<em>会话计时器</em>，时间通常为小时单位，如果没有数据传输并且会话计时器超时，那么响内部主机发送<em>探测</em>报文，以检测连接是否还“活着”，如果活着，重置计时器，如果连接已经断开，则会收到内部主机的 RST，然后清除映射。</p><p>另外，NAT 无法处理 IP 分片的报文，因为分片报文中除了第一个分片，都不包含端口信息。</p><h4 id="NAT-端口转换和过滤行为"><a href="#NAT-端口转换和过滤行为" class="headerlink" title="NAT 端口转换和过滤行为"></a>NAT 端口转换和过滤行为</h4><h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><p>NAT 的操作方式差别很大，大部分细节设计具体的地址和端口映射。</p><p><img src="/images/ip/nat/port_mapping.png" alt=""></p><ul><li>若对于任何 Y1、Y2，X1:x1=X2:x2，那么称 NAT 是<em>独立于端点的</em></li><li>若仅当 Y1=Y2 时，X1:x1=X2:x2，那么称 NAT 是<em>依赖于地址的</em></li><li>若仅当 Y1:y1=Y2:y2 时，X1:x1=X2:x2，那么 NAT 是<em>依赖于端口和地址的</em></li></ul><h5 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h5><p>为了安全的考虑，对每种方式有不同的过滤行为：</p><table><thead><tr><th style="text-align:center">行为名称</th><th style="text-align:left">转换行为</th><th>过滤行为</th></tr></thead><tbody><tr><td style="text-align:center">独立于端点的</td><td style="text-align:left">对于任何 Y1、Y2，X1:x1=X2:x2</td><td>只要任何 X1:x1 存在，允许任何数据包进入</td></tr><tr><td style="text-align:center">依赖于地址的</td><td style="text-align:left">仅当 Y1=Y2 时，X1:x1=X2:x2</td><td>只要 X1之前联系过 Y1，就允许任何来自 Y1 的数据</td></tr><tr><td style="text-align:center">依赖于端口和地址的</td><td style="text-align:left">仅当 Y1:y1=Y2:y2 时，X1:x1=X2:x2</td><td>只要 X1之前联系过 Y1:y1，就允许任何来自 Y1:y1 的数据</td></tr></tbody></table><h5 id="静态-NAT"><a href="#静态-NAT" class="headerlink" title="静态 NAT"></a>静态 NAT</h5><p>有时候互联网上的服务器也位于 NAT 之后，要想提供稳定的服务，必须保证每次转换的 IP 和端口完全相同。可以采用<em>静态配置</em>，也叫<em>端口转发</em>。</p><h5 id="NAT-环回"><a href="#NAT-环回" class="headerlink" title="NAT 环回"></a>NAT 环回</h5><p>当一台主机要访问同一个 NAT 私有空间的服务器，且只知道服务器提供服务的公用地址时，源地址会是 Y:y 还是 Y1:y1 呢？</p><p><img src="/images/ip/nat/nat_loopback.png" alt=""></p><p>实际上 NAT 设备都支持 X 以 X1:x1 为源地址到达 Y，这种行为称作有“外部源 IP 地址和端口”的<em>发夹</em>行为。</p><h4 id="NAT-穿越"><a href="#NAT-穿越" class="headerlink" title="NAT 穿越"></a>NAT 穿越</h4><p>当讨论 client/server 模型时，client 通过 NAT 向服务器发送请求，在 NAT 上生产了映射，那么服务器响应的数据可以畅通的返回。</p><p>但如果通信是以 P2P 为基础，那么 NAT 给通信带来了巨大的困难，特别是当双方的 NAT 不是独立于端口的时候。如：A、B 主机均在“依赖于端口和地址的 NAT”之后，A 主机向 B 主机发起连接，那么 B 主机所在的 NAT 设备没有关于 A 的信息，则会丢弃数据。反过来，B 要连接 A 也会被丢弃。</p><p>有的应用采用 TCP <em>同时连接</em> 的技术来解决这个问题。A 和 B 在“同一时刻”向对方发送 SYN，在经过各自的 NAT 设备时，都产生了一个映射，那么对方的 SYN 到来的时候，就能够通过 NAT 设备。当然并不是真的同时，允许差一些时间，但是不能太长（大约 6 s ？），因为太长的时间差内，很可能 NAT 设备已经删除了映射。</p><p>不过这种办法可靠性不是特别高，需要更可靠的方法：STUN 和 TURN。详见<a href="https://cloud.tencent.com/developer/article/1005490" target="_blank" rel="noopener">more</a></p><h3 id="配置防火墙和-NAT"><a href="#配置防火墙和-NAT" class="headerlink" title="配置防火墙和 NAT"></a>配置防火墙和 NAT</h3><p>NAT 通常只需要很少的配置，但防火墙通常需要配置，大多数网络中，NAT、IP 路由、防火墙等功能都在一台设备上。</p><p>防火墙需要一套说明匹配条件的指令来控制流量，通常叫<em>访问控制列表</em>（Access Control List，ACL）。许多防火墙允许在处理顺序中的某一点运用防火墙规则。Linux 中，主要使用 iptables。</p><p><img src="/images/ip/nat/iptables_routing.svg" alt=""></p><p>如图，有五个重要节点（POSTROUTING/FORWARD/POSTROUTING/INPUT/OUTPUT），每个节点上有一条 <em>链</em>，这个链可以有多个行为组成：</p><ul><li>FILTER，负责过滤数据包</li><li>NAT，负责地址转换</li><li>MANGLE，拆解报文，做出修改并重新封装</li><li>RAW，关闭连接追踪</li></ul><p>其中，每种行为有对应的 <em>表</em>，这个表就是对应行为的多条规则，比如过滤有多条规则：IP 地址不能为 x.x.x.x；端口必须为 3000 等等。</p><p>链和表关系：</p><p><img src="/images/ip/nat/iptables_chain_table.png" alt=""></p><p>可以用如下命令查看 Linux iptables 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -t 代表查看哪个表，-L 表示 list</span></span><br><span class="line">iptables -t filter -L</span><br></pre></td></tr></table></figure><p>如下命令添加规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令语法：iptables -t 表名 -A 链名 匹配条件 -j 动作</span></span><br><span class="line">iptables -t filter -A INPUT -s 192.168.1.146 -j DROP</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;防火墙和网络地址转换&quot;&gt;&lt;a href=&quot;#防火墙和网络地址转换&quot; class=&quot;headerlink&quot; title=&quot;防火墙和网络地址转换&quot;&gt;&lt;/a&gt;防火墙和网络地址转换&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;互联网发展到现在，最主要有两点问题：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="network protocol" scheme="https://littlechao.top/categories/network-protocol/"/>
    
    
      <category term="IP" scheme="https://littlechao.top/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>DHCP 和自动配置</title>
    <link href="https://littlechao.top/network-protocol/dhcp.html"/>
    <id>https://littlechao.top/network-protocol/dhcp.html</id>
    <published>2018-06-16T16:00:00.000Z</published>
    <updated>2018-06-17T09:17:47.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DHCP-和自动配置"><a href="#DHCP-和自动配置" class="headerlink" title="DHCP 和自动配置"></a>DHCP 和自动配置</h2><blockquote><p>为了使用 TCP/IP 协议族，每台主机都要有一定的配置信息，特别是 IP 地址。通常这些配置信息有三种方法获得：</p><ul><li>手工获取</li><li>通过一个系统服务获得</li><li>通过某种算法获得</li></ul></blockquote><p>手工获取就是静态配置 IP、DNS 等信息，主要讨论后两种方法。</p><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP），它动态的分配 IP 地址和其他信息（子网掩码、路由器 IP 地址、DNS 服务器 IP 地址）给主机。DHCP 的设计基于早期的 Internet 引导程序协议(BOOTP)，它使用<em>租用</em>的概念来扩展 BOOTP，允许客户机使用一个商定好的时间来配置信息。通常客户端使用 68 端口，服务端使用 67 端口。</p><p>租用的时间是一个重要的配置参数。如果时间太短，可以提供一个可用性较高的地址池，但频繁的分配导致稳定性减小、网络流量负荷增大；较长的租期稳定性较好，但通常会较快耗尽可用地址。默认的租期在 12~24 小时，在租期过半时，客户端可以申请续租。</p><h4 id="DHCPv4-和-BOOTP"><a href="#DHCPv4-和-BOOTP" class="headerlink" title="DHCPv4 和 BOOTP"></a>DHCPv4 和 BOOTP</h4><p>DHCP 是基于 BOOTP 的，并且 DHCPv4 是兼容 BOOTP 的，BOOTP 消息格式如下：</p><p><img src="/images/ip/bootp.png" alt=""></p><h5 id="基本字段"><a href="#基本字段" class="headerlink" title="基本字段"></a>基本字段</h5><table><thead><tr><th style="text-align:center">字段</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">yiaddr</td><td>从 server 送回 client 之 DHCP OFFER 与 DHCPACK 封包中，此栏填写分配给 client 的 IP 地址。</td></tr><tr><td style="text-align:center">TRANSACTION ID</td><td>DHCP REQUEST 时产生的数值，以作 DHCPREPLY 时的依据。</td></tr><tr><td style="text-align:center">sname</td><td>Server 之名称字符串，以 0x00 结尾。</td></tr><tr><td style="text-align:center">siaddr</td><td>若 client 需要透过网络开机，从 server 送出之 DHCP OFFER、DHCPACK、DHCPNACK封包中，此栏填写开机程序代码所在 server 之地址。</td></tr><tr><td style="text-align:center">SECONDS</td><td>Client 端启动时间（秒）。（时间戳）</td></tr><tr><td style="text-align:center">options</td><td>允许厂商定议选项（Vendor-Specific Area)，以提供更多的设定信息（如：Netmask、Gateway、DNS、等等）。</td></tr><tr><td style="text-align:center">OP</td><td>若是 client 送给 server 的封包，设为 1 ，反向为 2。</td></tr><tr><td style="text-align:center">HTYPE</td><td>硬件类别，Ethernet 为 1。</td></tr><tr><td style="text-align:center">HOPS</td><td>若封包需经过 router 传送，每站加 1 ，若在同一网内，为 0。</td></tr><tr><td style="text-align:center">HLEN</td><td>硬件地址长度， Ethernet 为 6。</td></tr><tr><td style="text-align:center">giaddr</td><td>若需跨网域进行 DHCP 发放，此栏为 relay agent 的地址，否则为 0。</td></tr><tr><td style="text-align:center">FLAGS</td><td>从 0 到 15 共 16 bits ，最左一 bit 为 1 时表示 server 将以广播方式传送封包给 client ，其余尚未使用。</td></tr><tr><td style="text-align:center">file</td><td>若 client 需要透过网络开机，此栏将指出开机程序名称，稍后以 TFTP 传送。</td></tr><tr><td style="text-align:center">ciaddr</td><td>要是 client 端想继续使用之前取得之 IP 地址，则列于这里。</td></tr><tr><td style="text-align:center">chaddr</td><td>Client 之硬件地址。</td></tr></tbody></table><h5 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h5><p>DHCP 通过选项来扩展 BOOTP，选项用于携带 IP 地址之外的信息，如 子网掩码、路由器地址、DNS 地址 等等，其中还有一个消息类型选项，表明一个 BOOTP 报文是哪种 DHCP 消息：</p><ul><li>DHCP DISCOVER</li><li>DHCP OFFER</li><li>DHCP REQUEST</li><li>DHCP DECLINE</li><li>DHCP ACK</li><li>DHCP NACK</li><li>DHCP RELEASE</li></ul><h4 id="DHCP-操作过程"><a href="#DHCP-操作过程" class="headerlink" title="DHCP 操作过程"></a>DHCP 操作过程</h4><p>DHCP 消息是带有一组特殊选项的 BOOTP 消息，客户端连接到网络时，首先要发现网络中的 DHCP 服务器，然后请求服务器：</p><p><img src="/images/ip/DHCPv4.png" alt=""></p><h5 id="discover"><a href="#discover" class="headerlink" title="discover"></a>discover</h5><p>一开始 client 使用 0 地址作为源，广播地址作为目标地址，去发现 DHCP 服务器：</p><p><img src="/images/ip/dhcp_discover.png" alt=""></p><h5 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h5><p>然后收到服务器的 offer 响应，这里可能有多个服务器，先收集所有信息。</p><p><img src="/images/ip/dhcp_offer.png" alt=""></p><p>注意大部分 offer 是以广播形式发送的，只不过我的电脑设置了单播，所以抓的包是单播形式。但是这里非常奇怪，为什么把还没正式分配的地址作为目标地址呢？如果网络中已经有一个 IP 地址为 10.0.0.51 的主机怎么办 ？这样为什么能够找到 client 主机呢？rfc 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If the BROADCAST bit is cleared to 0, the message SHOULD be sent as an IP unicast to the IP address specified in the &apos;yiaddr&apos; field and the link-layer address specified in the &apos;chaddr&apos; field.</span><br></pre></td></tr></table></figure><p>但 rfc 回答了第一个问题。第二个问题，注意图中 offer 之前，服务器发送了一个 ARP 报文，这是在探测目前是否有主机使用了这个 IP 地址，通常是没有的，如果有，那么服务器会在 offer 中提供另一个 IP 地址。第三个问题，通过 Mac 地址找到 client，虽然此时 client IP 地址(0.0.0.0) 和 报文目标 IP 地址不同，不过 client 并不会丢弃这个报文（这很特殊）。</p><h5 id="request"><a href="#request" class="headerlink" title="request"></a>request</h5><p>offer 响应包含了服务器 可以提供的 IP 地址，client 从多个里面选取自己想要的（通常是以前使用过的），然后发送广播包请求：</p><p><img src="/images/ip/dhcp_request.png" alt=""></p><h5 id="ACK、NAK"><a href="#ACK、NAK" class="headerlink" title="ACK、NAK"></a>ACK、NAK</h5><p>服务器收到请求后，再次确认是否可以分配，然后响应 ACK 或 NAK 同意或不同意这个请求，如果发送 ACK，那么 client 就拥有了一个合法的 IP 地址，并且 client 发送 GARP 宣告自己的身份使得同网络的主机更新 ARP 缓存。</p><p>另外，client 从 ACK 中得到租用时间 T，计算出更新时间 T1=T/2，重新绑定时间 T2=7T/8.</p><h4 id="DHCP-状态机"><a href="#DHCP-状态机" class="headerlink" title="DHCP 状态机"></a>DHCP 状态机</h4><p><img src="/images/ip/dhcp_fsm.png" alt=""></p><h4 id="DHCPv6"><a href="#DHCPv6" class="headerlink" title="DHCPv6"></a>DHCPv6</h4><p>DHCPv6 过程和 DHCPv4 类似，消息类型和 DHCPv4 对应如下：</p><table><thead><tr><th style="text-align:center">DHCPv6</th><th>DHCPv4</th></tr></thead><tbody><tr><td style="text-align:center">SOLICIT</td><td>DISCOVER</td></tr><tr><td style="text-align:center">ADVERTISE</td><td>OFFER</td></tr><tr><td style="text-align:center">REQUEST</td><td>REQUEST</td></tr><tr><td style="text-align:center">RENEW</td><td>REQUEST</td></tr><tr><td style="text-align:center">REBIND</td><td>DISCOVER</td></tr><tr><td style="text-align:center">REPLY</td><td>ACK/NAK</td></tr><tr><td style="text-align:center">DECLINE</td><td>DECLINE</td></tr></tbody></table><p>略。</p><h3 id="DHCP-中继"><a href="#DHCP-中继" class="headerlink" title="DHCP 中继"></a>DHCP 中继</h3><p>以上 DHCP 服务有一个前提条件，就是服务器要和客户端在同一个网段，因为广播无法跨过路由器。如果一个企业有上百个部门，对应上百个子网，要配置上百个 DHCP 服务器。配置麻烦不说，而且资源分配可能不均衡，很可能出现一个部门地址不够分，另一个却有很多空闲。</p><p>所以需要统一管理分配，可是如何跨越广播域呢？可以通过一个中继来帮助客户端和服务器发现彼此。</p><h4 id="DHCP-中继代理"><a href="#DHCP-中继代理" class="headerlink" title="DHCP 中继代理"></a>DHCP 中继代理</h4><p>当DHCP客户端与服务器不在同一个子网上，就必须有DHCP中继代理来转发DHCP请求和应答消息。DHCP中继代理的数据转发，与通常路由转发是不同的，通常的路由转发相对来说是透明传输的，设备一般不会修改IP包内容。而DHCP中继代理接收到DHCP消息后，进行<strong>转换源目的IP，MAC</strong>生成一个DHCP消息，然后转发出去。</p><p>在DHCP客户端看来，DHCP中继代理就像DHCP服务器；在DHCP服务器看来，DHCP中继代理就像DHCP客户端。 </p><p>不需要在各个用户网关设备上启用DHCP server功能，而只要在网络中心安装一个 DHCP 服务器，就可以实现对多个网段的动态IP管理，统一维护，即Client—Relay—Server 模式的DHCP动态IP管理</p><ul><li>当dhcp client 启动并进行dhcp 初始化时，它会在本地网络广播配置请求报文。</li><li>如果本地网络存在 dhcp server，则可以直接进行 dhcp 配置，不需要 dhcp relay。</li><li>如果本地网络没有 dhcp server，则与本地网络相连的具有 dhcprelay 功能的网络设备收到该广播报文后，将进行适当处理并转发给指定的其它网络上的 dhcp server。</li><li>dhcp server 根据 dhcp client 提供的信息进行相应的配置，并通过 dhcp relay 将配置信息发送给 dhcp client，完成对dhcp client 的动态配置。</li></ul><h3 id="无状态地址自动配置"><a href="#无状态地址自动配置" class="headerlink" title="无状态地址自动配置"></a>无状态地址自动配置</h3><p>对于一个全球性的地址，这些地址的某一部分通常需要被管理，也就是通过 DHCP 动态分配的。但如果只是<a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E8%B7%AF%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">链路本地</a>的地址，通常通过<em>自动配置</em>来获得，也就是主机自己决定自己的 IP 地址。称为<em>无状态地址自动配置</em>（SLAAC）。</p><h4 id="IPv4-链路本地的动态配置"><a href="#IPv4-链路本地的动态配置" class="headerlink" title="IPv4 链路本地的动态配置"></a>IPv4 链路本地的动态配置</h4><p>当一个网络没有 DHCP 服务器和中继，主机不能获取 IP 地址，那么只能自己分配一个链路本地地址。IPv4 链路本地的范围是 168.254.0.1~168.254.254.254，使用子网掩码 255.255.0.0。</p><p>这种方法也叫自动专用 IP 寻址（Auto Private IP Addressing）。就是从特定范围随机选择一个地址，然后通过 GARP 检查是否有冲突。</p><h4 id="链路本地-IPv6-的-SLAAC"><a href="#链路本地-IPv6-的-SLAAC" class="headerlink" title="链路本地 IPv6 的 SLAAC"></a>链路本地 IPv6 的 SLAAC</h4><p>无状态地址自动配置（StateLess Address Auto Config，SLAAC）可用于无路由器环境，只分配链路本地地址。IPv6 的链路本地地址以 fe80::/10 为前缀，最后 N 位是一个<em>接口 ID（IID）</em>，其余位为 0。IID 可以通过主机的 Mac 地址按照一定的规则来生成，也可以是一个随机数，基本可以保证局域网中的唯一性。</p><p><img src="/images/ip/ipv6_link_local.png" alt=""></p><p>由于没有路由器，这个地址只能在子网内部使用，不可路由。</p><h4 id="全球地址的-IPv6-SLAAC"><a href="#全球地址的-IPv6-SLAAC" class="headerlink" title="全球地址的 IPv6 SLAAC"></a>全球地址的 IPv6 SLAAC</h4><p>一个节点获得链路本地地址后，还可能需要一个或多个全球地址。全球地址的形成类似于链路本地地址，只不过前缀不再是 fe80::/10，而是由路由器给出的可以路由的前缀。</p><p><img src="/images/ip/ipv6_global.png" alt=""></p><h4 id="无状态-DHCP"><a href="#无状态-DHCP" class="headerlink" title="无状态 DHCP"></a>无状态 DHCP</h4><p>无状态 DHCP 模式下， DHCPv6 提供 IP 地址以外的其他信息。在分配 IP 地址时，需要维护 IP 地址的租用状态（见前面的 DHCP 状态机），如果不提供 IP 地址，那么也就不用维护状态，故称无状态 DHCP。</p><p>通常把 IPv6 全球地址 SLAAC 和无状态 DHCP 结合起来用。</p><h3 id="相关攻击"><a href="#相关攻击" class="headerlink" title="相关攻击"></a>相关攻击</h3><p>最大的漏洞就是如果有恶意主机，冒充正常主机，不断使用伪造的 Mac 地址来申请 IP 地址，那么 IP 地址资源很快用尽。可以采用授权的方式，使得合法的请求才能获取 IP 地址，同时限制未授权用户的数量，像链路层认证（如 WIFI 网络使用的 WPA2）就有助于限制未授权客户机的数量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DHCP-和自动配置&quot;&gt;&lt;a href=&quot;#DHCP-和自动配置&quot; class=&quot;headerlink&quot; title=&quot;DHCP 和自动配置&quot;&gt;&lt;/a&gt;DHCP 和自动配置&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;为了使用 TCP/IP 协议族，每台主机都要有一定
      
    
    </summary>
    
      <category term="network protocol" scheme="https://littlechao.top/categories/network-protocol/"/>
    
    
      <category term="IP" scheme="https://littlechao.top/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>Go String 笔记</title>
    <link href="https://littlechao.top/go-sdk/go_sdk_runtime_string.html"/>
    <id>https://littlechao.top/go-sdk/go_sdk_runtime_string.html</id>
    <published>2018-06-14T16:00:00.000Z</published>
    <updated>2018-06-15T16:05:05.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-String-笔记"><a href="#Go-String-笔记" class="headerlink" title="Go String 笔记"></a>Go String 笔记</h2><h3 id="什么是-string-？"><a href="#什么是-string-？" class="headerlink" title="什么是 string ？"></a>什么是 string ？</h3><p>标准库<code>builtin</code>的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type string</span><br><span class="line"></span><br><span class="line">string is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable.</span><br></pre></td></tr></table></figure><p>简单的来说字符串是一系列 8 位字节的集合，通常但不一定代表 UTF-8 编码的文本。字符串可以为空，但不能为  nil。而且字符串的值是不能改变的。<br>不同的语言字符串有不同的实现，在 go 的源码中 <code>src/runtime/string.go</code>，string 在底层的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    str unsafe.Pointer</span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 str 其实是个指针，指向某个数组的首地址，这个数组就是一个字节数组，里面存着 string 的真正内容。其实字节数组指针更像是 c 语言的字符串形式，而在 go 里，对其进行封装。不同的是， c 语言的 string 是以 null 或 <code>/0</code> 结尾，计算长度的时候对其遍历；而 go 的 string 结尾没有特殊符号，只不过用空间换时间，把长度存在了 len 字段里。</p><p>那么问题来了，我们平时用的 string 又是什么呢？它的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">string</span> <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>。。。好像和刚刚说的不太一样哈(-_-!)。这个 string 就是一个<em>名叫 string 的类型</em>，其实什么也不代表。只不过为了直观，使用的时候，把 stringStruct 转换成 string 类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostringnocopy</span><span class="params">(str *<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">ss := stringStruct&#123;str: unsafe.Pointer(str), <span class="built_in">len</span>: findnull(str)&#125;</span><br><span class="line">s := *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;ss))</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了验证，我们可以试一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">"fmt"</span></span><br><span class="line">   <span class="string">"unsafe"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="string">"nnnn"</span></span><br><span class="line">   fmt.Println(a)</span><br><span class="line">   <span class="keyword">var</span> b = (*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(&amp;a)) + <span class="number">8</span>));</span><br><span class="line">    <span class="comment">// 按照 stringStruct 结构，把 a 地址偏移 int 的长度位，得到 len 字段地址</span></span><br><span class="line">    <span class="comment">// 这里我的电脑是 64 位，而系统寻址以一个在节为单位，所以 +8</span></span><br><span class="line">   fmt.Println(*b) <span class="comment">// 这里输出的是 a 的长度 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string-操作"><a href="#string-操作" class="headerlink" title="string 操作"></a>string 操作</h3><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><p>我们可以用 + 来完成字符串的拼接，就像这样：s := x+y+z+… 底层如何实现的呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tmpBuf [tmpStringBufSize]<span class="keyword">byte</span> <span class="comment">// 这是一个很重要的类型，tmpStringBufSize 为常量 32，但这个值并没有什么科学依据(-_-!)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstrings</span><span class="params">(buf *tmpBuf, a []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;<span class="comment">// 把所有要拼接的字符串放到 a 里面</span></span><br><span class="line">idx := <span class="number">0</span></span><br><span class="line">l := <span class="number">0</span></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123; <span class="comment">// 这里主要计算总共需要的长度，以便分配内存</span></span><br><span class="line">n := <span class="built_in">len</span>(x)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l+n &lt; l &#123;</span><br><span class="line">throw(<span class="string">"string concatenation too long"</span>)</span><br><span class="line">&#125;</span><br><span class="line">l += n</span><br><span class="line">count++</span><br><span class="line">idx = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span> </span><br><span class="line">        <span class="comment">// 需要注意的是，虽然空字符串看起来不占空间，可是底层还是 stringStruct，仍要占两个 int 空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count == <span class="number">1</span> &amp;&amp; (buf != <span class="literal">nil</span> || !stringDataOnStack(a[idx])) &#123;</span><br><span class="line"><span class="keyword">return</span> a[idx] <span class="comment">// count 为 1 表明不需要拼接，直接返回源 string，并且没有内存拷贝</span></span><br><span class="line">&#125;</span><br><span class="line">s, b := rawstringtmp(buf, l) <span class="comment">// 这里分配了一个长度为 l 字节的内存，这个内存并没有初始化</span></span><br><span class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="built_in">copy</span>(b, x) <span class="comment">// 把每个字符串的内容复制到新的字节数组里面</span></span><br><span class="line">b = b[<span class="built_in">len</span>(x):]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可是这里有个问题，b 是一个字节切片，而 x 是字符串，为什么能直接复制呢？</p><h4 id="与切片的转换"><a href="#与切片的转换" class="headerlink" title="与切片的转换"></a>与切片的转换</h4><p>内置函数copy会有一种特殊情况<code>copy(dst []byte, src string) int</code>，但是两者并不能直接 copy，需要把 string 转换成 []byte。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> b []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">*buf = tmpBuf&#123;&#125; <span class="comment">// 清零</span></span><br><span class="line">b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">b = rawbyteslice(<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(b, s)</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请新的内存，返回切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawbyteslice</span><span class="params">(size <span class="keyword">int</span>)</span> <span class="params">(b []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">cap</span> := roundupsize(<span class="keyword">uintptr</span>(size)) <span class="comment">// 使申请内存的大小为 8 的倍数</span></span><br><span class="line">p := mallocgc(<span class="built_in">cap</span>, <span class="literal">nil</span>, <span class="literal">false</span>) <span class="comment">// 第三个参数为 FALSE 表示不用给分配的内存清零</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> != <span class="keyword">uintptr</span>(size) &#123;</span><br><span class="line">memclrNoHeapPointers(add(p, <span class="keyword">uintptr</span>(size)), <span class="built_in">cap</span>-<span class="keyword">uintptr</span>(size)) <span class="comment">// 超出需要的部分内存清零</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, <span class="keyword">int</span>(<span class="built_in">cap</span>)&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="string-与内存"><a href="#string-与内存" class="headerlink" title="string 与内存"></a>string 与内存</h3><h5 id="string-字面量"><a href="#string-字面量" class="headerlink" title="string 字面量"></a>string 字面量</h5><p>前面提到过，字符串的值是不能改变的，可是为什么呢？</p><p>这里说的字符串通常指的是 <em>字符串字面量</em>，因为它的存储位置不在堆和栈上，通常 string 常量是编译器分配到<strong>只读段</strong>的(.rodata)，对应的数据地址不可修改。</p><p>不过等等，好像有什么不对？下面的代码为啥改了呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"aaaa"</span></span><br><span class="line">str = <span class="string">"bbbb"</span></span><br></pre></td></tr></table></figure><p>这是因为前面提到过的 stringStruct，我们拿到的 str 实际上是 stringStruct 转换成 string 的。常量<code>aaaa</code>被保存在了只读段，下面函数参数 str 就是这个常量的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostringnocopy</span><span class="params">(str *<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">ss := stringStruct&#123;str: unsafe.Pointer(str), <span class="built_in">len</span>: findnull(str)&#125;</span><br><span class="line">s := *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;ss))</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们拿到的 str 本来是 stringStruct.str ，给 str 赋值相当于给 stringStruct.str 赋值，使其指向 <code>bbbb</code>所在地只读段地址，而 <code>aaaa</code>本身是没有改变的。在改变 stringStruct.str 的同时，解释器也会更新 stringStruct.len 的值。</p><h5 id="动态-string"><a href="#动态-string" class="headerlink" title="动态 string"></a>动态 string</h5><p>所谓动态是指字符串 stringStruct.str 指向的地址不在只读段，而是指向由 malloc 动态分配的堆地址。尽管如此，直接修改 string 的内容还是非法的。要修改内容，可以先把 string 转成 []byte，不过这里会有一次内存拷贝，这点在转换的代码中可以看到。不过也可以做到 ‘零拷贝转换’：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(s <span class="keyword">string</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">sh := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">bh := reflect.SliceHeader&#123;</span><br><span class="line">Data: sh.Data,</span><br><span class="line">Len:  sh.Len,</span><br><span class="line">Cap:  sh.Len,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;bh))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种方法不建议使用，因为一旦 string 指向的内存位于只读段，转换成 []byte 后对其进行写操作会引发系统的段错误。</p><h5 id="临时-string"><a href="#临时-string" class="headerlink" title="临时 string"></a>临时 string</h5><p>有时候我们会把 []byte 转换成 string，通常也会发生一次内存拷贝，但有的时候我们只需要 ‘临时的’ 字符串，比如：</p><ul><li>使用 m[string(k)] 来查找map</li><li>用作字符拼接： <code>&quot;&lt;&quot;+string(b)+&quot;&gt;&quot;</code></li><li>用于比较： string(b)==”foo”</li></ul><p>这些情况下我们都只是临时的使用一下一个 []byte 的字符串形式的值，如果分配内存有点不划算，所以编译器会做出一些优化，使用如下函数来转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostringtmp</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &amp;&amp; <span class="built_in">len</span>(b) &gt; <span class="number">0</span> &#123;</span><br><span class="line">racereadrangepc(unsafe.Pointer(&amp;b[<span class="number">0</span>]),</span><br><span class="line"><span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)),</span><br><span class="line">getcallerpc(),</span><br><span class="line">funcPC(slicebytetostringtmp))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &amp;&amp; <span class="built_in">len</span>(b) &gt; <span class="number">0</span> &#123;</span><br><span class="line">msanread(unsafe.Pointer(&amp;b[<span class="number">0</span>]), <span class="keyword">uintptr</span>(<span class="built_in">len</span>(b)))</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 注意，以上两个 if 都为假，所以不会执行。不知道有什么用(-_-!)</span></span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>以上是读了 <code>src/runtime/string.go</code> 代码的一些个人想法，连蒙带猜，所以有些地方可能不太对，欢迎指出啦(^_^)！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go-String-笔记&quot;&gt;&lt;a href=&quot;#Go-String-笔记&quot; class=&quot;headerlink&quot; title=&quot;Go String 笔记&quot;&gt;&lt;/a&gt;Go String 笔记&lt;/h2&gt;&lt;h3 id=&quot;什么是-string-？&quot;&gt;&lt;a href=&quot;#什
      
    
    </summary>
    
      <category term="go sdk" scheme="https://littlechao.top/categories/go-sdk/"/>
    
    
      <category term="golang" scheme="https://littlechao.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>ARP 地址解析协议</title>
    <link href="https://littlechao.top/network-protocol/arp.html"/>
    <id>https://littlechao.top/network-protocol/arp.html</id>
    <published>2018-06-11T16:00:00.000Z</published>
    <updated>2018-06-13T13:11:58.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><blockquote><p>在网络通信中，主机和主机通信的数据包需要依据OSI模型从上到下进行数据封装，当数据封装完整后，再向外发出。所以在局域网的通信中，不仅需要源目IP地址的封装，也需要源目MAC的封装。上层应用程序更多关心IP地址而不关心MAC地址，所以需要通过ARP协议来获知目的主机的MAC地址</p><p>IP 协议使得报文可以跨越不同网络进行传输，当 IP 报文到达目标地址所在网络后，接下来要靠对方的 Mac 地址才能交付，这时候也要用到 ARP 地址解析协议。</p></blockquote><h3 id="ARP-原理"><a href="#ARP-原理" class="headerlink" title="ARP 原理"></a>ARP 原理</h3><h4 id="请求与应答"><a href="#请求与应答" class="headerlink" title="请求与应答"></a>请求与应答</h4><p>我在 Mac 上使用 ping 命令查询 192.168.0.105，由于不知道对方的 Mac 地址，所以先 ARP 请求。抓到的 ARP 请求报文如下：</p><p><img src="/images/ip/arp_req.png" alt=""></p><p>不知道对方是否存在以及在哪里，所以向所在网段发送链路层广播请求，询问谁是 192.168.0.105 ，也就是目标 Mac 地址为 ff:ff:ff:ff:ff:ff，并且带上自己的 IP 和 Mac 信息。响应报文如下：</p><p><img src="/images/ip/arp_res.png" alt=""></p><p>IP 地址为 ARP 目标 IP 地址的主机收到后，由于知道这个请求是谁发出的，就以单播的形式返回一个响应报文，并且告诉对方自己的 Mac 地址。其他主机收到 ARP 请求会默认丢弃。</p><p>请求方收到响应后，即可把目标 Mac 地址封装到帧里然后发送数据。</p><h4 id="ARP-缓存"><a href="#ARP-缓存" class="headerlink" title="ARP 缓存"></a>ARP 缓存</h4><p>为了提高效率，每个主机维护了一个 ARP 缓存，维护着从网络层地址到硬件地址的最新映射，每条映射有一个到期时间，默认是 20min。</p><p>当收到多条 ARP 回应的时候，ARP 缓存按照”后到优先”原则，新的缓存直接覆盖旧的。</p><h3 id="ARP-攻击"><a href="#ARP-攻击" class="headerlink" title="ARP 攻击"></a>ARP 攻击</h3><h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>正常主机收到 ARP 请求，如果 目标 IP 不是自己，那么丢弃此报文。但当存在恶意节点时，则会造成 ARP 攻击：</p><p><img src="/images/ip/arp_attack.png" alt=""></p><p>恶意节点会发送大量的 ARP 响应，由于“后到覆盖”原则，几乎总是拿到错误数据。那么主机 A 会把发给主机 B 的数据都发送给 主机 C。同理，如果主机 B 要发送数据给主机 A，那么 C 也会冒充 A，就形成了 A &lt;=&gt; C &lt;=&gt; B 的情形，这就是典型的<em>中间人攻击</em>。</p><p>更严重的情况是，恶意节点冒充网关，拦截所有流量，这时候恶意节点可以直接使别的主机断连，当然很容易被发现，所以更多的时候实行限速。最严重的是，可能会盗取个人信息和密码。</p><h4 id="防御-ARP-攻击"><a href="#防御-ARP-攻击" class="headerlink" title="防御 ARP 攻击"></a>防御 ARP 攻击</h4><blockquote><p><strong>ARP防御可以在网络设备上实现，也可以在用户端实现，更可以在网络设备和用户端同时实现</strong></p></blockquote><h5 id="网络设备防御"><a href="#网络设备防御" class="headerlink" title="网络设备防御"></a>网络设备防御</h5><p>先来了解下网络设备（例如这里的交换机）的防御技术，这种防御技术被称为<strong>DAI（Dynamic ARP Inspection）- 动态ARP检测</strong>，原理可以用两句话简单概括：</p><ul><li>交换机记录每个接口对应的 IP 地址和 MAC，即 <strong>port&lt;=&gt;mac&lt;=&gt;ip</strong>，生成DAI检测表；</li><li>交换机检测每个接口发送过来的 ARP 回应包，根据 DAI 表判断是否违规，若违规则丢弃此数据包并对接口进行惩罚</li></ul><p>如果判断出包是虚假的欺骗包，交换机马上丢弃这个包，并且可以对接口做惩罚（不同设备的惩罚方式有所不同，可以直接将接口”<strong>软关闭</strong>“，直接将攻击者断网；也可以”<strong>静默处理</strong>“，仅丢弃欺骗包，其他通信正常）</p><p>对于这个方案，有几点问题：</p><ul><li><p>交换机可以查看 IP ？</p><p>从现在的网络技术来看，分层界限越来越模糊，融合式的网络设备才是主流，现在的接入交换机基本能被Telnet/SSH/Web管理。不要被”交换机就是二层设备”给束缚了</p></li></ul><ul><li><p>如何生成 DAI 表 ？</p><p>在交换机上开启<strong>DHCP侦听</strong>技术，当用户第一次通过DHCP获取到地址的时候，交换机就把用户电脑的IP、MAC、Port信息记录在DHCP侦听表，后面ARP检测直接调用这张DHCP侦听表即可</p></li></ul><h5 id="主机防御"><a href="#主机防御" class="headerlink" title="主机防御"></a>主机防御</h5><p>主机有两种方法防御：</p><ul><li>安装 ARP 防火墙</li><li>静态绑定：静态绑定的信息比动态学习的优先级高</li></ul><h3 id="代理-ARP-PARP"><a href="#代理-ARP-PARP" class="headerlink" title="代理 ARP(PARP)"></a>代理 ARP(PARP)</h3><p>在发送数据包时需要填写目标 Mac 地址，可是如果源主机和目标主机不在同一个网络会如何？如图，client 向 Server 发送请求，client 上配置了默认网关。</p><p><img src="/images/ip/arp_non_proxy.png" alt=""></p><p>那么 client 上包的目标 Mac 填什么呢？很显然不可能知道 Server 的 Mac 地址：</p><ul><li>路由器隔离广播域，每个接口/网段都是独立的广播域</li><li>ARP 请求是二层广播包，广播包没法过路由器</li></ul><p>此时如果 client 上配置了默认网关，那么直接找到默认网关的 Mac 地址作为目标地址。</p><p>但如果没有默认网关，则采用<em>代理 ARP</em>。</p><blockquote><p>代理 ARP 本质上是一种欺骗，原理和 ARP 攻击一样，冒充目标地址，不过目的是为了正常通信</p></blockquote><p><img src="/images/ip/arp_proxy.png" alt=""></p><p>在这种情况下，路由器上如果配置了代理 ARP，则会冒充目的地址。</p><p>总结如下：</p><p><strong>①当电脑没有网关（采用代理ARP）时：”跨网段访问谁，就问谁的MAC”</strong></p><p><strong>②当电脑有网关（采用正常ARP）时：”跨网段访问谁，都问网关的MAC”</strong></p><p><strong>③无论哪种ARP，跨网段通信时，发送方请求得到的目标MAC地址都是网关MAC。</strong></p><h3 id="免费-无故-ARP-Gratuitous-ARP"><a href="#免费-无故-ARP-Gratuitous-ARP" class="headerlink" title="免费/无故 ARP(Gratuitous ARP)"></a>免费/无故 ARP(Gratuitous ARP)</h3><p><strong>用于检测局域网内的IP地址冲突</strong>，在一定程度上能够给用户和网络运维人员提供帮助。相比『免费』这个翻译，『无故』这个词其实会更加好理解：”<strong>在没有人问自己的情况下，无缘无故自问自答</strong>“。</p><p>如下是我的电脑和隔壁老王的电脑一起设置了静态 IP 地址，都设成 192.168.0.108，抓到的包：</p><p><img src="/images/ip/gratuitous_arp.png" alt=""></p><p>先看第四条，我的电脑设了静态 IP 后，广播发送无故 ARP，注意这里 tell 后面是 0.0.0.0，也就是说，不用告诉我谁是 192.168.0.108，只是我自己宣告，我就是 192.168.0.108。</p><p>再看第五条，这不是一个 ARP 响应，而是老王的电脑也在向外宣告，他自己是 192.168.0.108，可以看到下面详细信息里目标 Mac 地址是老王的(72结尾的)。我这里收到后，告诉他我才是 192.168.0.108。</p><p>然后两台机器就开始互怼，同一局域网的其他主机，则根据这两个免费 ARP 信息不断的修改本地 ARP 表。</p><p>之后老王把他的 IP 改回 DHCP（第二个红框），路由器(192.168.0.1)这里同时扮演了 DHCP 的分配者，它向外询问是否有人占用了 192.168.0.104 这个地址，没有收到回应，于是分配给老王这个地址。分配了地址后，老王还是要向外宣告他自己的身份，使得同局域网的主机刷新 ARP 缓存，同时检测是否还有地址冲突。</p><p>第三个红框是老王关闭 WIFI 又重启。</p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>讨论了三种 ARP：</p><ul><li>ARP：通过 IP 地址找到 Mac 地址</li><li>PARP：在没有网关的时候辅助通信</li><li>GARP：解决地址冲突的问题</li></ul><p>其实还有 RARP(Reverse ARP) 和 IARP(Inverse ARP)，不过使用极少，就不再赘述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ARP-协议&quot;&gt;&lt;a href=&quot;#ARP-协议&quot; class=&quot;headerlink&quot; title=&quot;ARP 协议&quot;&gt;&lt;/a&gt;ARP 协议&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在网络通信中，主机和主机通信的数据包需要依据OSI模型从上到下进行数据封装，当数据
      
    
    </summary>
    
      <category term="network protocol" scheme="https://littlechao.top/categories/network-protocol/"/>
    
    
      <category term="IP" scheme="https://littlechao.top/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>IP(II) 协议</title>
    <link href="https://littlechao.top/network-protocol/internet_protocol.html"/>
    <id>https://littlechao.top/network-protocol/internet_protocol.html</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-06-12T08:13:11.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Internet-协议"><a href="#Internet-协议" class="headerlink" title="Internet 协议"></a>Internet 协议</h1><blockquote><p>IP 是 TCP/IP 的核心协议，它提供的是<em>尽力而为</em>的服务。</p></blockquote><h2 id="IPv4-头部"><a href="#IPv4-头部" class="headerlink" title="IPv4 头部"></a>IPv4 头部</h2><p><img src="/images/ip/ipv4_hdr.png" alt=""></p><p>简单介绍一下一些字段：</p><ul><li><p>IHL ，initial header length。表示 IP 首部 长度。占 4 位，最大值为 15，单位是 32 位，也就是最大长度为 15 * 4 字节 = 60 字节</p></li><li><p>ToS，type of service。这个字段使用很少，于是被分为两个部分，前六位 DS，后两位位 ECN</p><ul><li>DS，distinguish service，服务区分。用于描述 IP 服务的类型，通常为 000000 ，表示<em>尽力而为</em>的服务。这个域极少使用</li><li>ECN，explicit congestion notification，显式拥塞提醒。这个字段用于在路由器由于拥塞丢弃数据时，显式的告知 TCP 发送方链路拥塞，以减缓发送速率</li></ul></li><li><p>第二行是关于 IP 分片的。16 位的标识区别了属于不同源报文的分片，后面三位标识分别表示</p><ul><li>当前报文是否为一个分片，1 表示是一个分片</li><li>是否允许分片，默认为 0，可以分片。如果需要分配，但是改标识位为 1，那么路由器丢弃该包</li><li>是否有更多分片，0 表示没有</li></ul><p>13 位的分片偏移表示当前分片在源数据中的位置，由于只有 13 位，但可能表示 16 位的数据，所以这里单位为 8 字节。如果当前包不是一个分片，则全为 0。</p></li><li><p>TTL，time to live，最开始表示 IP 包生存时间，现在表示剩余路由跳数，每经过一个路由，该值减一，若跳数为 0，那么路由器丢弃该包，并由 ICMP 告知发送方。这样可以防止包在路由环路中无限循环</p></li><li><p>协议字段，表示 IP 数据段有效荷载的数据类型。通常是传输层协议，17（UDP），6（TCP），但也可能表示其他协议，4（ipv4 in ipv4）</p></li><li><p>校验和，仅计算头部，由于每经过一个路由器 TTL 值减一，所以造成校验和字段重新计算</p></li><li><p>IP 选项，多数选项很少或从未使用，并且通常会在企业网络边界被防火墙拒绝或剥离，所以略过</p></li></ul><h2 id="IPv6-头部"><a href="#IPv6-头部" class="headerlink" title="IPv6 头部"></a>IPv6 头部</h2><p><img src="/images/ip/ipv6_hdr.png" alt=""></p><ul><li>IPv6 的头部精简了许多，版本、DS 和 ECN、跳数限制 都和 IPv4头部一个意思。</li><li>流标签本身也是一个比较复杂的话题，该字段用于某些对连接的服务质量有特殊要求的通信，诸如音频 或视频等实时数据传输。在IPv6中，同一信源和信宿之间可以有多种不同的数据流，彼此之间以非“0”流标记区分。如果不要求路由器做特殊处理，则该字段 值置为“0”。详见<a href="http://www.infocomm-journal.com/dxkx/article/2013/1000-0801/1000-0801-29-9-00083.shtml" target="_blank" rel="noopener">这里</a>。</li><li>负载长度表示数据段长度，包括扩展头部，最大 65535 个字节，超过这一字节数的负载，该字段 值置为“0”。不过 IPv6 支持超长数据报选项，单个分组最大可支持 4GB</li><li>下一个头部，8位。IPv6 通过增加扩展头部来实现一些想 IPv4 选项提供的特殊功能，这个字段说明紧跟着的下一个头部类型</li></ul><h3 id="IPv6-扩展头部"><a href="#IPv6-扩展头部" class="headerlink" title="IPv6 扩展头部"></a>IPv6 扩展头部</h3><p>IPv6 头部固定为 40 字节，扩展头部只在需要时添加，并且要求仅由终端主机处理（有一个例外）。扩展头部也可以是上层的协议如 TCP、UDP</p><p><img src="/images/ip/extend_hdr_1.png" alt=""></p><p>也可以是多个头部级联起来:</p><p><img src="/images/ip/extend_hdr_2.png" alt=""></p><p>需要注意的是，每种类型的扩展头部必须按照固定的顺序排列：</p><p><img src="/images/ip/extend_hdr_table.png" alt=""></p><p>这其中 hop-by-hop 和 destination 比较特殊，称为选项头部。 hop-by-hop 逐跳选项可以出现多次，destination 目的地选项可以出现两次（传输过程的 IP 地址和最终 IP 地址），别的头部只能出现一次。</p><h4 id="IPv6-选项"><a href="#IPv6-选项" class="headerlink" title="IPv6 选项"></a>IPv6 选项</h4><p>选项头部有固定的格式，被编码为 <em>类型-长度-值（TLV）</em>集合：</p><p><img src="/images/ip/ipv6_opt_fmt.png" alt=""></p><p>其中动作表示如果路由器不识别这个选项，应该做的操作：</p><table><thead><tr><th style="text-align:center">值</th><th style="text-align:left">动作</th></tr></thead><tbody><tr><td style="text-align:center">00</td><td style="text-align:left">跳过该选项，处理下一个选项或头部</td></tr><tr><td style="text-align:center">01</td><td style="text-align:left">丢弃该数据包</td></tr><tr><td style="text-align:center">10</td><td style="text-align:left">丢弃该数据包，并向源地址发送 <code>ICMPv6参数问题</code> 消息</td></tr><tr><td style="text-align:center">11</td><td style="text-align:left">与 10 相同，但仅当目的地址不是组播地址时才这样</td></tr></tbody></table><p>有如下常用的选项：</p><ul><li>超大有效负荷：可以携带有效荷载为 64KB ~ 4GB 的数据包。用此选项时，IPv6负载长度字段被置为 0。属于逐跳选项</li><li>隧道封装限制：隧封指把一个 IP 数据包封装在另一个 IP 报文的有效荷载部分。这个选项指明了封装的最大层数。属于‘目的地选项’</li><li>家乡地址：使用移动 IP 时，这个选项保存家乡地址的值。属于目的地选项</li></ul><h4 id="分片头部"><a href="#分片头部" class="headerlink" title="分片头部"></a>分片头部</h4><p>如果数据包大小超过下一跳的 MTU，那么任何主机和路由器可以将数据包分片（和 IPv4 不同的是，IPv4 有一个位用于说明是否能分片，但是 IPv6 没有）。分片头部如下，占 8 字节：</p><p><img src="/images/ip/fragment_hdr.png" alt=""></p><p>其中保留 8 位和 Res 2位都为全 0，目前都被接收方忽略。M，more，表示是否还有更多分片。分片偏移和 IPv4 一样，都为 13 位，并且都是以 8 字节位单位。</p><p>对于分片过程来说，一个数据包有两个部分，一个是“不可分片部分”，包括路由头部之前的所有头部，剩下的部分是“可分片部分”。不可分片部分在每个分片中都有一个副本。分片完成后要修改 IPv6 基本头部中的负载长度字段。</p><h2 id="IP-转发"><a href="#IP-转发" class="headerlink" title="IP 转发"></a>IP 转发</h2><p>大多数主机即可以配置位路由器，也可以配置为主机，前者会转发不是由它自己生成的数据包，后者不会。IP 层包括一些位于内存的信息，通常称为路由表。路由表包含的信息类似于如下示例：</p><table><thead><tr><th style="text-align:center">目的地</th><th style="text-align:left">掩码</th><th>网关（下一跳）</th><th>接口</th></tr></thead><tbody><tr><td style="text-align:center">0.0.0.0</td><td style="text-align:left">0.0.0.0</td><td>10.0.0.1</td><td>10.0.0.100</td></tr><tr><td style="text-align:center">10.0.0.0</td><td style="text-align:left">255.255.255.128</td><td>10.0.0.100</td><td>10.0.0.100</td></tr></tbody></table><h3 id="转发行为"><a href="#转发行为" class="headerlink" title="转发行为"></a>转发行为</h3><p>主机或路由器转发一条数据报时，使用报文中的目的 IP 地址 D 来执行<em>最长前缀匹配算法</em>：</p><ul><li>di = D^Mi，Mi 表示第 i 条路由表的掩码，把 di 和 ai (第 i 条路由表的目的地址)相比较，若 di 满足 ai，那么 ai 和 D 相“匹配”</li><li>找到所有“匹配”的条目，选择其中掩码 1 的个数最多的一条，将其下一跳字段的值作为转发的 IP 地址</li><li>如果没有找到匹配的条目，那么 ICMP 返回一个“主机不可达”错误</li></ul><h4 id="直接交付"><a href="#直接交付" class="headerlink" title="直接交付"></a>直接交付</h4><p>每个主机里也有自己缓存的路由表，当发送主机和目的主机在同一子网内，主机的路由表包含目的主机，那么不需要经过路由器，直接经过交换机就能到达目的地，并不关心 IP 地址。不过要提前知道对方的 Mac 地址，可以用 ARP 请求或者 IPv6 的邻居请求来获取。</p><h4 id="间接交付"><a href="#间接交付" class="headerlink" title="间接交付"></a>间接交付</h4><p>当源主机自己的路由表没有目的主机的信息，那么使用自己的默认路由条目，局域网内通常是 10.0.0.1，这通常是网关的地址，然后由路由器为我们转发到目的地。在每一跳的过程中，IP 地址可能不变，但底层的 Mac 地址一直在变，它是更新为下一跳的 IP 地址所对应的 Mac 地址。</p><h4 id="traceroute-原理"><a href="#traceroute-原理" class="headerlink" title="traceroute 原理"></a>traceroute 原理</h4><p>traceroute 命令会输出 IP 包经过的每一个路由节点的 IP 地址信息，那么它是如何做到的呢？</p><p><img src="/images/ip/traceroute.png" alt=""></p><p>还记得前面提到的 TTL 字段吗，当它减为 0 时，该包会被丢弃，并且由 ICMP 向源主机发送 “TTL 过期”错误。traceroute 利用这个特性，分别发送 TTL 为 1，2，3…的 IP 包，也就是说，在经过链路上的第一、二、三… 个节点时，都会由 ICMP 发送回来一个错误信息，这样就得知每个节点信息了。</p><p>那么如何判断已经到达目的地呢？事实上，traceroute 默认发送 UDP 报文，并且目标端口通常是选择对方没有开启的端口，这样在报文到达目的地后，对方返回一个 “端口不可达”错误。</p><p>由于是 UDP 报文，可能会丢失，所以每个 TTL 值发送三个报文：</p><p><img src="/images/ip/traceroute_icmp.png" alt=""></p><h2 id="移动-IP"><a href="#移动-IP" class="headerlink" title="移动 IP"></a>移动 IP</h2><p>许多 Internet 协议都要求节点的 IP 地址保持不变。如果其中的任一协议在移动设备上处于活动状态，并且其 IP 地址改变了，则应用该协议将失败。</p><p>如果移动计算机（即<strong>移动节点</strong>）移到新网络后其 IP 地址保持不变，则移动节点的地址不会反映新连接点。因此，所存在的路由协议无法将数据报正确路由到该移动节点。</p><p>移动 IP 通过允许移动节点使用两个 IP 地址，可以解决上述问题。第一个地址是<strong>家乡地址</strong>，它是固定的。第二个地址是<strong>转交地址</strong>，它在每个新连接点都会发生变化。移动 IP 允许计算机在 Internet 上自由漫游。另外，它还允许计算机在组织的网络上自由漫游，同时仍保持其家乡地址不变。因此，当用户更改计算机的连接点时，通信活动不会中断。</p><p><img src="/images/ip/mobile_ip.png" alt=""></p><p>通过使用该图中的移动 IP 拓扑，以下情形说明了数据报是如何在移动 IP 框架的不同点之间移动的。</p><ul><li>Internet 主机使用移动节点的家乡地址向移动节点发送数据报（此为标准的 IP 路由过程）。</li><li>如果移动节点位于家乡网络，则数据报会通过常规 IP 进程传送到移动节点。否则，数据报将传送到家乡代理。</li><li>如果移动节点位于外地网络，则家乡代理将数据报转发到外地代理。家乡代理必须将数据报封装到外部数据报中，以便外地代理的 IP 地址出现在外部 IP 数据包头。</li><li>外地代理将数据报传送到移动节点。</li><li>数据报通过使用标准的 IP 路由过程从移动节点发送到 Internet 主机。如果移动节点位于外地网络上，则包会传送到外地代理。外地代理随后会将数据报转发到 Internet 主机。</li><li>如果存在入口过滤 (ingress filtering)，则发送数据报的子网的源地址在拓扑结构上必须正确，否则路由器无法转发数据报。如果移动节点和通信节点之间的链路上存在这种情况，则外地代理需要提供反向隧道连接支持。然后，外地代理即可将移动节点所发送的每个数据报传送到其家乡代理。家乡代理随后将转发数据报，所使用的路径即是移动节点驻留在家乡网络的情况下数据报应采用的路径。此过程保证数据报必须遍历的所有链路的源地址均正确。</li></ul><p>步骤中的数据报封装指的是隧道，IP-over-IP</p><p><img src="/images/ip/mobile_ip_tunnel.png" alt=""></p><p>更多原理参考<a href="https://docs.oracle.com/cd/E19253-01/819-7058/6n91g7eb8/index.html" target="_blank" rel="noopener">这里</a></p><h2 id="IP-数据报的主机处理"><a href="#IP-数据报的主机处理" class="headerlink" title="IP 数据报的主机处理"></a>IP 数据报的主机处理</h2><h3 id="主机模式"><a href="#主机模式" class="headerlink" title="主机模式"></a>主机模式</h3><p>当主机有两个 IP 地址时，在主机接收到数据包时，可能会出现一些问题。有两种处理策略，分别是<em>强主机模式</em>和<em>弱主机模式</em></p><p>强主机模式中，只有当收到的包的目的 IP 地址与该报文到达的接口所配置的 IP 地址相同时，才把数据交付给本地协议栈。</p><p>而弱主机模式则不然，只要接收到的包的目的 IP 地址与主机的任何本地地址相匹配，那么不论到达哪个接口，都交付给本地协议栈处理。</p><p><img src="/images/ip/host_mode.png" alt=""></p><p>如，在强主机模式下，主机 A 从交换机收到 目的地址为 192.0.2.1 的数据包，那么丢弃它。而弱主机模式下，会接收它。</p><h3 id="地址选择"><a href="#地址选择" class="headerlink" title="地址选择"></a>地址选择</h3><p>当主机有多个 IP 地址，发送数据时，需要填写自己的 IP 地址，那么如何从多个 IP 地址中选择呢？特别是当一个主机有 IPv4 和 IPv6 地址时，地址选择失败可能导致非对称路由、不必要的分组。</p><p>默认规则是</p><ul><li>优先在相同范围内选择成对的源/目的地址</li><li>优先选择更小的范围以避免其他地址可用时使用临时地址</li><li>优先选择具有更长公共前缀的成对地址</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Internet-协议&quot;&gt;&lt;a href=&quot;#Internet-协议&quot; class=&quot;headerlink&quot; title=&quot;Internet 协议&quot;&gt;&lt;/a&gt;Internet 协议&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;IP 是 TCP/IP 的核心协议，它提供
      
    
    </summary>
    
      <category term="network protocol" scheme="https://littlechao.top/categories/network-protocol/"/>
    
    
      <category term="IP" scheme="https://littlechao.top/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>IP(I) 地址</title>
    <link href="https://littlechao.top/network-protocol/ip_addr.html"/>
    <id>https://littlechao.top/network-protocol/ip_addr.html</id>
    <published>2018-06-03T16:00:00.000Z</published>
    <updated>2018-06-12T08:13:11.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IP-地址结构"><a href="#IP-地址结构" class="headerlink" title="IP 地址结构"></a>IP 地址结构</h2><blockquote><p>Internet 中使用的网络层地址，又叫 IP 地址。每一个连接到 Internet 的设备至少有一个 IP 地址。IP 地址标志了流量的来源和去向。</p></blockquote><h3 id="IP-地址的表示"><a href="#IP-地址的表示" class="headerlink" title="IP 地址的表示"></a>IP 地址的表示</h3><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>IPv4 地址本质上是 32 位二进制整数，通常用<strong>点分十进制</strong>表示:</p><table><thead><tr><th style="text-align:left">点分十进制</th><th style="text-align:left">二进制</th></tr></thead><tbody><tr><td style="text-align:left">0.0.0.0</td><td style="text-align:left">00000000 00000000 00000000 00000000</td></tr><tr><td style="text-align:left">1.2.3.4</td><td style="text-align:left">00000001 00000010 00000011 00000100</td></tr></tbody></table><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>ipv6 地址长度为 128 位，被分为 8 个块表示，每个块包含 4 个十六进制数，块之间用 <code>:</code> 分隔。另外有一些规则:</p><ul><li>一个块中的前到 0 可以省略</li><li>全块的 0 可以用 <code>::</code> 代替。如：0:0:0:0:0:0:0:1 可以写成 ::1。另外 <code>::</code> 只能使用一次，并且只能在 0 最多的地方用，如果有两个一样多连续 0 的地方，前者可以使用 <code>::</code></li><li>在 ipv6 中嵌入 ipv4 地址可以使用混合符号形式。::ffff:10.0.0.1 可以表示 ipv4 地址 10.0.0.1。其中 ipv4地址紧邻 ffff，这被称为 ipv4 映射的 ipv6 地址</li><li>ipv6 地址低 32 位通常采用点分十进制，这被称为 <em>兼容 ipv4 的 ipv6 地址</em></li></ul><p>当 ipv6 地址和端口号一起使用时，<code>:</code> 可能造成歧义，所以用 <code>[]</code> 括起来：<code>http://[::3333:22]:443/</code></p><h3 id="基本的-IP-地址结构"><a href="#基本的-IP-地址结构" class="headerlink" title="基本的 IP 地址结构"></a>基本的 IP 地址结构</h3><h4 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h4><p>IP 地址中，被用于识别连接 Internet 或某些专用的内联网的计算机网络接口的地址，叫做单播地址，还有涉及多个接口或者有特殊用途的地址，包括广播、组播、多播地址。</p><h5 id="分类寻址"><a href="#分类寻址" class="headerlink" title="分类寻址"></a>分类寻址</h5><p>单播 IP 地址都有一个网络部分和一个主机部分，分别被用来识别网络和网络中的主机。IP 地址呗分为如下五大类：</p><p><img src="/images/ip/ip_class.png" alt=""></p><p>更形象一点如图：</p><p><img src="/images/ip/ip_class_pie_chart.png" alt=""></p><p>但是要注意的是，每个网络里的主机号，全 0 和全 1 的不能被分配给某个主机。全 1 的作为这个子网的广播地址使用。</p><h5 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h5><p>A 类地址的主机数量为 2^24 - 2，B 类地址的主机数量为 2^16 - 2，C 类地址为 2^8 - 2。实际上很难分配到一个大小合适的网络，于是在分类基础上加了子网的概念。</p><p><img src="/images/ip/sub_net.png" alt=""></p><p>如图，把一个 B 类地址的主机号 ‘借’ 出 8 位作为子网号的例子，这样把一个网络划分出来若干子网，以此来得到一个合适大小的网络。</p><h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>为了能够从 IP 地址中知道主机号中哪些是子网号，哪些是主机号，使用了一个 32 位二进制的子网掩码。它的每一位和 IP 地址一一对应，子网掩码某一位为 1 代表对应 IP 地址那一位不是主机号。</p><p><img src="/images/ip/subnet_mask.png" alt=""></p><p>写的时候为了简单，把 IP 地址和子网掩码 1 的位数写在一起，如：<code>128.3.4.5/23</code>。</p><p>要注意，只有划分子网内部路由器和主机知道子网结构，在需要子网寻址之前，互联网其他部分仍把它作为站点相关的地址来看。来看一个例子：</p><p><img src="/images/ip/subnet_example.png" alt=""></p><h5 id="可变长度子网掩码"><a href="#可变长度子网掩码" class="headerlink" title="可变长度子网掩码"></a>可变长度子网掩码</h5><p>Variable Length Subnet Mask, VLSM。在同一站点的不同部分，可以将不同长度的子网掩码应用于相同网络号。增加了配置的复杂性但是也提高了子网结构的灵活性。如图，三个不同掩码被用于 128.32.0.0/16 ，每个子网可以有不同数量的主机：</p><p><img src="/images/ip/vlsm_example.png" alt=""></p><h3 id="CIDR-和聚合"><a href="#CIDR-和聚合" class="headerlink" title="CIDR 和聚合"></a>CIDR 和聚合</h3><p>划分子网缓解了增长带来的痛苦，但是随着互联网规模增长，路由表的条目数越来越多，路由性能受到影响。</p><h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><p>为了缓解 v4 地址的压力，分类寻址采用了类似于 VLSM 的方案，<strong>无类别域间路由（Classless Inter-Domain Router, CIDR）</strong>。使用 CIDR，任何没有预定义的地址都可以作为同一个类的一部分，就是说，B 类地址和 C 类地址可以在同一个类。</p><p>注意，和普通子网掩码不同的是，CIDR 的掩码不仅限于一个站点，而是全球路由可见的。核心 Internet 路由器必须能够解释和处理 CIDR 掩码。 IP 地址加上一个 0~32 的数字，称为前缀，代表一个子网。</p><table><thead><tr><th style="text-align:left">前缀</th><th style="text-align:left">地址范围</th></tr></thead><tbody><tr><td style="text-align:left">0.0.0.0/0</td><td style="text-align:left">0.0.0.0 ~ 255.255.255.255</td></tr><tr><td style="text-align:left">128.0.0.0/1</td><td style="text-align:left">128.0.0.0 ~ 255.255.255.255</td></tr><tr><td style="text-align:left">128.0.0.0/24</td><td style="text-align:left">128.0.0.0 ~ 128.0.0.255</td></tr></tbody></table><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>前缀并没有解决路由表性能问题，但是可以把多条路由聚合成一条，以此减轻路由器压力。把网络拓扑排成一棵树，按照分层结构的思想来分配地址，可以在保证最短路由的情况下减少路由器路由条目。</p><p>下图是一个随意排布的、路由与位置无关的结构（a, 左图）和拓扑敏感的、位置与路由相关的结构（b, 右图），每个圆点代表路由器：</p><p><img src="/images/ip/cidr_gather.png" alt=""></p><p>两者最大的区别在于，a 中顶层路由节点为了能够路由到下面 8 个节点，需要储存 9 条（加上 other Parts 那一条）路由信息；而 b 中顶层节点只需要存储 3 条（同上）。</p><p>关键在于，b 把多条路由信息聚合成一条。聚合是把多个相邻的 IP 前缀合并成一个短前缀。</p><p><img src="/images/ip/ip_gather.png" alt=""></p><p>注意，只有连续的、数值相邻的地址才能被聚合，如果中间有一条地址不在此列，那么不能聚合。</p><h3 id="特殊用途地址"><a href="#特殊用途地址" class="headerlink" title="特殊用途地址"></a>特殊用途地址</h3><h4 id="IPv4-和-IPv6-转换"><a href="#IPv4-和-IPv6-转换" class="headerlink" title="IPv4 和 IPv6 转换"></a>IPv4 和 IPv6 转换</h4><p>IPv4 和 IPv6 转换时，采用特殊地址，称为<strong>嵌入 IPv4 的 IPv6 地址</strong>，如下，IPv6 前缀必须是以下之一：</p><p><img src="/images/ip/v4_to_v6.png" alt=""></p><p>其中，63~71 对应的 U 必须为 0。</p><h4 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h4><p>。。。</p><p>我不会</p><p>。。。</p><p>没看懂</p><p>。。。</p><p><img src="/images/ip/hehe.gif" alt="我不会"></p><p>。。。</p><p>以后再写吧</p><h3 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h3><p>IP 地址被分配为较大的块，由一些权威组织负责。这些权威机构给一些小型机构或者大型 ISP (Internet Service Provider) 分配 IP 地址。用户通常以地址前缀形式使用 ISP 地址空间，这些地址范围由 ISP 管理，被称为<strong>供应商聚合地址（PA）</strong>，可以和 ISP 的其他地址前缀聚合。但同时，这些地址是不可移植的。</p><p>另一种可选的地址空间类型称为<strong>供应商独立（PI）的地址空间</strong>，这些地址可以直接分配给用户，并且任何 ISP 都可以使用，但是通常和 ISP 的地址数值不相邻，所以不能聚合。</p><p>下面看一下一个站点分配了单播地址后的一些可能的场景</p><h4 id="单供应商-无网络-单个地址"><a href="#单供应商-无网络-单个地址" class="headerlink" title="单供应商/无网络/单个地址"></a>单供应商/无网络/单个地址</h4><p>这种情况最简单，ISP 分配了一个 IP 地址，然后通过网线连接到一台主机，这里没有形成网络。但这太主机还有其他的 IP 地址，包括本地环回的 127.0.0.1  或者 ::1</p><p>####单供应商/单个网络/单个地址 </p><p>这种场景大多是家庭局域网（LAN）或无线局域网（WLAN），由一台路由器连接 Internet。虽然每个连接到路由器的设备都被分配到一个 IP 地址，但是都是私有的，由 NAT 做转换，对于 ISP 来看，仍然只有一个地址。</p><h4 id="单供应商-多个网络-多个地址"><a href="#单供应商-多个网络-多个地址" class="headerlink" title="单供应商/多个网络/多个地址"></a>单供应商/多个网络/多个地址</h4><p>对应组织或者小型公司来说，一个 IP 地址，特别是当它只是临时分配的不固定的地址时，是不满足需求的。</p><p><img src="/images/ip/middle_net.png" alt=""></p><p>图中 DMZ 表示<em>非军事区</em>，在主防火墙之外，拥有公网地址，可以被互联网连接。</p><p>####多供应商/多个网络/多个地址</p><p>对于一些大型企业，通常使用多个 ISP 以便在失效时提供冗余连接。通常来说，只有一个 ISP 的组织拥有该 ISP 关联的 PA 地址。多个 ISP 的组织，可能有多个不能互相聚合的 PA 地址，或者 PA 地址 + PI 地址。这里讨论一下 <code>PA + PI</code> 的场景。</p><p><img src="/images/ip/multi_isp.png" alt=""></p><p>这里 C、D 相当于两个站点边界路由器，分别拥有一个 PA 地址和一个 PI 地址。</p><p>如果站点使用 PA 地址空间，那么 ISP P1 可以聚合该地址，而 P2 不能。本质上 P1 和 P2 都可以到达 12.46.129.1，但从互联网其他部分过来的流量偏向于经过 P2，因为 P2 的路由路径更长，路由器采用<em>最长匹配前缀</em>来计算路由。</p><p>如果站点采用 PI 地址空间，则相对公平，因为 P1 和 P2 都无法聚合路由。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IP-地址结构&quot;&gt;&lt;a href=&quot;#IP-地址结构&quot; class=&quot;headerlink&quot; title=&quot;IP 地址结构&quot;&gt;&lt;/a&gt;IP 地址结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Internet 中使用的网络层地址，又叫 IP 地址。每一个连接到 In
      
    
    </summary>
    
      <category term="network protocol" scheme="https://littlechao.top/categories/network-protocol/"/>
    
    
      <category term="IP" scheme="https://littlechao.top/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>Go http server (III)</title>
    <link href="https://littlechao.top/uncategorized/go_http_server_3.html"/>
    <id>https://littlechao.top/uncategorized/go_http_server_3.html</id>
    <published>2018-06-01T16:00:00.000Z</published>
    <updated>2018-06-02T07:30:10.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GO-http-server-III-组建简易-HTTP-Server-框架"><a href="#GO-http-server-III-组建简易-HTTP-Server-框架" class="headerlink" title="GO http server (III) 组建简易 HTTP Server 框架"></a>GO http server (III) 组建简易 HTTP Server 框架</h2><blockquote><p>上篇提到 DefaultServerMux 作为默认的 HTTP Server 框架太过简单，缺少很多功能。这篇我们利用官方库和一些三方库来定制一个简易合用的 HTTP Server 框架。完整代码见<a href="https://github.com/TechcatsLab/apix" target="_blank" rel="noopener">这里</a></p></blockquote><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>首先要有 router 模块，这里我使用第三方 gorilla 框架的最小化路由模块 mux，它的作用和 DefaultServerMux 差不多，只不过支持了 RESTful API。</p><p>在添加路由和对应 handler 时，很可能我们写的处理函数有 bug，导致没有往 response 里写入内容就返回，这会造成客户端阻塞等待，所以当出现错误提前返回时，需要一个默认的错误处理函数，给客户端返回默认错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">struct</span> &#123;</span><br><span class="line">   router     *mux.Router</span><br><span class="line">   ctxPool    sync.Pool</span><br><span class="line">   errHandler <span class="function"><span class="keyword">func</span><span class="params">(w http.responseWriter, r *http.request)</span> </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>很多时候，执行路由对应 handler 时我们并不想直接操作 http.responseWriter 和 *http.request，并且希望有一些简单的封装，提供更多的功能。再者，这两个对象并不能很好的携带中间件处理过程中产生的一些参数。所以我们会定义一个 Context （下一节）来封装它们。每一个请求都应该有一个 Context，为了方便的管理，使用 sync.Pool 做一个 context 池。</p><p>创建新的 Router：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewRouter returns a router.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">   r := &amp;Router&#123;</span><br><span class="line">      router:     mux.NewRouter(),</span><br><span class="line">      errHandler: <span class="function"><span class="keyword">func</span><span class="params">(_ *Context)</span></span> &#123;&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   r.ctxPool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">      <span class="keyword">return</span> NewContext(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   r.router.NotFoundHandler = http.NotFoundHandler()</span><br><span class="line">   r.router.MethodNotAllowedHandler = MethodNotAllowedHandler()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>router 注册路由，由于使用 gorilla.mux，调用其 HandleFunc ，返回 router 本身，在调用 Method 即可指定请求方法。不过我们还可以在自己的 handler 执行之前，提供一些钩子，这里我们可以添加一些 filter 函数，以便功能扩展。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(rt *Router)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc, filters ...FilterFunc)</span></span> &#123;</span><br><span class="line">   rt.router.HandleFunc(pattern, rt.wrapHandlerFunc(handler, filters...)).Methods(<span class="string">"GET"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post adds a route path access via POST method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *Router)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc, filters ...FilterFunc)</span></span> &#123;</span><br><span class="line">   rt.router.HandleFunc(pattern, rt.wrapHandlerFunc(handler, filters...)).Methods(<span class="string">"POST"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wraps a HandlerFunc to a http.HandlerFunc.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *Router)</span> <span class="title">wrapHandlerFunc</span><span class="params">(f HandlerFunc, filters ...FilterFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">      c := rt.ctxPool.Get().(*Context)</span><br><span class="line">      <span class="keyword">defer</span> rt.ctxPool.Put(c)</span><br><span class="line">      c.Reset(w, r)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(filters) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> _, filter := <span class="keyword">range</span> filters &#123;</span><br><span class="line">            <span class="keyword">if</span> passed := filter(c); !passed &#123;</span><br><span class="line">               c.LastError = errFilterNotPassed</span><br><span class="line">               <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err := f(c); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         c.LastError = err</span><br><span class="line">         rt.errHandler(c)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>前面提到可以用一个 Context 包装 http.responseWriter 和 *http.request，并且提供一些额外的功能。额外的功能如 validator，用来对请求做参数验证。这个 validator 我们可以直接用一个第三方库，也可以做成 Interface 以便升级。</p><p>另外我们可能需要 Context 能够携带额外的信息，所以可以加一个 map 用来存储。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">   responseWriter http.ResponseWriter</span><br><span class="line">   request        *http.Request</span><br><span class="line">   Validator      *validator.Validate</span><br><span class="line">   store          <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要忘了在 Router 里面我们是用一个线程安全的池来管理 context ，也就是每次用完 context 需要还回去来避免临时分配带来的开销。所以别忘了还回去之前需要把 context 重置成原来的样子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Reset</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   c.responseWriter = w</span><br><span class="line">   c.request = r</span><br><span class="line">   c.store = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>有了 router 和 context，我们还需要封装一个 server。首先定义一个 EntryPoiont 结构体，当然名字随意。非常确认的是我们需要用到 http 包的 Server，还可以加上可能用到的 net.Listener。另外，我们需要方便的添加一些即插即用的工具，所以需要中间件，这里我使用第三方库 negroni 。然后我们可能需要一个通知关闭所有连接的机制，用一个 channel 可以做到。所以 EntryPoint 大致如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entrypoint <span class="keyword">struct</span> &#123;</span><br><span class="line">   server        *http.Server</span><br><span class="line">   listener      net.Listener</span><br><span class="line">   middlewares   []negroni.Handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="negroni"><a href="#negroni" class="headerlink" title="negroni"></a>negroni</h4><p>其实 negroni 的核心代码也很简单，就只是把多个 middleware 串起来使其能够串行调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Negroni <span class="keyword">struct</span> &#123;</span><br><span class="line">   middleware middleware</span><br><span class="line">   handlers   []Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> middleware <span class="keyword">struct</span> &#123;</span><br><span class="line">handler Handler</span><br><span class="line">next    *middleware</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键就是 Handler 接口，所有第三方实现的中间件要和 negroni 一起用的话，都要实现它，并且每个中间件执行完自己的功能后，要去调用 next 触发下一个中间件的执行。</p><p>添加中间件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Negroni)</span> <span class="title">Use</span><span class="params">(handler Handler)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"handler cannot be nil"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   n.handlers = <span class="built_in">append</span>(n.handlers, handler)</span><br><span class="line">   n.middleware = build(n.handlers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(handlers []Handler)</span> <span class="title">middleware</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> next middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(handlers) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> voidMiddleware()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(handlers) &gt; <span class="number">1</span> &#123;</span><br><span class="line">next = build(handlers[<span class="number">1</span>:])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next = voidMiddleware()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> middleware&#123;handlers[<span class="number">0</span>], &amp;next&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加中间件的时候，递归地调用 build ，把所有 middlewares 串起来。必然的，negroni 实现了 http.Handler 接口，这使得 Negroni 可以当做 http.Handler 传给 Server.Serve()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Negroni)</span> <span class="title">ServeHTTP</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   n.middleware.ServeHTTP(NewResponseWriter(rw), r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m middleware)</span> <span class="title">ServeHTTP</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">m.handler.ServeHTTP(rw, r, m.next.ServeHTTP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整合-router"><a href="#整合-router" class="headerlink" title="整合 router"></a>整合 router</h4><p>当所有中间件执行完了以后，应该把 context 传给 router 去执行对应的路由，所以把 router 作为最后一个中间件传到 negroni 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ep *Entrypoint)</span> <span class="title">buildRouter</span><span class="params">(router http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">n := negroni.New()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, mw := <span class="keyword">range</span> ep.middlewares &#123;</span><br><span class="line">n.Use(mw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n.Use(negroni.Wrap(http.HandlerFunc(router.ServeHTTP)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然在启动 Server.Serve() 之前，还要把 ep.buildRouter 返回的对象赋给 ep.Server.Handler，使这个对象代替 DefaultServerMux。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ep *Entrypoint)</span> <span class="title">prepare</span><span class="params">(router http.Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      err       error</span><br><span class="line">      listener  net.Listener</span><br><span class="line">   ）</span><br><span class="line"></span><br><span class="line">   listener, err = net.Listen(<span class="string">"tcp"</span>, ep.configuration.Address)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ep.listener = listener</span><br><span class="line">   ep.server = &amp;http.Server&#123;</span><br><span class="line">      Addr:      ep.configuration.Address,</span><br><span class="line">      Handler:   ep.buildRouter(router),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以调用 start 跑起服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ep *Entrypoint)</span> <span class="title">Start</span><span class="params">(router http.Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> router == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errNoRouter</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := ep.prepare(router); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> ep.startServer()</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"Serving on:"</span>, ep.configuration.Address)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中间件封装"><a href="#中间件封装" class="headerlink" title="中间件封装"></a>中间件封装</h3><p>有的时候有一些现成的中间件，但是不能直接放到 negroni 里面用，就需要我们给它加一层封装。</p><p>例如，我们要做 jwt 验证，使用第三方的 <em>jwtmiddleware.JWTMiddleware，但是有的路径我们不需要 token，需要跳过 jwt 中间件。不方便改别人的代码，可以这样封装来代替原来的 </em>jwtmiddleware.JWTMiddleware：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Skipper <span class="function"><span class="keyword">func</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">JWTMiddleware</span> <span class="title">is</span> <span class="title">a</span> <span class="title">wrapper</span> <span class="title">of</span> <span class="title">go</span>-<span class="title">jwt</span>-<span class="title">middleware</span>, <span class="title">but</span> <span class="title">added</span> <span class="title">a</span> <span class="title">skipper</span> <span class="title">func</span> <span class="title">on</span> <span class="title">it</span>.</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">JWTMiddleware</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">   *jwtmiddleware.JWTMiddleware</span><br><span class="line">   skipper Skipper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <em>jwtmiddleware.JWTMiddleware 作为一个匿名变量，这样可以在自定义的 JWTMiddleware 上直接调用 </em>jwtmiddleware.JWTMiddleware 的函数。然后用 handler 函数覆盖原有的 HandlerWithNext 函数，这样就能通过调用时传入的 skipper 函数判断是否需要跳过 jwt：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *JWTMiddleware)</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request, next http.HandlerFunc)</span></span> &#123;</span><br><span class="line">   path := r.URL.Path</span><br><span class="line">   <span class="keyword">if</span> skip := jm.skipper(path); skip &#123;</span><br><span class="line">      next(w, r)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   jm.HandlerWithNext(w, r, next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后用 negroni 包装一下，使它能够直接被 negroni 使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NegroniJwtHandler</span><span class="params">(key <span class="keyword">string</span>, skipper Skipper, signMethod *jwt.SigningMethodHMAC, errHandler <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request, err <span class="keyword">string</span>)</span>) <span class="title">negroni</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> signMethod == <span class="literal">nil</span> &#123;</span><br><span class="line">      signMethod = jwt.SigningMethodHS256</span><br><span class="line">   &#125;</span><br><span class="line">   jm := jwtmiddleware.New(jwtmiddleware.Options&#123;</span><br><span class="line">      ValidationKeyGetter: <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">         <span class="keyword">return</span> []<span class="keyword">byte</span>(key), <span class="literal">nil</span></span><br><span class="line">      &#125;,</span><br><span class="line">      SigningMethod: signMethod,</span><br><span class="line">      ErrorHandler:  errHandler,</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> skipper == <span class="literal">nil</span> &#123;</span><br><span class="line">      skipper = defaulSkiper</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   JM := JWTMiddleware&#123;</span><br><span class="line">      jm,</span><br><span class="line">      skipper,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> negroni.HandlerFunc(JM.handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前为止我们实现了一个简易通用的 HTTP server 框架，虽然功能还不是很完善，不过好在可扩展性比较高，我们可以在此基础上任意扩展，可以添加上缓存、数据库、监控等等模块。</p><p>如果有兴趣的话，可以去看看 echo 的实现，其实也是大同小异。</p><p>最后，再放一遍项目<a href="https://github.com/TechCatsLab/apix" target="_blank" rel="noopener">地址</a>，还有一些别的库，欢迎 star 和 pr 啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GO-http-server-III-组建简易-HTTP-Server-框架&quot;&gt;&lt;a href=&quot;#GO-http-server-III-组建简易-HTTP-Server-框架&quot; class=&quot;headerlink&quot; title=&quot;GO http server (
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go http server (II)</title>
    <link href="https://littlechao.top/uncategorized/go_http_server_2.html"/>
    <id>https://littlechao.top/uncategorized/go_http_server_2.html</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2018-06-02T07:30:40.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GO-http-server-II-Server-Handler"><a href="#GO-http-server-II-Server-Handler" class="headerlink" title="GO http server (II) Server.Handler"></a>GO http server (II) Server.Handler</h2><blockquote><p> 上一篇里讨论了 go 官方库里提供的 http 服务框架，使用者需要关心的是 Server 的 handler 域。当 Server 调用 Serve 函数时 Server.Handler 为 nil，则默认使用 http.DefaultServeMux 作为 handler。</p></blockquote><h3 id="DefaultServeMux"><a href="#DefaultServeMux" class="headerlink" title="DefaultServeMux"></a>DefaultServeMux</h3><p>来看一下它的定义和描述：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeMux is an HTTP request multiplexer.</span></span><br><span class="line"><span class="comment">// It matches the URL of each incoming request against a list of registered</span></span><br><span class="line"><span class="comment">// patterns and calls the handler for the pattern that</span></span><br><span class="line"><span class="comment">// most closely matches the URL.</span></span><br></pre></td></tr></table></figure><p>简单的说，它就是一个路由分发器。</p><h5 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">mu    sync.RWMutex</span><br><span class="line">m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">  <span class="comment">//路由规则，一个string对应一个mux实例对象，map的key就是注册的路由表达式(string类型的)</span></span><br><span class="line">hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123; <span class="comment">// 代表着一个 路由-处理函数 组合</span></span><br><span class="line">explicit <span class="keyword">bool</span> <span class="comment">//表示 patern 是否已经被明确注册过了</span></span><br><span class="line">h        Handler</span><br><span class="line">pattern  <span class="keyword">string</span> <span class="comment">//路由表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前提到过，Server.Handler 需要有路由功能，并且可以执行路由对应的处理函数。当注册路由时，调用<code>mux.Handle</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">mux.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: invalid pattern "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mux.m[pattern].explicit &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">&#125;</span><br><span class="line">mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">mux.hosts = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下是很有用的功能:当pattern == “/tree/”时,</span></span><br><span class="line">  <span class="comment">// 会插入一条永久的重定向到“/tree”,注意最后的斜杠。</span></span><br><span class="line">  <span class="comment">// 当然前提是在这之前没有“/tree”这条路由</span></span><br><span class="line">n := <span class="built_in">len</span>(pattern)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; pattern[n<span class="number">-1</span>] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]].explicit &#123;</span><br><span class="line"><span class="comment">//如果包含host，</span></span><br><span class="line">path := pattern</span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line"><span class="comment">// In pattern, at least the last character is a '/', so</span></span><br><span class="line"><span class="comment">// strings.Index can't be -1.</span></span><br><span class="line">path = pattern[strings.Index(pattern, <span class="string">"/"</span>):]</span><br><span class="line">&#125;</span><br><span class="line">url := &amp;url.URL&#123;Path: path&#125;</span><br><span class="line">mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码挺多，其实主要就做了一件事，向<code>DefaultServeMux</code>的<code>map[string]muxEntry</code>中增加对应的路由规则和<code>handler</code>。注意这里每条路由并没有包含我们常说的 GET、POST 等等区别，主要有两个原因：一是为了简洁，很多开发者偏好不同的处理方法，官方库只提供最基本的功能；二是不直接和请求方法绑定起来便于写 RESTful API。</p><p>但是这里还要注意路径结尾的<code>/</code>,这时候该路径为一个子树，如果能完全匹配到其子路由，那么也能匹配到这个子树，不过路由越长，优先级越大；如果不能完全匹配到其子路由，会匹配到这个子树的路由。比如有一个根路由<code>/</code>、<code>/example/</code>和 <code>/example/1</code>，那么访问<code>/example/2</code>时，会匹配到<code>/example/</code>，访问<code>/nothing</code>会匹配到<code>/</code>。</p><h5 id="处理路由请求"><a href="#处理路由请求" class="headerlink" title="处理路由请求"></a>处理路由请求</h5><p>注册好路由，并且没有使用别的 handler 时，DefaultServerMux 的 ServeHTTP 就会在接收到 request 时被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">   handler := sh.srv.Handler</span><br><span class="line">   <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">      handler = DefaultServeMux </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">      handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServeHTTP 主要从之前注册好的路由表中获取对应的 handler：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   h, _ := mux.Handler(r) <span class="comment">// 匹配和 request 最接近的路由，拿到对应的 handler</span></span><br><span class="line">   h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   host := stripHostPort(r.Host)</span><br><span class="line">   path := cleanPath(r.URL.Path)</span><br><span class="line">   <span class="keyword">if</span> path != r.URL.Path &#123;</span><br><span class="line">      _, pattern = mux.handler(host, path)</span><br><span class="line">      url := *r.URL</span><br><span class="line">      url.Path = path</span><br><span class="line">      <span class="keyword">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">      <span class="comment">//注意这里的重定向 handler</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">mux.mu.RLock()</span><br><span class="line"><span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line"><span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">h, pattern = mux.match(host + path)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">h, pattern = mux.match(path) <span class="comment">// match 做的是字符串匹配的工作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">h, pattern = NotFoundHandler(), <span class="string">""</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有找到匹配的路由时，返回 NotFoundHandler， 默认只是写入 404 not found，但通常我们会自定义它，然后返回一个专门的好看的 404 页面。</p><p>如果需要重定向，则会通过返回的 redirectHandler 调用 Redirect：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Redirect</span><span class="params">(w ResponseWriter, r *Request, url <span class="keyword">string</span>, code <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> u, err := parseURL(url); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// If url was relative, make absolute by</span></span><br><span class="line">      <span class="comment">// combining with request path.</span></span><br><span class="line">      <span class="comment">// The browser would probably do this for us,</span></span><br><span class="line">      <span class="comment">// but doing it ourselves is more reliable.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// NOTE(rsc): RFC 2616 says that the Location</span></span><br><span class="line">      <span class="comment">// line must be an absolute URI, like</span></span><br><span class="line">      <span class="comment">// "http://www.google.com/redirect/",</span></span><br><span class="line">      <span class="comment">// not a path like "/redirect/".</span></span><br><span class="line">      <span class="comment">// Unfortunately, we don't know what to</span></span><br><span class="line">      <span class="comment">// put in the host name section to get the</span></span><br><span class="line">      <span class="comment">// client to connect to us again, so we can't</span></span><br><span class="line">      <span class="comment">// know the right absolute URI to send back.</span></span><br><span class="line">      <span class="comment">// Because of this problem, no one pays attention</span></span><br><span class="line">      <span class="comment">// to the RFC; they all send back just a new path.</span></span><br><span class="line">      <span class="comment">// So do we.</span></span><br><span class="line">      <span class="keyword">if</span> u.Scheme == <span class="string">""</span> &amp;&amp; u.Host == <span class="string">""</span> &#123;</span><br><span class="line">         oldpath := r.URL.Path</span><br><span class="line">         <span class="keyword">if</span> oldpath == <span class="string">""</span> &#123; <span class="comment">// should not happen, but avoid a crash if it does</span></span><br><span class="line">            oldpath = <span class="string">"/"</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// no leading http://server</span></span><br><span class="line">         <span class="keyword">if</span> url == <span class="string">""</span> || url[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">            <span class="comment">// make relative path absolute</span></span><br><span class="line">            olddir, _ := path.Split(oldpath)</span><br><span class="line">            url = olddir + url</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> query <span class="keyword">string</span></span><br><span class="line">         <span class="keyword">if</span> i := strings.Index(url, <span class="string">"?"</span>); i != <span class="number">-1</span> &#123;</span><br><span class="line">            url, query = url[:i], url[i:]</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// clean up but preserve trailing slash</span></span><br><span class="line">         trailing := strings.HasSuffix(url, <span class="string">"/"</span>)</span><br><span class="line">         url = path.Clean(url)</span><br><span class="line">         <span class="keyword">if</span> trailing &amp;&amp; !strings.HasSuffix(url, <span class="string">"/"</span>) &#123;</span><br><span class="line">            url += <span class="string">"/"</span></span><br><span class="line">         &#125;</span><br><span class="line">         url += query</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   w.Header().Set(<span class="string">"Location"</span>, hexEscapeNonASCII(url))</span><br><span class="line">   w.WriteHeader(code)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// RFC 2616 recommends that a short note "SHOULD" be included in the</span></span><br><span class="line">   <span class="comment">// response because older user agents may not understand 301/307.</span></span><br><span class="line">   <span class="comment">// Shouldn't send the response for POST or HEAD; that leaves GET.</span></span><br><span class="line">   <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">      note := <span class="string">"&lt;a href=\""</span> + htmlEscape(url) + <span class="string">"\"&gt;"</span> + statusText[code] + <span class="string">"&lt;/a&gt;.\n"</span></span><br><span class="line">      fmt.Fprintln(w, note)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，DefaultServerMux 只有一个最基本的路由功能，是一个最简单的 HTTP 服务框架。可是这通常不能满足我们的需求，于是我们可以根据我们自己的需要自定义一个简单通用的 HTTP Server 框架。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GO-http-server-II-Server-Handler&quot;&gt;&lt;a href=&quot;#GO-http-server-II-Server-Handler&quot; class=&quot;headerlink&quot; title=&quot;GO http server (II) Server.H
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go http server (I)</title>
    <link href="https://littlechao.top/uncategorized/go_http_server_1.html"/>
    <id>https://littlechao.top/uncategorized/go_http_server_1.html</id>
    <published>2018-05-28T16:00:00.000Z</published>
    <updated>2018-06-02T07:30:40.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-http-server-I-源码阅读"><a href="#Go-http-server-I-源码阅读" class="headerlink" title="Go http server (I) 源码阅读"></a>Go http server (I) 源码阅读</h2><blockquote><p>这个系列会写三到四篇文章，第一篇是 go sdk 里 net/http/server.go 的阅读笔记，之后会写一下如何利用 server.go 的接口自定义一个简易通用的 HTTP server 框架。</p></blockquote><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>先从一个简单的例子开始吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启web服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">// 注意这里第二个参数为 nil</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"ListenAndServer:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Hello Guest!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，此时浏览器访问<code>localhost:9090</code>就会看到输出 “Hello Guest!”，其实访问<code>localhost:9090/</code>+任意字符串，都能得到结果。这段代码先用<code>http.HandleFunc</code>注册了一个处理函数，然后调用<code>http.ListenAndServe</code>监听端口，当有请求到来时，会根据访问路径找到并执行对应的处理函数。</p><p>我们通常还能看到另一种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启web服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.Handle(<span class="string">"/"</span>, &amp;handler&#123;&#125;)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"ListenAndServer:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">sayHello(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码效果一样。区别就是<code>http.HandleFunc</code>和<code>http.Handle</code>需要的第二个参数，前者要一个<code>func (w http.ResponseWriter, r *http.Request)</code>函数，后者要一个实现了该函数的结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123; DefaultServeMux.Handle(pattern, handler) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，两个函数都会调用<code>mux.handle</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span></span><br></pre></td></tr></table></figure><p>第二个参数是Handler，是一个接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回到上面的<code>HandleFunc</code>,注意这个：<code>HandlerFunc(handler)</code>,这里很容易让人误以为HandlerFunc是一个函数并且包装了传入的handler，再返回一个<code>Handler</code>类型。而实际上这里是<strong>类型转换</strong>，来看HandlerFunc的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ServeHTTP</span> <span class="title">calls</span> <span class="title">f</span><span class="params">(w, r)</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>HandlerFunc</code>的类型是一个函数，但它是一种类型，因为是以<code>type</code>来定义而不是<code>func</code>，并且实现了<code>ServeHTTP(w ResponseWriter, r *Request)</code>，在这个函数里，它又调用了自身。这个细节是十分重要的，因为这一步关乎到当路由规则匹配时，相应的响应方法是否会被调用的问题！这里的类型转换用法使一个函数自身实现了一个接口，就不用每次都要先写一个本身无用结构体，再用结构体实现接口。请仔细体会这种技巧！</p><p>。。。有点扯偏了，这里记住 Handler 这个接口是 go 语言 HTTP 服务最最最重要的接口，官方库和第三方库都按照这个接口来扩展。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>来看一下 Server 这个结构体吧, 这里我只列出了几个核心的域：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr      <span class="keyword">string</span>      <span class="comment">// TCP address to listen on, ":http" if empty</span></span><br><span class="line">Handler   Handler     <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">TLSConfig *tls.Config <span class="comment">// optional TLS config, used by ServeTLS and ListenAndServeTLS</span></span><br><span class="line"></span><br><span class="line">listeners  <span class="keyword">map</span>[net.Listener]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">onShutdown []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4><p>这里主要关注 Handler，这个 Handler 就是刚刚的那个接口，可以在创建 Server 时传入，也可以在调用 Server.ListenAndServe 时传入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line"><span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个 handler 是在建立连接后收到客户端请求时用到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123; <span class="comment">// conn 指当前连接</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">w, err := c.readRequest(ctx)</span><br><span class="line">...</span><br><span class="line">serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serverHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">srv *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">handler := sh.srv.Handler</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">handler = DefaultServeMux</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 serverHandler 的 ServeHTTP 函数可以看到，当 server.handler==nil 时，使用内部全局变量，也就是前面提到过的 DefaultServeMux。也就是说，我们在收到请求时通过这个 handler 来执行自己的逻辑代码，所以这个 handler 必须包含路由功能，并且能够执行路由对应的处理函数。同时我们用的第三方 HTTP server 框架(echo、beego…)也是通过自定义 handler 来实现功能扩展。这也是 Handler 这个接口是最最重要的接口的原因。</p><p>关于 DefaultServeMux 和 自定义的 handler，会在之后详细讨论。接下来回到 Server 本身。</p><h4 id="Server-Serve"><a href="#Server-Serve" class="headerlink" title="Server.Serve"></a>Server.Serve</h4><p>在主函数中可以调用 http.ListenAndServe 或者 http.Serve 来开始 HTTP 服务， 原理都一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">addr := srv.Addr</span><br><span class="line"><span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">addr = <span class="string">":http"</span></span><br><span class="line">&#125;</span><br><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看下 srv.Serve 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> l.Close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;<span class="comment">// 如果设置了 http2，就使用 http2 服务，</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">rw, e := l.Accept() <span class="comment">// 这里会等待新的连接的建立，会阻塞在这里。</span></span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line"><span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tempDelay *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">tempDelay = max</span><br><span class="line">&#125;</span><br><span class="line">srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">time.Sleep(tempDelay)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">tempDelay = <span class="number">0</span></span><br><span class="line">c := srv.newConn(rw)</span><br><span class="line">c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line"><span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要详细解释一下的就是 Accept 返回的 error 了。有以下几种可能：</p><ul><li>Accept 的时候 Server 由于某种原因停止了</li><li>收到系统信号产生中断，当然如果 返回的是 EINTR 表示可以重新调用</li><li>之前断掉的连接在短时间被重用了，此时该连接处于 <strong>TIME_WAIT</strong> 状态，新连接暂时不可用。可参考<a href="https://blog.littlechao.top/2018/04/05/tcp_faq/" target="_blank" rel="noopener">这里</a></li></ul><p>对于暂时性的错误，可以稍等一会儿，所以会出现 sleep。如果成功拿到 conn，先标记连接状态，然后创建新 goroutine 开始对连接服务。</p><h4 id="conn-serve"><a href="#conn-serve" class="headerlink" title="conn.serve"></a>conn.serve</h4><blockquote><p>这里由于 HTTPS 和 HTTP2 本身比较复杂，主要讨论 HTTP1.1 的实现。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;</span><br><span class="line"><span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">c.server.logf(<span class="string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !c.hijacked() &#123;</span><br><span class="line">c.<span class="built_in">close</span>()</span><br><span class="line">c.setState(c.rwc, StateClosed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok &#123;</span><br><span class="line"><span class="comment">// 处理 https</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP/1.x from here on.</span></span><br><span class="line"></span><br><span class="line">ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">c.cancelCtx = cancelCtx</span><br><span class="line"><span class="keyword">defer</span> cancelCtx()</span><br><span class="line"></span><br><span class="line">c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">c.bufr = newBufioReader(c.r)</span><br><span class="line">c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// 同一个连接有多个请求，循环处理</span></span><br><span class="line">w, err := c.readRequest(ctx) <span class="comment">// 读取请求，会阻塞</span></span><br><span class="line"><span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class="line"><span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line">c.setState(c.rwc, StateActive)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expect 100 Continue support</span></span><br><span class="line">req := w.req</span><br><span class="line"><span class="keyword">if</span> req.expectsContinue() &#123;</span><br><span class="line"><span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.ContentLength != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Wrap the Body reader with one that replies on the connection</span></span><br><span class="line">req.Body = &amp;expectContinueReader&#123;readCloser: req.Body, resp: w&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Header.get(<span class="string">"Expect"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">w.sendExpectationFailed()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.curReq.Store(w)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> requestBodyRemains(req.Body) &#123; <span class="comment">// 支持管线化，处理当前请求时可能还在接收请求</span></span><br><span class="line">registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> w.conn.bufr.Buffered() &gt; <span class="number">0</span> &#123;</span><br><span class="line">w.conn.r.closeNotifyFromPipelinedRequest()</span><br><span class="line">&#125;</span><br><span class="line">w.conn.r.startBackgroundRead()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req) <span class="comment">// 这里就是之前提到的，自定义处理的入口</span></span><br><span class="line">w.cancelCtx()</span><br><span class="line"><span class="keyword">if</span> c.hijacked() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.finishRequest() <span class="comment">// 把数据 flush 到网络层，此次请求在应用层结束</span></span><br><span class="line"><span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line"><span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">c.closeWriteAndWait() <span class="comment">// 发送 TCP FIN ，关闭连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> d := c.server.idleTimeout(); d != <span class="number">0</span> &#123; <span class="comment">// 设置空闲超时，超时后关闭连接</span></span><br><span class="line">c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line"><span class="keyword">if</span> _, err := c.bufr.Peek(<span class="number">4</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.rwc.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码比较复杂，包含了比较完整的 HTTP、HTTPs、HTTP2 协议的实现，建议了解了协议的内容再来看具体实现。代码协议的细节部分代码就不详细谈了，我们需要理解的是 创建 listener，从 Accept 拿到连接，等待并读取到 request，用 handler 处理 request 并把结果或错误信息写到 response 的过程。</p><p>需要注意的是，我们所讨论的是 go 语言官方库的 HTTP 的实现，这里的发送和接收数据都是指的发给下层传输层和从传输层接收，也就是调用 socket 接口，一定要分清楚各个层次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go-http-server-I-源码阅读&quot;&gt;&lt;a href=&quot;#Go-http-server-I-源码阅读&quot; class=&quot;headerlink&quot; title=&quot;Go http server (I) 源码阅读&quot;&gt;&lt;/a&gt;Go http server (I) 源码
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netstack TCP(IV) 收发数据(下)</title>
    <link href="https://littlechao.top/netstack-tcp/netstack_tcp_receive.html"/>
    <id>https://littlechao.top/netstack-tcp/netstack_tcp_receive.html</id>
    <published>2018-05-16T16:00:00.000Z</published>
    <updated>2018-05-17T12:49:44.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netstack-TCP-IV-收发数据-下"><a href="#Netstack-TCP-IV-收发数据-下" class="headerlink" title="Netstack TCP(IV) 收发数据(下)"></a>Netstack TCP(IV) 收发数据(下)</h2><blockquote><p>接上文，现在看一下 receiver 是如何接收数据的。</p></blockquote><p>endpoint 上关于接收数据的字段如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rcvListMu  sync.Mutex</span><br><span class="line">rcvList    segmentList</span><br><span class="line">rcvClosed  <span class="keyword">bool</span></span><br><span class="line">rcvBufSize <span class="keyword">int</span></span><br><span class="line">rcvBufUsed <span class="keyword">int</span></span><br><span class="line">segmentQueue segmentQueue</span><br></pre></td></tr></table></figure><p>存储结构有 segmentList 和 segmentQueue 。而在 receiver 上主要是 <code>pendingRcvdSegments segmentHeap</code>，一个堆。记住这三个结构，接下来围绕它们展开。这三个结构之间的关系最后总结。</p><p>前面讨论发送数据时是从应用层和传输层之间接口 Write 开始的，而接收数据我们从网络层到传输层的接口 HandlePacket 开始讨论，这样符合数据流方向。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">HandlePacket</span><span class="params">(r *stack.Route, id stack.TransportEndpointID, vv *buffer.VectorisedView)</span></span> &#123;</span><br><span class="line">s := newSegment(r, id, vv)</span><br><span class="line"><span class="keyword">if</span> !s.parse() &#123;</span><br><span class="line">atomic.AddUint64(&amp;e.stack.MutableStats().MalformedRcvdPackets, <span class="number">1</span>)</span><br><span class="line">s.decRef()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把收到的包直接放到 endpoint 的 segmentQueue 里面，但是顺序是没有保障的。</span></span><br><span class="line"><span class="keyword">if</span> e.segmentQueue.enqueue(s) &#123;</span><br><span class="line">e.newSegmentWaker.Assert() </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// The queue is full, so we drop the segment.</span></span><br><span class="line">atomic.AddUint64(&amp;e.stack.MutableStats().DroppedPackets, <span class="number">1</span>)</span><br><span class="line">s.decRef()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上一篇的 mainLoop 函数里，已经注册过 newSegmentWaker 和它的回调 handleSegments 函数，然后在循环中等待 waker。这里收到包，添加到队列里，然后通知 mainLoop 有新的包到来，触发 handleSegments ，先来看下大概执行过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">handleSegments</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">checkRequeue := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxSegmentsPerWake; i++ &#123;</span><br><span class="line">        <span class="comment">// maxSegmentsPerWake 是一个常量，值为 100，其实是随意设置的一个值，因为每次 newSegmentWaker 被触发时可能有很多包要被处理</span></span><br><span class="line">s := e.segmentQueue.dequeue() <span class="comment">// 从队列拿到无序的数据包</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">checkRequeue = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagRst) &#123;</span><br><span class="line"><span class="keyword">if</span> e.rcv.acceptable(s.sequenceNumber, <span class="number">0</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s.flagIsSet(flagAck) &#123;</span><br><span class="line">...</span><br><span class="line">e.rcv.handleRcvdSegment(s) <span class="comment">// </span></span><br><span class="line">e.snd.handleRcvdSegment(s) <span class="comment">// 分别调用 sender 和 receiver 处理同样的包</span></span><br><span class="line">&#125;</span><br><span class="line">s.decRef()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> checkRequeue &amp;&amp; !e.segmentQueue.empty() &#123;</span><br><span class="line">e.newSegmentWaker.Assert() <span class="comment">// 当 100 次过后还有未处理的包，再次触发 newSegmentWaker</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send an ACK for all processed packets if needed.</span></span><br><span class="line"><span class="keyword">if</span> e.rcv.rcvNxt != e.snd.maxSentAck &#123;</span><br><span class="line">e.snd.sendAck()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要分为两个分支，分别交给 endpoint 的 receiver 和 sender 来处理。这里需要注意，每个 endpoint 只有一个 sender 和 一个 receiver，所以 sender 除了正常向外发送包，还需要在收到包时负责发送 ACK 或 SACK 。所以收到一个数据包时，receiver 和 sender 都要处理，这个过程大致如图</p><p><img src="../images/tcp_handleSegment.png" alt=""></p><p>两个主要过程如下：</p><h4 id="rcv-handleRcvdSegment"><a href="#rcv-handleRcvdSegment" class="headerlink" title="rcv.handleRcvdSegment"></a>rcv.handleRcvdSegment</h4><p>这个函数主要作用是接收乱序的包，放到 receiver 的 pendingRcvdSegments 这个最小堆里，在合适的时候把连续、完整的几个包放到 endpoint 的 rcvList，应用层读取连接的数据就是通过这个 rcvList。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *receiver)</span> <span class="title">handleRcvdSegment</span><span class="params">(s *segment)</span></span> &#123;</span><br><span class="line">   </span><br><span class="line">   segLen := seqnum.Size(s.data.Size())</span><br><span class="line">   segSeq := s.sequenceNumber</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !r.acceptable(segSeq, segLen) &#123;<span class="comment">// 判断包的合法性，是否在接收窗口范围</span></span><br><span class="line">      r.ep.snd.sendAck() <span class="comment">// 发送冗余 ACK</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !r.consumeSegment(s, segSeq, segLen) &#123;<span class="comment">// consumeSegment 判断当前收到的包是否可以造成接收窗口右移，如果是，说明 pendingRcvdSegments 这个堆里的数据包是连续的，然后把连续的包存到 endpoint 的 rcvList 队列里；如果不是，说明收到失序报文段，返回 FALSE</span></span><br><span class="line">      <span class="keyword">if</span> segLen &gt; <span class="number">0</span> || s.flagIsSet(flagFin) &#123;</span><br><span class="line">         <span class="comment">// We only store the segment if it's within our buffer</span></span><br><span class="line">         <span class="comment">// size limit.</span></span><br><span class="line">         <span class="keyword">if</span> r.pendingBufUsed &lt; r.pendingBufSize &#123;</span><br><span class="line">            r.pendingBufUsed += s.logicalLen()</span><br><span class="line">            s.incRef()</span><br><span class="line">            heap.Push(&amp;r.pendingRcvdSegments, s)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         UpdateSACKBlocks(&amp;r.ep.sack, segSeq, segSeq.Add(segLen), r.rcvNxt)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Immediately send an ack so that the peer knows it may</span></span><br><span class="line">         <span class="comment">// have to retransmit.</span></span><br><span class="line">         r.ep.snd.sendAck()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 继续检查 pendingRcvdSegments 里是否有更多连续的数据，如果有，取出来放到 rcvList 里</span></span><br><span class="line">   <span class="keyword">for</span> !r.closed &amp;&amp; r.pendingRcvdSegments.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">      s := r.pendingRcvdSegments[<span class="number">0</span>]</span><br><span class="line">      segLen := seqnum.Size(s.data.Size())</span><br><span class="line">      segSeq := s.sequenceNumber</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Skip segment altogether if it has already been acknowledged.</span></span><br><span class="line">      <span class="keyword">if</span> !segSeq.Add(segLen<span class="number">-1</span>).LessThan(r.rcvNxt) &amp;&amp;</span><br><span class="line">         !r.consumeSegment(s, segSeq, segLen) &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      heap.Pop(&amp;r.pendingRcvdSegments)</span><br><span class="line">      r.pendingBufUsed -= s.logicalLen()</span><br><span class="line">      s.decRef()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="snd-handleRcvdSegment"><a href="#snd-handleRcvdSegment" class="headerlink" title="snd.handleRcvdSegment"></a>snd.handleRcvdSegment</h4><p>这里主要是在收到新的数据包后返回 ACK 或 SACK，并且更新当前状态，比如在外数据值、接收窗口、RTT、RTO…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sender)</span> <span class="title">handleRcvdSegment</span><span class="params">(seg *segment)</span></span> &#123;</span><br><span class="line"><span class="comment">// Check if we can extract an RTT measurement from this ack.</span></span><br><span class="line"><span class="keyword">if</span> s.rttMeasureSeqNum.LessThan(seg.ackNumber) &#123;</span><br><span class="line">s.updateRTO(time.Now().Sub(s.rttMeasureTime))</span><br><span class="line">s.rttMeasureSeqNum = s.sndNxt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update Timestamp if required. See RFC7323, section-4.3.</span></span><br><span class="line">s.ep.updateRecentTimestamp(seg.parsedOptions.TSVal, s.maxSentAck, seg.sequenceNumber)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Count the duplicates and do the fast retransmit if needed.</span></span><br><span class="line">rtx := s.checkDuplicateAck(seg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stash away the current window size.</span></span><br><span class="line">s.sndWnd = seg.window</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ignore ack if it doesn't acknowledge any new data.</span></span><br><span class="line">ack := seg.ackNumber</span><br><span class="line"><span class="keyword">if</span> (ack - <span class="number">1</span>).InRange(s.sndUna, s.sndNxt) &#123;</span><br><span class="line"><span class="comment">// When an ack is received we must reset the timer. We stop it</span></span><br><span class="line"><span class="comment">// here and it will be restarted later if needed.</span></span><br><span class="line">s.resendTimer.disable()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove all acknowledged data from the write list.</span></span><br><span class="line">acked := s.sndUna.Size(ack)</span><br><span class="line">s.sndUna = ack</span><br><span class="line"></span><br><span class="line">ackLeft := acked</span><br><span class="line">originalOutstanding := s.outstanding</span><br><span class="line"><span class="keyword">for</span> ackLeft &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// We use logicalLen here because we can have FIN</span></span><br><span class="line"><span class="comment">// segments (which are always at the end of list) that</span></span><br><span class="line"><span class="comment">// have no data, but do consume a sequence number.</span></span><br><span class="line">seg := s.writeList.Front()</span><br><span class="line">datalen := seg.logicalLen()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> datalen &gt; ackLeft &#123;</span><br><span class="line">seg.data.TrimFront(<span class="keyword">int</span>(ackLeft))</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.writeNext == seg &#123;</span><br><span class="line">s.writeNext = seg.Next()</span><br><span class="line">&#125;</span><br><span class="line">s.writeList.Remove(seg)</span><br><span class="line">s.outstanding--</span><br><span class="line">seg.decRef()</span><br><span class="line">ackLeft -= datalen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the send buffer usage and notify potential waiters.</span></span><br><span class="line">s.ep.updateSndBufferUsage(<span class="keyword">int</span>(acked))</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we are not in fast recovery then update the congestion</span></span><br><span class="line"><span class="comment">// window based on the number of acknowledged packets.</span></span><br><span class="line"><span class="keyword">if</span> !s.fr.active &#123;</span><br><span class="line">s.updateCwnd(originalOutstanding - s.outstanding)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// It is possible for s.outstanding to drop below zero if we get</span></span><br><span class="line"><span class="comment">// a retransmit timeout, reset outstanding to zero but later</span></span><br><span class="line"><span class="comment">// get an ack that cover previously sent data.</span></span><br><span class="line"><span class="keyword">if</span> s.outstanding &lt; <span class="number">0</span> &#123;</span><br><span class="line">s.outstanding = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that we've popped all acknowledged data from the retransmit</span></span><br><span class="line"><span class="comment">// queue, retransmit if needed.</span></span><br><span class="line"><span class="keyword">if</span> rtx &#123;</span><br><span class="line">s.resendSegment()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send more data now that some of the pending data has been ack'd, or</span></span><br><span class="line"><span class="comment">// that the window opened up, or the congestion window was inflated due</span></span><br><span class="line"><span class="comment">// to a duplicate ack during fast recovery. This will also re-enable</span></span><br><span class="line"><span class="comment">// the retransmit timer if needed.</span></span><br><span class="line">s.sendData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三个存储结构"><a href="#三个存储结构" class="headerlink" title="三个存储结构"></a>三个存储结构</h4><p>开始提到的三个字段，关系如下，结合图，再回过头看整个处理过程，其实很清楚了，每个结构的分工还是很明确的。</p><p><img src="../images/tcp_rcv_packets.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netstack-TCP-IV-收发数据-下&quot;&gt;&lt;a href=&quot;#Netstack-TCP-IV-收发数据-下&quot; class=&quot;headerlink&quot; title=&quot;Netstack TCP(IV) 收发数据(下)&quot;&gt;&lt;/a&gt;Netstack TCP(IV) 收
      
    
    </summary>
    
      <category term="netstack_tcp" scheme="https://littlechao.top/categories/netstack-tcp/"/>
    
    
      <category term="tcp" scheme="https://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="https://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>netstack TCP(III) 收发数据(上)</title>
    <link href="https://littlechao.top/netstack-tcp/netstack_tcp_send.html"/>
    <id>https://littlechao.top/netstack-tcp/netstack_tcp_send.html</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-05-17T12:49:44.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netstack-TCP-III-收发数据-上"><a href="#Netstack-TCP-III-收发数据-上" class="headerlink" title="Netstack TCP(III) 收发数据(上)"></a>Netstack TCP(III) 收发数据(上)</h2><blockquote><p>上一篇我们讨论了 TCP 连接建立的过程，这篇接着讨论连接建立以后的故事。</p></blockquote><p>如果是被动建立连接，这个连接会经过 deliverAccept 函数被放到 Accept 队列，然后由应用程序去调用 Accept 来获取一个连接，Go SDK 1.9.2 的 net/http/server.go 中是这样调用的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> l.Close()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">rw, e := l.Accept()</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">...</span><br><span class="line">time.Sleep(tempDelay)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">tempDelay = <span class="number">0</span></span><br><span class="line">c := srv.newConn(rw)</span><br><span class="line">c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line"><span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，循环去调用 Accept 去获取一个可读写的连接，但是可能会有一个暂时性的错误，所以让它 <code>sleep</code> 了一小会儿。当然，这里的 Accept 是对系统调用的封装， 和 netstack 的 Accept 不是同一个，但是基本原理是一样的。来看下 netstack 的 Accept：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(tcpip.Endpoint, *waiter.Queue, *tcpip.Error)</span></span> &#123;</span><br><span class="line">e.mu.RLock()</span><br><span class="line"><span class="keyword">defer</span> e.mu.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Endpoint must be in listen state before it can accept connections.</span></span><br><span class="line"><span class="keyword">if</span> e.state != stateListen &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, tcpip.ErrInvalidEndpointState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the new accepted endpoint.</span></span><br><span class="line"><span class="keyword">var</span> n *endpoint</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> n = &lt;-e.acceptedChan:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, tcpip.ErrWouldBlock <span class="comment">// 注意这里，当没有新的连接时，没有一直阻塞，而是返回一个 ‘暂时不可用’ 的错误。这也是上一段代码里 sleep 一小会儿的原因。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the protocol goroutine.</span></span><br><span class="line">wq := &amp;waiter.Queue&#123;&#125;</span><br><span class="line">n.startAcceptedLoop(wq)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n, wq, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到新的连接后进入 <code>startAcceptedLoop，</code> <code>startAcceptedLoop</code>只是对 <code>protocolMainLoop</code>的简单封装。</p><p>而如果是主动建立连接，三次握手后，直接进入 <code>protocolMainLoop</code>循环。</p><h4 id="protocolMainLoop"><a href="#protocolMainLoop" class="headerlink" title="protocolMainLoop"></a>protocolMainLoop</h4><p><img src="../images/tcp_main_loop.png" alt=""></p><p>如图，虚线框里的就是 protocolMainLoop 的主要内容。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protocolMainLoop</span><span class="params">()</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// One time set-up.</span></span><br><span class="line">    s := sleep.Sleeper&#123;&#125;</span><br><span class="line"></span><br><span class="line">    funcs := []<span class="keyword">struct</span> &#123;</span><br><span class="line">            w *sleep.Waker</span><br><span class="line">            f <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">        &#125;</span>&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.sndWaker,</span><br><span class="line">                f: e.handleWrite,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.sndCloseWaker,</span><br><span class="line">                f: e.handleClose,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.newSegmentWaker,</span><br><span class="line">                f: e.handleSegments,</span><br><span class="line">            &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        s.AddWaker(funcs[i].w, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called repeatedly.</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v, _ := s.Fetch(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> !funcs[v].f() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，主要是注册一些回调，添加到 sleeper 的 waker 里，然后进入循环，Fetch 拿到触发了的事件，然后执行这些事件对应的回调。这是大体框架，接下来详细了解一些比较重要的事件及其回调。</p><p>####sender</p><p>先来关注一个连接作为发送方需要的功能，sender 是比较复杂的，它需要关注 TCP 窗口大小、流量控制、超时重传、拥塞控制、保活探测等一系列机制，同时由于一个 endpoint 只有一个 sender 和 receiver，收到数据后返回 ACK 或者 SACK 的工作也需要 sender 来控制。</p><p>在 endpoint 上和发送有关的域有如下几个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sndBufMu      sync.Mutex</span><br><span class="line">sndBufSize    <span class="keyword">int</span></span><br><span class="line">sndBufUsed    <span class="keyword">int</span></span><br><span class="line">sndClosed     <span class="keyword">bool</span></span><br><span class="line">sndBufInQueue seqnum.Size</span><br><span class="line">sndQueue      segmentList <span class="comment">// 用来保存还未发出的数据</span></span><br><span class="line">sndWaker      sleep.Waker</span><br><span class="line">sndCloseWaker sleep.Waker</span><br></pre></td></tr></table></figure><p>在 sender 上也有一个<code>writeList   segmentList</code> 域，这里 segmentList 是一个有头有尾的链表结构。这两个 segmentList 分别有什么作用和区别呢？我们通过 Write 函数来看下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 socket 的标准接口之一，调用的时候通常放在一个循环里，确保数据被写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">Write</span><span class="params">(p tcpip.Payload, opts tcpip.WriteOptions)</span> <span class="params">(<span class="keyword">uintptr</span>, *tcpip.Error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// Check against the limit.</span></span><br><span class="line">avail := e.sndBufSize - e.sndBufUsed <span class="comment">// 检查发送窗口大小</span></span><br><span class="line"><span class="keyword">if</span> avail &lt;= <span class="number">0</span> &#123; <span class="comment">// 可用窗口 &lt;= 0,暂时不可发送，返回一个‘暂时性’的错误，表示多试几次即可</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, tcpip.ErrWouldBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v, perr := p.Get(avail)</span><br><span class="line">l := <span class="built_in">len</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err *tcpip.Error</span><br><span class="line"><span class="keyword">if</span> p.Size() &gt; avail &#123;</span><br><span class="line">err = tcpip.ErrWouldBlock</span><br><span class="line">&#125;</span><br><span class="line">l := <span class="built_in">len</span>(v)</span><br><span class="line">s := newSegmentFromView(&amp;e.route, e.id, v) <span class="comment">// 把整块的数据根据当前窗口大小切出一个包，也就是说数据在此之前是‘流式’的</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">e.sndQueue.PushBack(s) <span class="comment">// 注意这里先把数据包存在了 endpoint 的链表里。</span></span><br><span class="line">...</span><br><span class="line">e.handleWrite()</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uintptr</span>(l), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这里的 sendQueue 是可以被多个 goroutine 访问的，所以操作它要加锁（以上代码里为了简要删掉了）。在调用 e.handleWrite() 里，把 e.sendQueue 整个链表追加到了 endpoint.snd.writeList 尾部，由sender 接管，在这里由于调用 handlewrite 已经加了锁，所以 sender 的writeList 只能被一个 goroutine 操作，不需要再加锁。e.handleWrite 做了另一件事就是调用了 sendData 函数。涉及了 TCP 发送方的诸多细节和算法，如超时重传、慢启动、拥塞避免、快速恢复、Reno、newReno、窗口探测等等，读这段代码前需要对 TCP 协议有详细的了解，否则可以先跳过这段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sender)</span> <span class="title">sendData</span><span class="params">()</span></span> &#123;</span><br><span class="line">limit := s.maxPayloadSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce the congestion window to min(IW, cwnd) per RFC 5681, page 10.</span></span><br><span class="line"><span class="comment">// "A TCP SHOULD set cwnd to no more than RW before beginning</span></span><br><span class="line"><span class="comment">// transmission if the TCP has not sent data in the interval exceeding</span></span><br><span class="line"><span class="comment">// the retrasmission timeout."</span></span><br><span class="line"><span class="keyword">if</span> !s.fr.active &amp;&amp; time.Now().Sub(s.lastSendTime) &gt; s.rto &#123;</span><br><span class="line"><span class="keyword">if</span> s.sndCwnd &gt; InitialCwnd &#123;</span><br><span class="line">s.sndCwnd = InitialCwnd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> We currently don't merge multiple send buffers</span></span><br><span class="line"><span class="comment">// into one segment if they happen to fit. We should do that</span></span><br><span class="line"><span class="comment">// eventually.</span></span><br><span class="line"><span class="keyword">var</span> seg *segment</span><br><span class="line">end := s.sndUna.Add(s.sndWnd)</span><br><span class="line"><span class="keyword">for</span> seg = s.writeNext; seg != <span class="literal">nil</span> &amp;&amp; s.outstanding &lt; s.sndCwnd; seg = seg.Next() &#123;</span><br><span class="line"><span class="comment">// We abuse the flags field to determine if we have already</span></span><br><span class="line"><span class="comment">// assigned a sequence number to this segment.</span></span><br><span class="line"><span class="keyword">if</span> seg.flags == <span class="number">0</span> &#123;</span><br><span class="line">seg.sequenceNumber = s.sndNxt</span><br><span class="line">seg.flags = flagAck | flagPsh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> segEnd seqnum.Value</span><br><span class="line"><span class="keyword">if</span> seg.data.Size() == <span class="number">0</span> &#123;</span><br><span class="line">seg.flags = flagAck</span><br><span class="line"></span><br><span class="line">s.ep.rcvListMu.Lock()</span><br><span class="line">rcvBufUsed := s.ep.rcvBufUsed</span><br><span class="line">s.ep.rcvListMu.Unlock()</span><br><span class="line"></span><br><span class="line">s.ep.mu.Lock()</span><br><span class="line"><span class="comment">// We're sending a FIN by default</span></span><br><span class="line">fl := flagFin</span><br><span class="line"><span class="keyword">if</span> (s.ep.shutdownFlags&amp;tcpip.ShutdownRead) != <span class="number">0</span> &amp;&amp; rcvBufUsed &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// If there is unread data we must send a RST.</span></span><br><span class="line"><span class="comment">// For more information see RFC 2525 section 2.17.</span></span><br><span class="line">fl = flagRst</span><br><span class="line">&#125;</span><br><span class="line">s.ep.mu.Unlock()</span><br><span class="line">seg.flags |= <span class="keyword">uint8</span>(fl)</span><br><span class="line"></span><br><span class="line">segEnd = seg.sequenceNumber.Add(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We're sending a non-FIN segment.</span></span><br><span class="line"><span class="keyword">if</span> !seg.sequenceNumber.LessThan(end) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">available := <span class="keyword">int</span>(seg.sequenceNumber.Size(end))</span><br><span class="line"><span class="keyword">if</span> available &gt; limit &#123;</span><br><span class="line">available = limit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> seg.data.Size() &gt; available &#123;</span><br><span class="line"><span class="comment">// Split this segment up.</span></span><br><span class="line">nSeg := seg.clone()</span><br><span class="line">nSeg.data.TrimFront(available)</span><br><span class="line">nSeg.sequenceNumber.UpdateForward(seqnum.Size(available))</span><br><span class="line">s.writeList.InsertAfter(seg, nSeg)</span><br><span class="line">seg.data.CapLength(available)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.outstanding++</span><br><span class="line">segEnd = seg.sequenceNumber.Add(seqnum.Size(seg.data.Size()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.sendSegment(&amp;seg.data, seg.flags, seg.sequenceNumber)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update sndNxt if we actually sent new data (as opposed to</span></span><br><span class="line"><span class="comment">// retransmitting some previously sent data).</span></span><br><span class="line"><span class="keyword">if</span> s.sndNxt.LessThan(segEnd) &#123;</span><br><span class="line">s.sndNxt = segEnd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember the next segment we'll write.</span></span><br><span class="line">s.writeNext = seg</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable the timer if we have pending data and it's not enabled yet.</span></span><br><span class="line"><span class="keyword">if</span> !s.resendTimer.enabled() &amp;&amp; s.sndUna != s.sndNxt &#123;</span><br><span class="line">s.resendTimer.enable(s.rto)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后实际发送是调用 sender.sendSegment —&gt; endpoint.sendRaw —&gt; sendTCP —&gt; route.ref.ep.WritePacket，route 是这条连接对应的路由，WritePacket 把这个数据包传到对应的网络层endpoint，TCP  sender 的工作到此结束了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sender)</span> <span class="title">sendSegment</span><span class="params">(data *buffer.VectorisedView, flags <span class="keyword">byte</span>, seq seqnum.Value)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">rcvNxt, rcvWnd := s.ep.rcv.getSendParams()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> s.ep.sendRaw(data.First(), flags, seq, rcvNxt, rcvWnd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">sendRaw</span><span class="params">(data buffer.View, flags <span class="keyword">byte</span>, seq, ack seqnum.Value, rcvWnd seqnum.Size)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">err := sendTCP(&amp;e.route, e.id, data, flags, seq, ack, rcvWnd)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendTCP</span><span class="params">(r *stack.Route, id stack.TransportEndpointID, data buffer.View, flags <span class="keyword">byte</span>, seq, ack seqnum.Value, rcvWnd seqnum.Size)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="comment">// 添加 TCP 首部</span></span><br><span class="line">hdr := buffer.NewPrependable(header.TCPMinimumSize + <span class="keyword">int</span>(r.MaxHeaderLength()))</span><br><span class="line">tcp := header.TCP(hdr.Prepend(header.TCPMinimumSize))</span><br><span class="line">tcp.Encode(&amp;header.TCPFields&#123;</span><br><span class="line">SrcPort:    id.LocalPort,</span><br><span class="line">DstPort:    id.RemotePort,</span><br><span class="line">SeqNum:     <span class="keyword">uint32</span>(seq),</span><br><span class="line">AckNum:     <span class="keyword">uint32</span>(ack),</span><br><span class="line">DataOffset: header.TCPMinimumSize,</span><br><span class="line">Flags:      flags,</span><br><span class="line">WindowSize: <span class="keyword">uint16</span>(rcvWnd),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> r.WritePacket(&amp;hdr, data, ProtocolNumber)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">WritePacket</span><span class="params">(hdr *buffer.Prependable, payload buffer.View, protocol tcpip.TransportProtocolNumber)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.ref.ep.WritePacket(r, hdr, payload, protocol)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netstack-TCP-III-收发数据-上&quot;&gt;&lt;a href=&quot;#Netstack-TCP-III-收发数据-上&quot; class=&quot;headerlink&quot; title=&quot;Netstack TCP(III) 收发数据(上)&quot;&gt;&lt;/a&gt;Netstack TCP(II
      
    
    </summary>
    
      <category term="netstack_tcp" scheme="https://littlechao.top/categories/netstack-tcp/"/>
    
    
      <category term="tcp" scheme="https://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="https://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>Netstack(II) 链路层</title>
    <link href="https://littlechao.top/uncategorized/netstack_linklayer.html"/>
    <id>https://littlechao.top/uncategorized/netstack_linklayer.html</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2018-05-07T15:39:40.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netstack-II-链路层"><a href="#Netstack-II-链路层" class="headerlink" title="Netstack(II) 链路层"></a>Netstack(II) 链路层</h2><blockquote><p>链路层没有特别指明 Protocol 的接口，不过其 endpoint 如下：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkEndpoint 被以太网、环回、raw 等链路层协议实现，网络层协议用它来往外发送数据。</span></span><br><span class="line"><span class="keyword">type</span> LinkEndpoint <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// MTU is the maximum transmission unit for this endpoint. This is</span></span><br><span class="line"><span class="comment">// usually dictated by the backing physical network; when such a</span></span><br><span class="line"><span class="comment">// physical network doesn't exist, the limit is generally 64k, which</span></span><br><span class="line"><span class="comment">// includes the maximum size of an IP packet.</span></span><br><span class="line">MTU() <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Capabilities returns the set of capabilities supported by the</span></span><br><span class="line"><span class="comment">// endpoint.</span></span><br><span class="line">Capabilities() LinkEndpointCapabilities</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxHeaderLength returns the maximum size the data link (and</span></span><br><span class="line"><span class="comment">// lower level layers combined) headers can have. Higher levels use this</span></span><br><span class="line"><span class="comment">// information to reserve space in the front of the packets they're</span></span><br><span class="line"><span class="comment">// building.</span></span><br><span class="line">MaxHeaderLength() <span class="keyword">uint16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkAddress returns the link address (typically a MAC) of the</span></span><br><span class="line"><span class="comment">// link endpoint.</span></span><br><span class="line">LinkAddress() tcpip.LinkAddress</span><br><span class="line"></span><br><span class="line"><span class="comment">// WritePacket writes a packet with the given protocol through the given</span></span><br><span class="line"><span class="comment">// route.</span></span><br><span class="line">WritePacket(r *Route, hdr *buffer.Prependable, payload buffer.View, protocol tcpip.NetworkProtocolNumber) *tcpip.Error</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach attaches the data link layer endpoint to the network-layer</span></span><br><span class="line"><span class="comment">// dispatcher of the stack.</span></span><br><span class="line">Attach(dispatcher NetworkDispatcher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常用一个 endpointID 和它联系起来:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkEndpointID <span class="keyword">uint64</span></span><br></pre></td></tr></table></figure><h3 id="fdbased-endpoint"><a href="#fdbased-endpoint" class="headerlink" title="fdbased endpoint"></a>fdbased endpoint</h3><p>LinkEndpoint 的实现有多种，这里我们主要看一下基于文件描述符的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> endpoint <span class="keyword">struct</span> &#123;</span><br><span class="line">fd <span class="keyword">int</span></span><br><span class="line">mtu <span class="keyword">uint32</span></span><br><span class="line">hdrSize <span class="keyword">int</span> </span><br><span class="line">    <span class="comment">// 指链路层首部长度，这里特别讨论一下，可能有两个值，0 或 14。14 好理解，6 字节 dst MAC 地址，6字节 src MAC 地址，2 字节类型。为什么可能是 0 呢，如果是 localhost 的数据，是不需要 dst 和 src Mac地址的。</span></span><br><span class="line">addr tcpip.LinkAddress</span><br><span class="line">caps stack.LinkEndpointCapabilities</span><br><span class="line"></span><br><span class="line"><span class="comment">// closed is a function to be called when the FD's peer (if any) closes</span></span><br><span class="line"><span class="comment">// its end of the communication pipe.</span></span><br><span class="line">closed <span class="function"><span class="keyword">func</span><span class="params">(*tcpip.Error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">vv</span>     *<span class="title">buffer</span>.<span class="title">VectorisedView</span></span></span><br><span class="line"><span class="function"><span class="title">iovecs</span> []<span class="title">syscall</span>.<span class="title">Iovec</span></span></span><br><span class="line"><span class="function"><span class="title">views</span>  []<span class="title">buffer</span>.<span class="title">View</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>这里 主要了解 View 和 VectorisedView：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> View []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VectorisedView <span class="keyword">struct</span> &#123;</span><br><span class="line">views []View</span><br><span class="line">size  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有一个 Prependable：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Prependable <span class="keyword">struct</span> &#123;</span><br><span class="line">buf View</span><br><span class="line">usedIdx <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个结构是整个系统里用的最多的底层结构，用来表示要传输的包。特别是 Prependable，它是可以扩展的，并且是在数据的开始处扩展，想想各层网络协议的首部，是在上一层数据的最前面添加这一层的首部。</p><h4 id="iovec"><a href="#iovec" class="headerlink" title="iovec"></a>iovec</h4><blockquote><p>这里重点提一下 <strong>向量IO</strong> 的概念。这是一种在单词系统调用中操作多个缓冲区的 I/O 方法，可以将单个数据流的内容写到多个缓冲区，或者把单个数据流读到多个缓冲区中。</p><ul><li>效率：单个向量I/O 操作能代替多个线性I/O 操作</li><li>性能：除了系统调用次数的降低，由于内部优化，向量I /O 比线性I/O 提供更好的性能。</li><li>原子性：不同于多个线性I/O 操作，一个进程可以执行单个向量I/O操作而且避免了与其它进程交叉操作的风险。</li></ul><p>实际上，内核里的所有I/O 都是向量I/O，read()和 write()是只有一个向量的向量I/O，且向量中只有一个段。</p></blockquote><p>代码里这个 iovecs 字段就是用于向量 IO，内存分配如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BufConfig = []<span class="keyword">int</span>&#123;<span class="number">128</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">8192</span>, <span class="number">16384</span>, <span class="number">32768</span>&#125; </span><br><span class="line"><span class="comment">// 总共接近 64KB，其实有点困惑，真的需要这么多内存吗？因为 MTU 也就 1500B</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">allocateViews</span><span class="params">(bufConfig []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> e.views &#123;</span><br><span class="line"><span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">b := buffer.NewView(bufConfig[i])</span><br><span class="line">e.views[i] = b</span><br><span class="line">e.iovecs[i] = syscall.Iovec&#123;</span><br><span class="line">Base: &amp;b[<span class="number">0</span>],</span><br><span class="line">Len:  <span class="keyword">uint64</span>(<span class="built_in">len</span>(b)),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p>先看发送，就是系统调用往对应的 fd 里写入内容，需要注意的是这是<em>非阻塞</em>写入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WritePacket writes outbound packets to the file descriptor. If it is not</span></span><br><span class="line"><span class="comment">// currently writable, the packet is dropped.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">WritePacket</span><span class="params">(r *stack.Route, hdr *buffer.Prependable, payload buffer.View, protocol tcpip.NetworkProtocolNumber)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e.hdrSize &gt; <span class="number">0</span> &#123; <span class="comment">// 不是 localhost，需要加上首部</span></span><br><span class="line">eth := header.Ethernet(hdr.Prepend(header.EthernetMinimumSize))</span><br><span class="line">eth.Encode(&amp;header.EthernetFields&#123;</span><br><span class="line">DstAddr: r.RemoteLinkAddress,</span><br><span class="line">SrcAddr: e.addr,</span><br><span class="line">Type:    protocol,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(payload) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rawfile.NonBlockingWrite(e.fd, hdr.UsedBytes())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rawfile.NonBlockingWrite2(e.fd, hdr.UsedBytes(), payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NonBlockingWrite</span><span class="params">(fd <span class="keyword">int</span>, buf []<span class="keyword">byte</span>)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ptr unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &#123;</span><br><span class="line">ptr = unsafe.Pointer(&amp;buf[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, _, e := syscall.RawSyscall(syscall.SYS_WRITE, <span class="keyword">uintptr</span>(fd), <span class="keyword">uintptr</span>(ptr), <span class="keyword">uintptr</span>(<span class="built_in">len</span>(buf)))</span><br><span class="line"><span class="keyword">if</span> e != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> TranslateErrno(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 '向量 IO' 写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NonBlockingWrite2</span><span class="params">(fd <span class="keyword">int</span>, b1, b2 []<span class="keyword">byte</span>)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">iovec := [...]syscall.Iovec&#123; <span class="comment">// </span></span><br><span class="line">&#123;</span><br><span class="line">Base: &amp;b1[<span class="number">0</span>],</span><br><span class="line">Len:  <span class="keyword">uint64</span>(<span class="built_in">len</span>(b1)),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Base: &amp;b2[<span class="number">0</span>],</span><br><span class="line">Len:  <span class="keyword">uint64</span>(<span class="built_in">len</span>(b2)),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, _, e := syscall.RawSyscall(syscall.SYS_WRITEV, <span class="keyword">uintptr</span>(fd), <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;iovec[<span class="number">0</span>])), <span class="keyword">uintptr</span>(<span class="built_in">len</span>(iovec)))</span><br><span class="line"><span class="keyword">if</span> e != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> TranslateErrno(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><p>链路层 endpoint 在运行起来后会进入一个接收循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">dispatchLoop</span><span class="params">(d stack.NetworkDispatcher)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">v := buffer.NewView(header.MaxIPPacketSize)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">cont, err := e.dispatch(d, v) <span class="comment">// note: if no data to deliver, it blocks.</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">dispatch</span><span class="params">(d stack.NetworkDispatcher, largeV buffer.View)</span> <span class="params">(<span class="keyword">bool</span>, *tcpip.Error)</span></span> &#123;</span><br><span class="line">e.allocateViews(BufConfig) <span class="comment">// 分配内存</span></span><br><span class="line"></span><br><span class="line">n, err := rawfile.BlockingReadv(e.fd, e.iovecs) <span class="comment">// 注意这里会阻塞</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">used := e.capViews(n, BufConfig)</span><br><span class="line">e.vv.SetViews(e.views[:used])</span><br><span class="line">e.vv.SetSize(n)</span><br><span class="line">e.vv.TrimFront(e.hdrSize) <span class="comment">// note: trim eth header, leave the IP protocol</span></span><br><span class="line"></span><br><span class="line">d.DeliverNetworkPacket(e, addr, p, e.vv)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare e.views for another packet: release used views.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; used; i++ &#123;</span><br><span class="line">e.views[i] = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 dispatch 先分配内存，然后读取，而且很明显只读取一个帧数据，由于 MTU 限制，通常大小为 1518B，所以不明白为什么会分配大约 64KB 的内存。</p><p>特别看一下 blockReadv 的实现，这个函数将底层的非阻塞读封装成了阻塞读。先回顾一下非阻塞 IO 模型：</p><p><img src="/images/netstack/nonblock.svg" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BlockingReadv</span><span class="params">(fd <span class="keyword">int</span>, iovecs []syscall.Iovec)</span> <span class="params">(<span class="keyword">int</span>, *tcpip.Error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, _, e := syscall.RawSyscall(syscall.SYS_READV, <span class="keyword">uintptr</span>(fd), <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;iovecs[<span class="number">0</span>])), <span class="keyword">uintptr</span>(<span class="built_in">len</span>(iovecs)))</span><br><span class="line"><span class="comment">// 注意这里可能阻塞，也可能不阻塞。首先这是一个 NonBlocking IO，如上图。数据没有准备好时，立即返回，数据准备好时，阻塞拷贝到 user 空间。</span></span><br><span class="line"><span class="keyword">if</span> e == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(n), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event := <span class="keyword">struct</span> &#123;</span><br><span class="line">fd      <span class="keyword">int32</span></span><br><span class="line">events  <span class="keyword">int16</span></span><br><span class="line">revents <span class="keyword">int16</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">fd:     <span class="keyword">int32</span>(fd),</span><br><span class="line">events: <span class="number">1</span>, <span class="comment">// POLLIN</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, e = blockingPoll(unsafe.Pointer(&amp;event), <span class="number">1</span>, <span class="number">-1</span>) </span><br><span class="line">        <span class="comment">// 这里会阻塞直到有事件触发。第二个参数是 event 个数，第三个参数是指等待的时间，时间到了，不论有没有事件到来，都要返回，-1 代表无限等待。关于 poll 可以参考这里:</span></span><br><span class="line">        <span class="comment">// http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html</span></span><br><span class="line"><span class="keyword">if</span> e != <span class="number">0</span> &amp;&amp; e != syscall.EINTR &#123; <span class="comment">// err=EINTR 代表需要重新发起调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, TranslateErrno(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取到一个数据帧后，调用<code>d.DeliverNetworkPacket(e, addr, p, e.vv)</code>把数据分发到 network 层。这里涉及到 NetworkDispatcher 接口，在代码里由 NIC 实现，这次就不讨论了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NetworkDispatcher <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// DeliverNetworkPacket finds the appropriate network protocol</span></span><br><span class="line"><span class="comment">// endpoint and hands the packet over for further processing.</span></span><br><span class="line">DeliverNetworkPacket(linkEP LinkEndpoint, remoteLinkAddr tcpip.LinkAddress, protocol tcpip.NetworkProtocolNumber, vv *buffer.VectorisedView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel-、loopback、sniffer-endpoint"><a href="#channel-、loopback、sniffer-endpoint" class="headerlink" title="channel 、loopback、sniffer endpoint"></a>channel 、loopback、sniffer endpoint</h3><p>这里简单讨论一下其他的 endpoint 实现。</p><h5 id="channel-endpoint"><a href="#channel-endpoint" class="headerlink" title="channel endpoint"></a>channel endpoint</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PacketInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">Header  buffer.View</span><br><span class="line">Payload buffer.View</span><br><span class="line">Proto   tcpip.NetworkProtocolNumber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Endpoint <span class="keyword">struct</span> &#123;</span><br><span class="line">dispatcher stack.NetworkDispatcher</span><br><span class="line">mtu        <span class="keyword">uint32</span></span><br><span class="line">linkAddr   tcpip.LinkAddress</span><br><span class="line"></span><br><span class="line"><span class="comment">// C is where outbound packets are queued.</span></span><br><span class="line">C <span class="keyword">chan</span> PacketInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel 主要是实现内部通信，所以写数据就是直接把帧放到 channel 形成队列：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WritePacket stores outbound packets into the channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endpoint)</span> <span class="title">WritePacket</span><span class="params">(_ *stack.Route, hdr *buffer.Prependable, payload buffer.View, protocol tcpip.NetworkProtocolNumber)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">p := PacketInfo&#123;</span><br><span class="line">Header: hdr.View(),</span><br><span class="line">Proto:  protocol,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> payload != <span class="literal">nil</span> &#123;</span><br><span class="line">p.Payload = <span class="built_in">make</span>(buffer.View, <span class="built_in">len</span>(payload))</span><br><span class="line"><span class="built_in">copy</span>(p.Payload, payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e.C &lt;- p:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="loopback-endpoint"><a href="#loopback-endpoint" class="headerlink" title="loopback endpoint"></a>loopback endpoint</h4><p>环回的 endpoint 就更简单了，不需要经过网卡，经过它发送的数据立即被looped back到IP层的输入队列中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">WritePacket</span><span class="params">(_ *stack.Route, hdr *buffer.Prependable, payload buffer.View, protocol tcpip.NetworkProtocolNumber)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(payload) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// We don't have a payload, so just use the buffer from the</span></span><br><span class="line"><span class="comment">// header as the full packet.</span></span><br><span class="line">v := hdr.View()</span><br><span class="line">vv := v.ToVectorisedView([<span class="number">1</span>]buffer.View&#123;&#125;)</span><br><span class="line">e.dispatcher.DeliverNetworkPacket(e, <span class="string">""</span>, protocol, &amp;vv)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">views := []buffer.View&#123;hdr.View(), payload&#125;</span><br><span class="line">vv := buffer.NewVectorisedView(<span class="built_in">len</span>(views[<span class="number">0</span>])+<span class="built_in">len</span>(views[<span class="number">1</span>]), views)</span><br><span class="line">e.dispatcher.DeliverNetworkPacket(e, <span class="string">""</span>, protocol, &amp;vv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外特别的是，由于不经过实际链路，所以没有通常意义的 MTU，它的 MTU 可以取到最大值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*endpoint)</span> <span class="title">MTU</span><span class="params">()</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">65536</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sniffer-endpoint"><a href="#sniffer-endpoint" class="headerlink" title="sniffer endpoint"></a>sniffer endpoint</h4><p>sniffer 意思是探测器，这个 endpoint 只是对一个正常的 endpoint 的包装，实现 LinkEndpoint 接口的函数都是调用它所包装的 endpoint。它所实现的功能是记录所有经过它的包，可以用它实现抓包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> endpoint <span class="keyword">struct</span> &#123;</span><br><span class="line">dispatcher stack.NetworkDispatcher</span><br><span class="line">lower      stack.LinkEndpoint</span><br><span class="line">file       *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LogPacket</span><span class="params">(prefix <span class="keyword">string</span>, protocol tcpip.NetworkProtocolNumber, b, plb []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netstack-II-链路层&quot;&gt;&lt;a href=&quot;#Netstack-II-链路层&quot; class=&quot;headerlink&quot; title=&quot;Netstack(II) 链路层&quot;&gt;&lt;/a&gt;Netstack(II) 链路层&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;链路层
      
    
    </summary>
    
    
      <category term="tcp" scheme="https://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="https://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>netstack TCP(II) 连接管理与三次握手</title>
    <link href="https://littlechao.top/netstack-tcp/netstack_conn_handshake.html"/>
    <id>https://littlechao.top/netstack-tcp/netstack_conn_handshake.html</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-05-19T02:24:00.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netsatck-TCP-II-连接的建立与三次握手"><a href="#Netsatck-TCP-II-连接的建立与三次握手" class="headerlink" title="Netsatck TCP(II) 连接的建立与三次握手"></a>Netsatck TCP(II) 连接的建立与三次握手</h2><h4 id="protocolListenLoop"><a href="#protocolListenLoop" class="headerlink" title="protocolListenLoop"></a>protocolListenLoop</h4><p>当新建一个 endpoint 并且将其 Bind 到一个端口后，这个endpoint 进入 protocolListenLoop，负责监听与连接建立。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">e.protocolListenLoop(seqnum.Size(e.receiveBufferAvailable()))&#123;<span class="comment">// 同时设置了 rcvBuf 的大小</span></span><br><span class="line">    ctx := newListenContext(e.stack, rcvWnd, v6only, e.netProto)<span class="comment">// 只是为了带一些参数</span></span><br><span class="line"></span><br><span class="line">s := sleep.Sleeper&#123;&#125;</span><br><span class="line">s.AddWaker(&amp;e.notificationWaker, wakerForNotification)</span><br><span class="line">s.AddWaker(&amp;e.newSegmentWaker, wakerForNewSegment)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> index, _ := s.Fetch(<span class="literal">true</span>); index &#123;</span><br><span class="line"><span class="keyword">case</span> wakerForNotification:</span><br><span class="line">n := e.fetchNotifications()</span><br><span class="line"><span class="keyword">if</span> n&amp;notifyClose != <span class="number">0</span> &#123;<span class="comment">// 表示收到退出通知</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> wakerForNewSegment:</span><br><span class="line"><span class="comment">// Process at most maxSegmentsPerWake segments.</span></span><br><span class="line">mayRequeue := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxSegmentsPerWake; i++ &#123; </span><br><span class="line">                <span class="comment">// maxSegmentsPerWake==100,因为收到一个通知可能对应受到了多个数据包，所以每次 wake</span></span><br><span class="line">                <span class="comment">// 都处理多次</span></span><br><span class="line">s := e.segmentQueue.dequeue()</span><br><span class="line">                <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">e.handleListenSegment(ctx, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mayRequeue &amp;&amp; !e.segmentQueue.empty() &#123;</span><br><span class="line">e.newSegmentWaker.Assert()</span><br><span class="line"><span class="comment">// maxSegmentsPerWake 次循环仍然没有处理完所有的包，再次唤醒 waker，继续处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/netstack/tcp_listenLoop.png" alt=""></p><p>handleListenSegment  处理收到的数据包，优先判定是否有 SYN 标识。如果改数据包没有 SYN 而有 ACK 标识的话，那么根据三次握手，它属于第三步，验证其合法后，该数据包对应的连接已经建立，那么为该连接创建一个新的 endpoint，将其发给 Accept 队列。</p><p>只要包含 SYN标识，那么说明该连接处于三步握手的第一步。为什么不是第二步？因为这是 Listen 函数，当前处于连接的被动方。这里会有一个队列，称为 SYN_RCVD 队列或半连接队列。长度为 max(64,/proc/sys/net/ipv4/tcp_max_syn_backlog) ，在机器的tcp_max_syn_backlog值在/proc/sys/net/ipv4/tcp_max_syn_backlog下配置。</p><p><img src="/images/netstack/handshake.png" alt=""></p><p>当这个队列满了，不开启 syncookies 的时候，Server 会丢弃新来的 SYN 包，而 Client 端在多次重发 SYN 包得不到响应而返回（<code>connection time out</code>）错误。但是，当 Server 端开启了 syncookies=1，那么 SYN 半连接队列就没有逻辑上的最大值了，并且 /proc/sys/net/ipv4/tcp_max_syn_backlog 设置的值也会被忽略。在 netstack 中开启了 syncookies。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">handleListenSegment</span><span class="params">(ctx *listenContext, s *segment)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s.flags &#123;</span><br><span class="line"><span class="keyword">case</span> flagSyn:</span><br><span class="line">opts := parseSynSegmentOptions(s)</span><br><span class="line"><span class="keyword">if</span> incSynRcvdCount() &#123; <span class="comment">// 半连接队列长度 +1，成功返回 true，队列已满返回 false</span></span><br><span class="line"><span class="keyword">go</span> e.handleSynSegment(ctx, s, &amp;opts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里采用 SYNCookies 策略，SYN 半连接队列就没有逻辑上的最大值</span></span><br><span class="line">cookie := ctx.createCookie(s.id, s.sequenceNumber, encodeMSS(opts.MSS))</span><br><span class="line">...</span><br><span class="line">sendSynTCP(&amp;s.route, s.id, flagSyn|flagAck, cookie, s.sequenceNumber+<span class="number">1</span>, ctx.rcvWnd, synOpts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> flagAck:</span><br><span class="line"><span class="keyword">if</span> data, ok := ctx.isCookieValid(s.id, s.ackNumber<span class="number">-1</span>, s.sequenceNumber<span class="number">-1</span>); ok &amp;&amp; <span class="keyword">int</span>(data) &lt; <span class="built_in">len</span>(mssTable) &#123; <span class="comment">// 验证 ACK 的正确性</span></span><br><span class="line">...</span><br><span class="line">n, err := ctx.createConnectedEndpoint(s, s.ackNumber<span class="number">-1</span>, s.sequenceNumber<span class="number">-1</span>, rcvdSynOptions)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">e.deliverAccepted(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e.handleSynSegment 做的事情就是创建 handshake 结构体，执行三步握手，然后将完成握手的新的 endpoint 传入 Accept 队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">handleSynSegment</span><span class="params">(ctx *listenContext, s *segment, opts *header.TCPSynOptions)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> decSynRcvdCount() <span class="comment">// 不论最后有没有成功建立连接，把半连接数量 -1</span></span><br><span class="line"></span><br><span class="line">n, err := ctx.createEndpointAndPerformHandshake(s, opts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">e.deliverAccepted(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *listenContext)</span> <span class="title">createEndpointAndPerformHandshake</span><span class="params">(s *segment, opts *header.TCPSynOptions)</span> <span class="params">(*endpoint, *tcpip.Error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create new endpoint.</span></span><br><span class="line">    irs := s.sequenceNumber <span class="comment">// irs: initial remote sequenceNUmber</span></span><br><span class="line">cookie := l.createCookie(s.id, irs, encodeMSS(opts.MSS)) <span class="comment">// 同样需要使用 cookie 来实现验证</span></span><br><span class="line">ep, err := l.createConnectedEndpoint(s, cookie, irs, opts)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform the 3-way handshake.</span></span><br><span class="line">h, err := newHandshake(ep, l.rcvWnd)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> err := h.execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ep.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> ep, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看下 handshake 的 excute 方法，也就是具体执行握手的方法。在看代码之前我们要做到心中有 B 树，哦不，是连接状态机：</p><p><img src="/images/netstack/tcp_state.png" alt=""></p><p>注意这个函数可以在被动的 Listen 函数里调用，也可以在主动的 Connect 里被调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">execute</span><span class="params">()</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="comment">// Initialize the resend timer.</span></span><br><span class="line">resendWaker := sleep.Waker&#123;&#125;</span><br><span class="line">timeOut := time.Duration(time.Second) <span class="comment">// 设置初始 RTO 为 1s</span></span><br><span class="line">rt := time.AfterFunc(timeOut, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">resendWaker.Assert() <span class="comment">// RTO 后触发超时重传</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> rt.Stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up the wakers.</span></span><br><span class="line">s := sleep.Sleeper&#123;&#125;</span><br><span class="line">s.AddWaker(&amp;resendWaker, wakerForResend)</span><br><span class="line">s.AddWaker(&amp;h.ep.notificationWaker, wakerForNotification)</span><br><span class="line">s.AddWaker(&amp;h.ep.newSegmentWaker, wakerForNewSegment)</span><br><span class="line"><span class="keyword">defer</span> s.Done()</span><br><span class="line"></span><br><span class="line">synOpts := header.TCPSynOptions&#123;</span><br><span class="line">WS:    h.rcvWndScale, <span class="comment">// 这里设置的是自己这一端的 wndScale</span></span><br><span class="line">TS:    <span class="literal">true</span>,</span><br><span class="line">TSVal: h.ep.timestamp(),</span><br><span class="line">TSEcr: h.ep.recentTS,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> h.state == handshakeSynRcvd &#123;</span><br><span class="line">synOpts.TS = h.ep.sendTSOk </span><br><span class="line">        <span class="comment">// handshakeSynRcvd 说明当前是由 Listen 调用的被动连接，由对方决定是否使用 TS 选项</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意以下的 ACK 序列号，如果是主动发起连接，该值为 0，相反，则值为 irs + 1</span></span><br><span class="line">sendSynTCP(&amp;h.ep.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> h.state != handshakeCompleted &#123;</span><br><span class="line"><span class="keyword">switch</span> index, _ := s.Fetch(<span class="literal">true</span>); index &#123;</span><br><span class="line"><span class="keyword">case</span> wakerForResend: <span class="comment">// SYN+ACK 超时重传的情况</span></span><br><span class="line">timeOut *= <span class="number">2</span> <span class="comment">// 指数退避行为</span></span><br><span class="line"><span class="keyword">if</span> timeOut &gt; <span class="number">60</span>*time.Second &#123; <span class="comment">// 最大超时时间</span></span><br><span class="line"><span class="keyword">return</span> tcpip.ErrTimeout</span><br><span class="line">&#125;</span><br><span class="line">rt.Reset(timeOut)</span><br><span class="line">sendSynTCP(&amp;h.ep.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> wakerForNotification: <span class="comment">// 收到关闭信号</span></span><br><span class="line">n := h.ep.fetchNotifications()</span><br><span class="line"><span class="keyword">if</span> n&amp;notifyClose != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrAborted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> wakerForNewSegment: <span class="comment">// 等待并处理新的 SYN 数据包或握手第三步的 ACK</span></span><br><span class="line"><span class="keyword">if</span> err := h.processSegments(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，excute 首先发送一个 SYN + ACK 报文（注意这里对应主动和被动两种情况），然后进入循环直到建立连接。同理，h.processSegments 也对应两种情况。如果自己是主动连接，那么自己目前处于 SYN_SENT 状态，等待一个 SYN + ACK 报文并执行 synSentState：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">synSentState</span><span class="params">(s *segment)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="comment">// RFC 793, page 37, states that in the SYN-SENT state, a reset is</span></span><br><span class="line"><span class="comment">// acceptable if the ack field acknowledges the SYN.</span></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagRst) &#123;</span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &amp;&amp; s.ackNumber == h.iss+<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrConnectionRefused</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !h.checkAck(s) || !s.flagIsSet(flagSyn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rcvSynOpts := parseSynSegmentOptions(s)</span><br><span class="line">h.ep.maybeEnableTimestamp(&amp;rcvSynOpts) <span class="comment">// 设置是否允许时间戳选项</span></span><br><span class="line"></span><br><span class="line">h.ackNum = s.sequenceNumber + <span class="number">1</span></span><br><span class="line">h.flags |= flagAck</span><br><span class="line">h.mss = rcvSynOpts.MSS</span><br><span class="line">h.sndWndScale = rcvSynOpts.WS</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &#123; <span class="comment">// 发出 SYN 后收到了 SYN + ACK，再发送一个 ACK，连接就完成建立了</span></span><br><span class="line">h.state = handshakeCompleted</span><br><span class="line">h.ep.sendRaw(<span class="literal">nil</span>, flagAck, h.iss+<span class="number">1</span>, h.ackNum, h.rcvWnd&gt;&gt;h.effectiveRcvWndScale())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这一端对应的是状态机那张图里的‘同时连接’的情况，此时作为主动方已经发出了一个 SYN，然后又收到了一个 SYN，此时只要发送一个 SYN + ACK，对于对方来说这个连接就已经建立了，对于自己来说，再收到一个 SYN + ACK 也算完成连接。</span></span><br><span class="line">h.state = handshakeSynRcvd</span><br><span class="line">synOpts := header.TCPSynOptions&#123;</span><br><span class="line">WS:    h.rcvWndScale,</span><br><span class="line">TS:    rcvSynOpts.TS,</span><br><span class="line">TSVal: h.ep.timestamp(),</span><br><span class="line">TSEcr: h.ep.recentTS,</span><br><span class="line">&#125;</span><br><span class="line">sendSynTCP(&amp;s.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是被动连接，那么自己目前处于 SYN_RCVD 状态，等待一个 ACK：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">synRcvdState</span><span class="params">(s *segment)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagRst) &#123; <span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> s.sequenceNumber.InWindow(h.ackNum, h.rcvWnd) &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrConnectionRefused</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !h.checkAck(s) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagSyn) &amp;&amp; s.sequenceNumber != h.ackNum<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// 之前已经收到过了一个 SYN，然后又收到了一个 SYN，并且两次 seq 不同，那么认为对方抽风，发送 RST 关闭连接。</span></span><br><span class="line">ack := s.sequenceNumber.Add(s.logicalLen())</span><br><span class="line">seq := seqnum.Value(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &#123;</span><br><span class="line">seq = s.ackNumber</span><br><span class="line">&#125;</span><br><span class="line">h.ep.sendRaw(<span class="literal">nil</span>, flagRst|flagAck, seq, ack, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !h.active &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrInvalidEndpointState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := h.resetState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">synOpts := header.TCPSynOptions&#123;</span><br><span class="line">WS:    h.rcvWndScale,</span><br><span class="line">TS:    h.ep.sendTSOk,</span><br><span class="line">TSVal: h.ep.timestamp(),</span><br><span class="line">TSEcr: h.ep.recentTS,</span><br><span class="line">&#125;</span><br><span class="line">sendSynTCP(&amp;s.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &#123;</span><br><span class="line"><span class="comment">// 如果之前协商好了要带上 timeStamp 选项，但是握手第三步没有带上时间戳，那么丢弃这个 ACK 数据包</span></span><br><span class="line"><span class="keyword">if</span> h.ep.sendTSOk &amp;&amp; !s.parsedOptions.TS &#123;</span><br><span class="line">atomic.AddUint64(&amp;h.ep.stack.MutableStats().DroppedPackets, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新时间戳</span></span><br><span class="line">h.ep.updateRecentTimestamp(s.parsedOptions.TSVal, h.ackNum, s.sequenceNumber)</span><br><span class="line"></span><br><span class="line">h.state = handshakeCompleted </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netsatck-TCP-II-连接的建立与三次握手&quot;&gt;&lt;a href=&quot;#Netsatck-TCP-II-连接的建立与三次握手&quot; class=&quot;headerlink&quot; title=&quot;Netsatck TCP(II) 连接的建立与三次握手&quot;&gt;&lt;/a&gt;Netsatc
      
    
    </summary>
    
      <category term="netstack_tcp" scheme="https://littlechao.top/categories/netstack-tcp/"/>
    
    
      <category term="tcp" scheme="https://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="https://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>netstack TCP(I) 总览</title>
    <link href="https://littlechao.top/netstack-tcp/netstack_tcp_overview.html"/>
    <id>https://littlechao.top/netstack-tcp/netstack_tcp_overview.html</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-05-17T12:49:44.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>netstack 是 Google 开源的用 Go 语言实现的网络协议栈。在之前的几篇文章中我们简要的了解了 TCP 协议的基本内容，接下来我会通过读源码来加深对协议的理解，学习如何架构一个比较复杂的项目。当然只会对源码进行大致的分析以及梳理关键点，源码还需要详细的去阅读。这里附上我 fork 的 <a href="github.com/shichao1996/netstack">netstack项目</a>,我在原来的基础上加了一些自己的注释或一些问题，为了区别原有注释，注释中以 ‘note：’ 开头的是我自己的笔记。如果你是用的 Intellij 的编辑器，参照<a href="http://blog.littlechao.top/2018/04/18/intellij%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A/" target="_blank" rel="noopener">这篇</a>设置高亮。</p></blockquote><h4 id="主要结构及其关联"><a href="#主要结构及其关联" class="headerlink" title="主要结构及其关联"></a>主要结构及其关联</h4><p><img src="/images/netstack/tcp_struct_map.png" alt=""></p><p>TCP 实现里暴露出来的最主要的接口是 EndPoint，它对应 Socket 的概念，提供了应用层常用的 Listen、Accept、Bind、Connect 等等方法。endpoint 结构体实现了 EndPoint 接口，它是一个 TCP 连接一端的实体，主要包含 sender、receiver、handshake 这三个结构体，这三个结构体也实现了一个 TCP 端所需的主要功能。</p><p>还有另一个非常重要的自段：stack，它是整个网络协议栈的抽象，这里负责把网络层和传输层连接起来。</p><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p><img src="/images/netstack/tcp_process.png" alt=""></p><p>整个运行的核心在图中标红的两个循环里，其余的部分代码较少，实现也简单。endpoint 的 Listen 函数在 protocolListenLoop 中监听新的连接请求，主要处理三步握手的 SYN 报文和 ACK 报文，负责连接的被动建立。可以看到，这里会有一个<strong>处于 SYN_RCVD 状态的半连接的队列</strong>。建立好的连接通过一个长度为 <strong>backlog</strong> 的channel，把新建连接对应的 endpoint 放到 backlog 队列，然后执行 Accept 的逻辑。</p><p>需要注意的是，负责 Listen 的 endpoint 管理的是所有未完成的连接，而连接建立以后会获得一个新的 endpoint，专门负责那一个连接。</p><p>Accept 和 Connect 函数处理的都是已经建立好的连接，不同之处是 Connect 是主动发起连接，而 Accept 是被动的。</p><h5 id="sleep-包"><a href="#sleep-包" class="headerlink" title="sleep 包"></a>sleep 包</h5><p>进入 protocolMainLoop 之前，先注册了一些回调函数，然后进入循环，当对应事件发生时，通过 sleeper-waker 机制，调用提前注册的函数。sleep 实现了一个边缘触发的 epoll</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It is similar to edge-triggered epoll waits, where the user registers each object of interest once, and then can repeatedly wait on all of them.</span><br></pre></td></tr></table></figure><p>用法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protocolMainLoop</span><span class="params">()</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// One time set-up.</span></span><br><span class="line">    s := sleep.Sleeper&#123;&#125;</span><br><span class="line"></span><br><span class="line">    funcs := []<span class="keyword">struct</span> &#123;</span><br><span class="line">            w *sleep.Waker</span><br><span class="line">            f <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">        &#125;</span>&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.sndWaker,</span><br><span class="line">                f: e.handleWrite,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.sndCloseWaker,</span><br><span class="line">                f: e.handleClose,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.newSegmentWaker,</span><br><span class="line">                f: e.handleSegments,</span><br><span class="line">            &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        s.AddWaker(funcs[i].w, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called repeatedly.</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v, _ := s.Fetch(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> !funcs[v].f() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入循环以后，就是 endpoint 的 sender 和 receiver 的工作了，TCP 实现的总体结构就是这样了。接下来需要仔细看看连接如何建立，如何三次握手，以及连接建立后如何控制流量与拥塞控制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;netstack 是 Google 开源的用 Go 语言实现的网络协议栈。在之前的几篇文章中我们简要的了解了 TCP 协议的基本内容，接下来我会通过读源码来加深对协议的理解，学习如何架构一个比较复杂的项目。当然只会对源码进行大致的分析以及梳理关键点
      
    
    </summary>
    
      <category term="netstack_tcp" scheme="https://littlechao.top/categories/netstack-tcp/"/>
    
    
      <category term="tcp" scheme="https://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="https://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>Intellij 自定义注释</title>
    <link href="https://littlechao.top/uncategorized/intellij%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A.html"/>
    <id>https://littlechao.top/uncategorized/intellij 自定义注释.html</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.312Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有时候在读好的代码的时候想要自己加上一些注释，并且为了和原来的注释区分开，想让它高亮显示，应该怎么设置呢？</p></blockquote><h4 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h4><ul><li>打开 preference –&gt; editor –&gt; TODO </li><li>在 Patterns 里添加一行, 填写 \b<strong>name</strong>\b.*, 其中 name 就是你的自定义注释，选择颜色，然后就 OK 啦！</li><li>使用的时候按照 todo 那种注释写，不过把 todo 换成你自定义的就好啦</li></ul><p>如图：<br><img src="/images/intellij/example.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有时候在读好的代码的时候想要自己加上一些注释，并且为了和原来的注释区分开，想让它高亮显示，应该怎么设置呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;steps&quot;&gt;&lt;a href=&quot;#steps&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="Intellij" scheme="https://littlechao.top/tags/Intellij/"/>
    
  </entry>
  
  <entry>
    <title>TCP 疑难杂症</title>
    <link href="https://littlechao.top/network-protocol/tcp_faq.html"/>
    <id>https://littlechao.top/network-protocol/tcp_faq.html</id>
    <published>2018-04-04T16:00:00.000Z</published>
    <updated>2018-06-12T08:17:05.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-的一些问题与解答"><a href="#TCP-的一些问题与解答" class="headerlink" title="TCP 的一些问题与解答"></a>TCP 的一些问题与解答</h2><h4 id="TCP-连接的初始化序列号能否固定"><a href="#TCP-连接的初始化序列号能否固定" class="headerlink" title="TCP 连接的初始化序列号能否固定"></a>TCP 连接的初始化序列号能否固定</h4><p>如果初始化序列号（缩写为ISN：Inital Sequence Number）可以固定，我们来看看会出现什么问题：</p><ul><li>假设ISN固定是1，Client和Server建立好一条TCP连接后，Client连续给Server发了10个包，这10个包不知怎么被链路上的路由器缓存了(路由器会毫无先兆地缓存或者丢弃任何的数据包)，这个时候碰巧Client挂掉了；</li><li>然后Client用同样的端口号重新连上Server，Client又连续给Server发了几个包，假设这个时候Client的序列号变成了5；</li><li>接着，之前被路由器缓存的10个数据包全部被路由到Server端了，Server给Client回复确认号10，这个时候，Client整个都不好了，这是什么情况？我的序列号才到5，你怎么给我的确认号是10了，整个都乱了。</li></ul><p>RFC793](<a href="https://tools.ietf.org/html/rfc793)中，建议ISN和一个假的时钟绑在一起，这个时钟会在每4微秒对" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc793)中，建议ISN和一个假的时钟绑在一起，这个时钟会在每4微秒对</a> ISN 做加一操作，直到超过2^32，又从0开始，这需要4小时才会产生 ISN 的回绕问题，这几乎可以保证每个新连接的ISN不会和旧的连接的 ISN 产生冲突。这种递增方式的 ISN，很容易让攻击者猜测到TCP连接的ISN，现在的实现大多是在一个基准值的基础上进行随机的。</p><h4 id="初始化连接的-SYN-超时问题"><a href="#初始化连接的-SYN-超时问题" class="headerlink" title="初始化连接的 SYN 超时问题"></a>初始化连接的 SYN 超时问题</h4><p>Client发送SYN包给Server后挂了，Server 回给 Client 的 SYN-ACK 一直没收到 Client 的 ACK 确认，这个时候这个连接既没建立起来，也不能算失败。这就需要一个超时时间让 Server 将这个连接断开，否则这个连接就会一直占用Server的SYN连接队列中的一个位置，大量这样的连接就会将Server的 SYN 连接队列耗尽，让正常的连接无法得到处理。</p><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了.所以，总共需要 63s，TCP才会把断开这个连接。</p><p>由于，SYN 超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称 SYN flood 攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p><h4 id="TIME-WAIT-状态"><a href="#TIME-WAIT-状态" class="headerlink" title="TIME_WAIT 状态"></a>TIME_WAIT 状态</h4><p><code>TIME_WAIT</code>状态是TCP连接中<strong>主动关闭</strong>连接的一方会进入的状态，在发出最后一个 ACK 包之后，主动关闭方进入 <code>TIME_WAIT</code> 状态，从而确保 ACK 包到达对端，以及等待网络中之前迷路的数据包完全消失，防止端口被复用的时候收到迷路包从而出现收包错误。</p><p><code>TIME_WAIT</code> 状态会持续 2MSL（max segment lifetime）的时间，一般 1 分钟到 4 分钟。在这段时间内端口不能被重新分配使用。</p><p><img src="/images/tcp/four_shakes.png" alt=""></p><p>Linux 上使用 <code>sysctl -a | grep time | grep wait</code> 命令查看如下：</p><p><img src="/images/tcp/msl.png" alt=""></p><h5 id="TIME-WAIT会带来哪些问题呢？"><a href="#TIME-WAIT会带来哪些问题呢？" class="headerlink" title="TIME_WAIT会带来哪些问题呢？"></a>TIME_WAIT会带来哪些问题呢？</h5><ul><li>作为服务器，短时间内关闭了大量的 Client 连接，就会造成服务器上出现大量的TIME_WAIT连接，占据大量的tuple，严重消耗着服务器的资源；</li><li>作为客户端，短时间内大量的短连接，会大量消耗的Client机器的端口，毕竟端口只有65535个，端口被耗尽了，后续就无法在发起新的连接了。</li></ul><h5 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h5><p>服务端为了解决这个 TIME_WAIT 问题，可选的方式有3种：</p><ul><li>保证由客户端主动发起关闭</li><li>关闭的时候使用 RST 方式（set SO_LINGER）</li><li>对处于 TIME_WAIT 状态的 TPC 允许重用（set SO_REUSEADDR），设置TCP参数 net.ipv4.tcp_tw_reuse = 1 和 net.ipv4.tcp_tw_recycle = 1。注意：使用tcp_tw_reuse和tcp_tw_recycle解决TIME_WAIT过多问题是非常危险的，参考<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="noopener">RFC</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-的一些问题与解答&quot;&gt;&lt;a href=&quot;#TCP-的一些问题与解答&quot; class=&quot;headerlink&quot; title=&quot;TCP 的一些问题与解答&quot;&gt;&lt;/a&gt;TCP 的一些问题与解答&lt;/h2&gt;&lt;h4 id=&quot;TCP-连接的初始化序列号能否固定&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="network protocol" scheme="https://littlechao.top/categories/network-protocol/"/>
    
    
      <category term="tcp" scheme="https://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 保活机制</title>
    <link href="https://littlechao.top/network-protocol/tcp_keepalive.html"/>
    <id>https://littlechao.top/network-protocol/tcp_keepalive.html</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-06-12T08:17:05.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-保活机制"><a href="#TCP-保活机制" class="headerlink" title="TCP 保活机制"></a>TCP 保活机制</h2><blockquote><p>TCP 协议没有轮询机制，对于一个没有传输数据的连接来说，连接也可以一直保持。理论上，中间路由器可以崩溃和重启，数据线也可以断开再重连，只要两端没有重启或更改 IP ，依然可以保持连接状态。</p></blockquote><p>有的情况下，服务端需要知道客户端是否已经离开以便回收空间；有的情况下，连接很久不需要数据交换，但是我们希望保持一定的数据流。于是设计了<strong>保活机制</strong>。</p><p>保活机制是一种在不影响数据流内容的情况下探测对方的方式。有一个<strong>保活计时器</strong>实现，定时器超时，就发送一个<strong>保活探测包</strong>，另一端收到后会返回相应的 ACK。</p><p>保活功能默认情况下是关闭的。如果在一段时间（保活时间，keepalive time）连接处于非活动状态，开启了保活功能的一端向另一端发送一个探测报文，如果在一定时间（保活时间间隔，keepalive interval）没有收到响应，那么将继续每隔保活时间间隔发送一个探测报文，直到次数达到一个阈值（保活探测数，keepalive probe）,如果仍然没有响应，就认为对方不可达，连接中断。</p><p>在不同的系统中，这些变量默认值如下：</p><table><thead><tr><th style="text-align:left">times\os</th><th>Linux</th><th>FreeBSD</th><th>OSX</th><th>Windows</th></tr></thead><tbody><tr><td style="text-align:left">keepalive time</td><td>2h</td><td>2h</td><td>2h</td><td>2h</td></tr><tr><td style="text-align:left">keepalive interval</td><td>75s</td><td>75s</td><td>75s</td><td>1s</td></tr><tr><td style="text-align:left">Keepalive probe</td><td>9</td><td>8</td><td>9</td><td>10</td></tr></tbody></table><p>保活报文段可以为空报文段，但通常包含一个字节的数据，它的序列号为对方发送的 ACK 的最大序号减 1（为了不影响已到达的报文段）。即使探测报文丢失也不会重传。</p><h4 id="对方的四种状态"><a href="#对方的四种状态" class="headerlink" title="对方的四种状态"></a>对方的四种状态</h4><ul><li>对方主机正常工作，并且可以到达。对方 TCP 响应正常。</li><li>对方主机已崩溃，包括已经关机或正在重启。对方不会响应探测报文，请求端持续发送 Keepalive probe 次的报文，然后关闭连接</li><li>对方主机崩溃并且已经重启。此时对方收到保活探测报文，会返回一个重置报文段，于是请求方关闭连接</li><li>对方主机正常工作，但是网络不可达。</li></ul><p>一般来说主机无法分辨第二种和第四种情况，这也是一种缺陷，比如当中间路由器崩溃时，连接一方发送保活探测，于是只好断开连接。除了第一种情况，请求端的应用层会收到来自 TCP 层的差错报告，比如连接超时、连接重置等等。</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h5 id="为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过-2-小时，连接也会关闭呢？"><a href="#为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过-2-小时，连接也会关闭呢？" class="headerlink" title="为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过 2 小时，连接也会关闭呢？"></a>为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过 2 小时，连接也会关闭呢？</h5><p><img src="/images/tcp/keepalive.png" alt=""></p><p>如图，两个主机之间 TCP 连接的保持同样会受到中间节点的影响，尤其是会受到防火墙（软件或硬件防火墙）的限制。防火墙的工作特性决定了要维护一个网络连接就需要耗费较多的资源，并且企业防火墙常常位于企业网络的出入口，长时间维护非活跃的 TCP 连接必将导致网络性能的下降。因此，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 TCP 连接断连。</p><p>解决方案：</p><ul><li>延长防火墙终止非活跃的 TCP 连接的时间。例如，针对上述案例，可以调节防火墙设置，将时间设置为大于服务器端设定的 2 小时。</li><li>缩短服务器端的 TCP 连接保活时间。缩短该时间的目的是为了在连接被防火墙终止之前发送保活探测报文，既可以探测客户端状态，又可以使连接变为活跃状态。</li></ul><h5 id="为什么说基于TCP的移动端IM仍然需要心跳保活？"><a href="#为什么说基于TCP的移动端IM仍然需要心跳保活？" class="headerlink" title="为什么说基于TCP的移动端IM仍然需要心跳保活？"></a>为什么说基于TCP的移动端IM仍然需要心跳保活？</h5><p>Keep Alive 机制开启后，TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。一般时间为 7200 s（2h），失败后重试 10 次，每次超时时间 75 s。显然默认值无法满足我们的需求，而修改过设置后就可以满足了吗？答案仍旧是否定的。</p><p>考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的<em>连接活着但业务提供方已死的状态</em>，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态，一直向当前服务器发送些必然会失败的请求。</p><p>KeepAlive 并不适用于检测双方存活的场景，这种场景还得依赖于应用层的心跳。应用层心跳有着更大的灵活性，可以控制检测时机，间隔和处理流程，甚至可以在心跳包上附带额外信息。从这个角度而言，应用层的心跳的确是最佳实践。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-保活机制&quot;&gt;&lt;a href=&quot;#TCP-保活机制&quot; class=&quot;headerlink&quot; title=&quot;TCP 保活机制&quot;&gt;&lt;/a&gt;TCP 保活机制&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;TCP 协议没有轮询机制，对于一个没有传输数据的连接来说，连接也可
      
    
    </summary>
    
      <category term="network protocol" scheme="https://littlechao.top/categories/network-protocol/"/>
    
    
      <category term="tcp" scheme="https://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 拥塞控制</title>
    <link href="https://littlechao.top/network-protocol/tcp_congestion_control.html"/>
    <id>https://littlechao.top/network-protocol/tcp_congestion_control.html</id>
    <published>2018-03-29T16:00:00.000Z</published>
    <updated>2018-06-12T08:15:02.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><blockquote><p>在上一篇文章中，讲了通过滑动窗口实现发送方和接收方之间一对一的流量控制。这次我们来看一下 TCP 协议是如何对网络进行宏观调控，也就是 TCP 拥塞控制。</p></blockquote><h3 id="网络拥塞"><a href="#网络拥塞" class="headerlink" title="网络拥塞"></a>网络拥塞</h3><p>网络中的路由器因无法处理高速到达的流量而被迫丢弃数据信息的现象称为拥塞。这里可能是因为路由器缓存较小或者处理不及时，虽然和流量控制时接收方的情况相似，但是这里有本质区别。因为后者是一对一的，几乎只影响一条连接；后者则影响多个连接。</p><p>当网络中大量的发送方和接收方被要求承担超负荷的通信任务时，可以采用<strong>降低发送方发送速率</strong>或者<strong>丢弃部分数据</strong>（也可二者结合）来降低拥塞。</p><h4 id="TCP-拥塞检测"><a href="#TCP-拥塞检测" class="headerlink" title="TCP 拥塞检测"></a>TCP 拥塞检测</h4><p>通常来说，接收方没有一个精确的方法去知道中间路由器的状态。目前基本的方法有：</p><ul><li>依据丢包情况，如果有丢包发生，可以认为是网络拥堵引发的丢包，但是丢包本身就是不能精确判断的。并且有时候我们不能判断丢包是因为路由器拥塞造成的还是由传输错误造成的（在无线网络中，传输和接收错误是丢包主要原因）</li><li>通过时延测量，当感知到 RTT 明显增大时，可以认为是网络拥堵。但是 RTT 测量本身也没有精确的方法。</li><li>显式收到一个丢包的消息，也称<strong>显式拥塞通知</strong>（Explicit Congestion Notification, ECN）。路由器在发生拥堵的时候，向数据包的 IP 首部中设置两个 ENC 标志位，发送方收到后可知拥塞发生。接收方收到则将其放到 ACK 报文中返回给发送方，直到发送方发来的报文中 CWR（接下来会说到） 字段被置为了 1。但是这个方法主要的限制是，它还没有被很好的推广，网络中很多路由器还不支持它。</li></ul><h4 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h4><p>之前的文章提到，发送方为了适应接收方接受速度，设置了一个发送窗口来控制流量。同样的，当拥堵发生时，也需要控制发送速率，于是引入了一个窗口变量，来反映网络传输能力，称为<strong>拥塞窗口</strong>（Congestion window），记作 cwnd。很直观的，我们可以知道，发送端实际可用窗口 W 表示如下,其中 awnd 表示接收方窗口大小：</p><p>​                                    <strong>W = min(cwnd, awnd)</strong></p><p>也就是说，还没有收到 ACK 的数据量（也称在外数据量）不能多于 W 。通常 W 以字节或包为单位。很明显， W 的值是在随时变化的，并且我们希望 W 接近一个最佳窗口大小——带宽延时积（Bandwidth-Delay Product, BDP）,BDP 表示某一时刻的在外数据量，但是确定一个连接的 BDP 也是一个难点。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><h4 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h4><p>当连接建立之初，还无法获知可用的连接资源，也无法确定 cwnd 初始值（有例外，就是之前文章里提到的目的度量）。这时候不应该直接大量快速的向网络中发送数据，因为会造成更严重的网络拥堵。获得 cwnd 最佳值的唯一方法就是以越来越快的速度发包，直到有数据包丢失（或网络拥堵）。可以考虑<strong>慢启动</strong>发送。在讨论具体算法之前，需要先了解<strong>数据包守恒</strong>的概念。</p><p><img src="/images/tcp_congestion/packet_balance.png" alt=""></p><p>TCP 发送端的拥塞控制行为是由 ACK 的接收来驱动或“控制”的。并且链路的传输能力是固定的，当发送方接收到一个 ACK 时，就表示链路上多了一个“空位”，于是发送方可以再发送一个数据包。数据包守恒就是指链路中最大包的数量守恒。</p><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p><strong>当一个连接刚启动时，或者检测到重传超时导致的丢包时，需要执行慢启动</strong>； TCP 长时间处于空闲状态也可能触发慢启动。其目的是探寻到 cwnd 值已经帮助 TCP 建立 ACK 时钟。</p><p>TCP 发送一定数目的报文开始慢启动，该数目称为初始窗口（IInitial Window，IW）。为了简便，我们讨论 IW 为一个 SMSS （sender’s MSS）的情况。意味着初始 cwnd 大小为 1 SMSS。</p><p>假设没有丢包且每一个数据都有相应的 ACK。那么第一个 ACK 到达，说明可以再发送一个新的报文段（数据包守恒），每收到一个“好的” ACK，<strong>cwnd = cwnd + min(N, SMSS)</strong>，这里的 N 是指那个“好的” ACK 所确认的字节数。所谓“好的”是指 ACK 号使窗口更新了。</p><p>因为通常来说 N 的值等于 SMSS，使得 cwnd 在收到一个 ACK 后增大一倍。所以慢启动实际上是以指数增长，在 K 轮之后，cwnd = 2^K。如下图：</p><p><img src="/images/tcp_congestion/slow_start.png" alt=""></p><p>当接收方开启延时 ACK，则发送方 cwnd 增长曲线如图中蓝色曲线，虽然起步看起来慢，但仍是指数增长。当然这对于带宽延时积很大的网络来说，确实有所浪费，应该采用更好的办法。</p><p>当然不可能让窗口大小无限增长，否则会造成严重的网络拥堵直至网络瘫痪。在上述情况下，cwnd 将大幅减小（减至原值一半），也是慢启动和<strong>拥塞避免</strong>的转折点，与<strong>慢启动阈值</strong>（slow start threshold, ssthresh）有关。</p><h4 id="避免拥塞"><a href="#避免拥塞" class="headerlink" title="避免拥塞"></a>避免拥塞</h4><p>当 cwnd 达到 ssthresh 时，可能还有一些传输资源未被占用。但这时候需要谨慎的试探，不能再以较快速度增大 cwnd。采用避免拥塞算法，每接收到一个新的 ACK，cwnd 会做以下更新：</p><p>​                            <strong>cwnd = cwnd + SMSS * SMSS / cwnd</strong></p><p>假设 cwnd = k * SMSS，则可推导如下：</p><p>​                                <strong>cwnd = cwnd + SMSS / k</strong></p><p>发包来看像这样：</p><p><img src="/images/tcp_congestion/ss_ca.png" alt=""></p><p>通常认为拥塞避免阶段 cwnd 呈线性增长，称为累加增长。</p><h4 id="慢启动-和-拥塞避免-的选择"><a href="#慢启动-和-拥塞避免-的选择" class="headerlink" title="慢启动 和 拥塞避免 的选择"></a>慢启动 和 拥塞避免 的选择</h4><p>通常 TCP 连接总是会选择慢启动和拥塞避免中的一个，依据就是之前提到的慢启动阈值。当 cwnd &lt; ssthresh，采用慢启动算法， cwnd &gt; ssthresh 采用拥塞避免，相等时选择任意都行。所以关键就是 ssthresh 的值，该值并不是固定的，它的主要目的是，<strong>记录上一次最好的窗口估计值</strong>。</p><p>ssthresh 初始值可以任意设定（如 awnd 或更大），这通常会使 TCP 总是以慢启动开始。当出现重传，无论是超时重传还是快速重传，都会导致 ssthresh 值更新如下：</p><p>​                            <strong>ssthresh = max(在外数据值 / 2, 2 * SMSS)</strong></p><p>在外数据值其实就是当前窗口大小。这样通常会使 ssthresh 变小（但也可能使其变大），然后触发拥塞避免。</p><h4 id="Tahoe、Reno、快速恢复-、-标准-TCP"><a href="#Tahoe、Reno、快速恢复-、-标准-TCP" class="headerlink" title="Tahoe、Reno、快速恢复 、 标准 TCP"></a>Tahoe、Reno、快速恢复 、 标准 TCP</h4><blockquote><p>接下来讨论的几个算法是将慢启动和拥塞避免结合使用，并且实现一些优化。</p></blockquote><p>Tahoe 算法规定当重传时，都会进入慢启动，并且丢包时，将 cwnd 设为 1 SMSS。这显然性能不太好，已被弃用，不用深究。</p><p>Reno 算法是标准 TCP 的基础，它根据之前提到的“包守恒”实现了快速恢复，较好的利用了带宽。快速恢复是针对快速重传的情景实现的，来看一下它在标准 TCP 中的使用：</p><ul><li><p>TCP 连接之初采用慢启动，cwnd = 1 SMSS</p></li><li><p>每收到一个好的 ACK，cwnd 就会相应更新：</p><ul><li>cwnd += SMSS     (cwnd &lt; ssthresh )</li></ul></li></ul><ul><li>cwnd += SMSS * SMSS / cwnd       (cwnd &gt; ssthresh)</li></ul><ul><li><p>收到三次冗余 ACK时，执行以下行为：</p><ul><li><p>更新 ssthresh</p></li><li><p>启动快速重传算法，<strong>将 cwnd 设为 ssthresh + 3 * SMSS</strong>（依据包守恒，因为已经有三个包已经收到）</p></li><li><p>每收到一个冗余 ACK，再将 cwnd 增加 1 SMSS</p></li><li><p>当收到一个好的 ACK，说明已经恢复正常，则将 cwnd 重新置为 ssthresh</p><p>注：以上 2、3 步构成了快速恢复,如图：</p></li></ul></li></ul><p><img src="http://7fvbl4.com1.z0.glb.clouddn.com/mmtrix_TCP%E5%8D%8F%E8%AE%AE%E6%A0%886" alt=""></p><p>以下是 Reno 的状态转换图：</p><p><img src="/images/tcp_congestion/reno_fsm.png" alt=""></p><h4 id="NewReno"><a href="#NewReno" class="headerlink" title="NewReno"></a>NewReno</h4><p>Reno 算法在同一窗口下丢失多个包时，其中一个包快速重传成功，就会停止 cwnd 膨胀，造成其它丢失的包可能触发超时重传，然后 cwnd 降为 1 SMSS，吞吐量大大降低。NewReno 采用了一个“恢复点”，指的是收到的 ACK 号大于已发送包的序列号的最大值，达到这个恢复点，才会退出快速恢复。下图最右图中， ACK11 达到了恢复点。</p><p><img src="/images/tcp_congestion/reno_newReno.png" alt=""></p><h4 id="限制传输"><a href="#限制传输" class="headerlink" title="限制传输"></a>限制传输</h4><p>限制传输策略对 TCP 做了微小改进，主要是为了解决窗口较小时，出现丢包，但是没有足够的包去引发快速重传/快速恢复机制。为了尽快触发快速重传，每接收两个连续重复 ACK，就发送一个新的包，使网络中的数据量维持一定数量。这是 TCP 推荐策略。</p><h4 id="拥塞窗口校验"><a href="#拥塞窗口校验" class="headerlink" title="拥塞窗口校验"></a>拥塞窗口校验</h4><h5 id="发送端受限"><a href="#发送端受限" class="headerlink" title="发送端受限"></a>发送端受限</h5><blockquote><p>发送端可能出现发送受限， cwnd 的值就会变的不那么准确。</p></blockquote><ul><li>空闲阶段（idle period）：发送端暂时没有发送的需求，并且之前发送的数据都已经收到 ACK</li><li>应用受限（application-limited period）：发送方实际发送的数据小于 cwnd，并且可能仍有 ACK 未收到</li></ul><p>这里对应 TCP/IP 详解卷一里，书上对于“应用受限”说法不正确。书上说此时“无法发送”，但是查阅 rfc 原文如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;application-limited period&quot; for the time when the sender sends less than is allowed by the congestion or receiver windows.</span><br></pre></td></tr></table></figure><h5 id="CWV"><a href="#CWV" class="headerlink" title="CWV"></a>CWV</h5><p>拥塞窗口校验（Congestion Window Validation）机制规定，需要发送新数据时，距离上次发送操作超过一个 RTO，如果是：</p><ul><li>空闲阶段：<ul><li>ssthresh = max(ssthresh, 0.75 * cwnd)</li><li>每隔一个 RTT，cwnd 减半，但不小于 1 SMSS</li></ul></li><li>应用受限：<ul><li>实际使用的窗口大小记为 W_used</li><li>ssthresh = max(ssthresh, 0.75 * cwnd)</li><li>cwnd = (cwnd + W_used) / 2</li></ul></li></ul><p>在长时间发送暂停后，cwnd 低于 ssthresh，再次发送时会进入慢启动。Linux 默认开启 CWV。</p><h3 id="伪-RTO-处理-——-Eifel-算法"><a href="#伪-RTO-处理-——-Eifel-算法" class="headerlink" title="伪 RTO 处理 —— Eifel 算法"></a>伪 RTO 处理 —— Eifel 算法</h3><p>在之前的超时重传里，我们提到了 伪超时，再来回顾下(注意下图是相当简易的情形，没有考虑延时 ACK 以及 cwnd 增长，会意即可)：</p><p><img src="/images/tcp_congestion/fake_timeout_retrans.png" style="height:400px"></p><p>伪超时可能引起“回退 N 步”的行为，并且可能触发快速重传，浪费不少资源。</p><h5 id="Eifel-检测算法"><a href="#Eifel-检测算法" class="headerlink" title="Eifel 检测算法"></a>Eifel 检测算法</h5><p>该算法利用 TCP 的 TSOPT 选项，在发送生超时后，重传报文并记录 TSV，期待一个 ACK，若 ACK 的 TSER 小于重传报文的 TSV，则认为该 ACK 是对原始报文的确认而不是对重传报文的确认，即认定该重传是伪重传。</p><h5 id="Eifel-响应"><a href="#Eifel-响应" class="headerlink" title="Eifel 响应"></a>Eifel 响应</h5><p>前面提到过，发生超时，则 ssthresh 减半，cwnd 降为 1 SMSS。发生伪超时的话，在 RTO 之后到来的 ACK 会使 cwnd 快速变大，但仍会有不必要重传。</p><p>采用 Eifel 算法，在判定伪超时后，会撤销对 ssthresh 的修改。在每次超时对 ssthresh 修改之前，会用 pipe_prev 变量来保存当前的 ssthresh，以便撤销修改。</p><p>若出现伪重传，当 ACK 到达时，假设 ACK 确认的报文段长度为 A：</p><ul><li>cwnd = 在外数据值 + min(A，IW)</li><li>ssthresh = pipe_prev</li></ul><h3 id="窗口缩减行为"><a href="#窗口缩减行为" class="headerlink" title="窗口缩减行为"></a>窗口缩减行为</h3><p>前面讨论了当失序或者超时的时候 TCP 的行为，这些行为都是通过 ACK 的反馈来触发或者驱动的，换句话说，这些“拥塞”的情况是“猜出来的”。当明确知道发生拥堵了，TCP 会执行<strong>拥塞窗口缩减</strong>（congestion window reducing，CWR）。明确知道拥堵的情况主要有两种：</p><ul><li>收到携带了 ENC-Echo 的报文，由路由器给出的网络拥堵信息</li><li>本地拥堵，上层应用发送速率大于下层协议发送速率</li></ul><p>CWR 处理过程如下：</p><ul><li>ssthresh = cwnd / 2</li><li>cwnd = min(cwnd, 在外数据值 + 1)</li><li>每收到 2 个 ACK，将 cwnd 减 1</li></ul><p>直到 cwnd 达到新的 ssthresh 值或者由于其他原因（如丢包）打断 CWR。</p><h3 id="拥塞控制状态机"><a href="#拥塞控制状态机" class="headerlink" title="拥塞控制状态机"></a>拥塞控制状态机</h3><blockquote><p>这部分内容 TCP/IP 详解卷没有，是从<a href="https://pdfs.semanticscholar.org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf" target="_blank" rel="noopener">这篇论文</a>里总结的，希望能够帮助理解拥塞控制状态。</p></blockquote><p>到此，我们总结一下 TCP 拥塞控制的几个重要状态：</p><ul><li>Open —— 未出现超时或者失序，按照慢启动或者避免拥塞正常处理 ACK</li><li>Lost —— 出现超时重传</li><li>DisOrder —— 失序</li><li>Recover —— 快速重传引发的快速恢复</li><li>CWR —— 明确拥塞时的窗口缩减状态，可打断</li></ul><p><img src="/images/tcp_congestion/congestion_fsm.png" alt=""></p><h3 id="缓冲区膨胀"><a href="#缓冲区膨胀" class="headerlink" title="缓冲区膨胀"></a>缓冲区膨胀</h3><p>这个问题还是很有趣的，所以拿出来讲一下。先说结论，网络设备的缓冲区并不是越大越好，也不是越小越好，而是需要根据链路速率和RTT进行计算，得到一个经验值。</p><h5 id="缓存区过小"><a href="#缓存区过小" class="headerlink" title="缓存区过小"></a>缓存区过小</h5><p>缓冲区过小的问题很明显，如果缓冲区太小，很容易就被写满了，只要不能进行适当的排队，丢包率会高，导致传输效率差。</p><h5 id="缓存区过大"><a href="#缓存区过大" class="headerlink" title="缓存区过大"></a>缓存区过大</h5><p>假设如下场景：</p><p><img src="/images/tcp_congestion/big_cache.png" alt=""></p><p>上图中，我们假设中间的路由设备的buffer极大，理论来说无论来多少数据，都能buffer起来。中间的路由设备，接收速率是1M/s，而发送速率只有10k/s。</p><p>到某一时刻，发送方认为某一数据超时丢失（实际上没有丢失，而是在缓冲区没来得及处理），于是重发，导致缓存区有冗余数据。大量的冗余数据导致利用率变得极低。</p><p>而缓冲区为正常大小的时候，多的数据会被丢弃，过一会而缓冲区有新的位置，新的数据会到来，接收方收到数据是失序的，于是发送冗余 ACK，促进快速重传，反而使链路利用率得到保障。</p><h3 id="与拥塞控制相关的攻击"><a href="#与拥塞控制相关的攻击" class="headerlink" title="与拥塞控制相关的攻击"></a>与拥塞控制相关的攻击</h3><p>大多数攻击是强迫 TCP 发送速率比一般情况更快或更慢。</p><h5 id="ACK-分割攻击"><a href="#ACK-分割攻击" class="headerlink" title="ACK 分割攻击"></a>ACK 分割攻击</h5><p>原理是接收方将原来的确认范围划分成很多小块，把一个 ACK 变成多个 ACK，使得发送方不断增大 cwnd，使网络变的拥堵。可以通过计算每个 ACK 的确认量（而不是一个包）来判断是否是正确的 ACK。</p><h5 id="乐观响应攻击"><a href="#乐观响应攻击" class="headerlink" title="乐观响应攻击"></a>乐观响应攻击</h5><p>接收方对还没到达的数据进行提前确认，使得 RTT 变得比较小，同样使得发送方不断增大 cwnd。可以采用一个可累加的随机数，动态匹配 ACK。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://tools.ietf.org/html/rfc7661" target="_blank" rel="noopener">rfc</a></li></ul><ul><li><p><a href="https://pdfs.semanticscholar.org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf" target="_blank" rel="noopener">Congestion Control in Linux TCP</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-拥塞控制&quot;&gt;&lt;a href=&quot;#TCP-拥塞控制&quot; class=&quot;headerlink&quot; title=&quot;TCP 拥塞控制&quot;&gt;&lt;/a&gt;TCP 拥塞控制&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在上一篇文章中，讲了通过滑动窗口实现发送方和接收方之间一对一的流量
      
    
    </summary>
    
      <category term="network protocol" scheme="https://littlechao.top/categories/network-protocol/"/>
    
    
      <category term="tcp" scheme="https://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 数据流与窗口管理</title>
    <link href="https://littlechao.top/network-protocol/tcp_window_management.html"/>
    <id>https://littlechao.top/network-protocol/tcp_window_management.html</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-06-12T08:17:05.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-数据流与窗口管理"><a href="#TCP-数据流与窗口管理" class="headerlink" title="TCP 数据流与窗口管理"></a>TCP 数据流与窗口管理</h2><h3 id="交互式通信"><a href="#交互式通信" class="headerlink" title="交互式通信"></a>交互式通信</h3><p>ssh 是一个典型的交互式通信协议，它是加密了的，通常每次按键都会生成一个单独的包。另外，ssh 会在服务端对客户端输入的字符进行回显。因此，服务端收到数据包会先发送一个 ACK，然后发送一个回显报文，再由客户端发送对回显报文段的 ACK，如下左图。</p><p><img src="https://image.littlechao.top/20180317033327000018.jpg" alt=""></p><p>但通常第二段和第三段可以合并来减少传输次数，这种方法称为捎带延时确认，如上右图。我们可以再来看看 wireshark 抓的包:</p><p><img src="https://image.littlechao.top/20180317041434000021.jpg" alt=""></p><p>不难发现，这些包三个为一组，先是客户端(192.168.0.120)发送一个加密的包，然后收到服务端一个加密包，然后客户端回复一个 ACK。看一下服务端发过来的包：</p><p><img src="https://image.littlechao.top/20180317043335000022.jpg" alt=""></p><p>可以看到，标志位的 ACK 置为了 1，ACK 值为 145，PSH 位也置为了 1（表明收到后立刻返回给应用层），并且数据段不为空，说明包含了回显的部分。很明显这里采用了捎带延时确认。</p><h3 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h3><p>在很多情况下，TCP 累计确认可以允许延迟一小会儿发送 ACK，以便结合相同方向的数据一起传送。但是显然，TCP 不能延时任意时长，通常建议：TCP 实现延迟应小于 500 ms，实践中延时应小于 200 ms。该延时值是可以配置的可选值如下：禁用延时，始终延时，每隔一个包回复一个 ACK，自动确认时间；默认值为 3。</p><h3 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h3><p>通常在类似于 ssh 这样的应用里，每次传输的数据包非常小，称为微型报文，这些报文会造成相当高的传输代价。可以采用 Nagle 算法来解决这类问题。</p><p>Nagle 算法规定，当一个 TCP 连接有在传数据时，小的报文段（长度小于 SMSS）不会被发送，直到所有在传数据都收到 ACK。并且收到 ACK 后，会收集小数据并整合到一个报文段发送。</p><p>下图为 ssh 应用中没有开启 Nagle 算法（左图）和开启 Nagle 算法（右图）的差别。</p><p><img src="https://image.littlechao.top/20180317121248000003.jpg" height="400px"></p><p>可以看到，没有开启时，同一时刻有很多包在传输，并且有很多小包（tinygram），总体时间短，但是网络负担大。开启了 Nagle 算法时，同一时刻只有一个方向的传输，并且在合适的情况下，合并小包一起发送，时间较长，但传输次数少，网络负担小。</p><h4 id="延时-ACK-与-Nagle-结合"><a href="#延时-ACK-与-Nagle-结合" class="headerlink" title="延时 ACK 与 Nagle 结合"></a>延时 ACK 与 Nagle 结合</h4><p>无论是延迟 ACK 还是 Nagle 算法，其目的都是减少网络中传输的包，减轻网络负担。但是二者一起使用时，可能会出现问题。</p><p>考虑如下情况：客户端依次要发送一个全长报文段以及若干个小包，服务端收到第一个全长包，然后延迟发送 ACK（延时，或者期待第二个全长报文段到达），而客户端采用了 Nagle 算法，需要等到 ACK 到达才能继续发送。这样就会形成一个短暂的死锁，性能反而变差。所以在有些情况下，如 ssh ，可以禁用 Nagle 算法。</p><h3 id="流量控制与窗口管理"><a href="#流量控制与窗口管理" class="headerlink" title="流量控制与窗口管理"></a>流量控制与窗口管理</h3><p> 每个 TCP 报文段的首部里都包含了一个窗口大小字段，该字段占 16 位，最大表示 65536，也就是 64 KB，但 TCP 选项中的窗口缩放选项可以让它表示更大的窗口。</p><p>一般来说每个连接的接收端会有一个大小固定的缓存，用来暂存发送端发来的数据，然后由应用程序读取。当应用程序来不及处理缓存数据，而发送方又不停的发送数据，超出缓存大小，就会造成数据丢失和不必要的重传。窗口大小字段用于 TCP 的流量控制，用于表示接收端可用缓存大小。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h5 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h5><p>每个 TCP 连接的两端都维护了一个发送窗口，结构如下：</p><p><img src="http://www.tcpipguide.com/free/diagrams/tcpswwindows.png"></p><p>主要分四部分：已经发送并收到确认、已经发送但未收到确认、未发送但可以发送、未发送并且目前不能发送。第三部分称为<strong>可用窗口</strong>，第二部分和第三部分合称<strong>发送窗口</strong>。随着时间推移，窗口可以有几种运动：</p><ul><li>关闭：随着 ACK 到来，发送窗口左边界向右移，窗口减小。</li><li>打开：窗口右边界右移，即接收方可用缓存增大，发送方可用窗口也就增大。</li><li>收缩：右边界左移，主机不支持这种做法，但 TCP 必须能处理这种问题。</li></ul><h5 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h5><p>除了发送窗口，接收方还维护了一个接收窗口。</p><p><img src="http://www.tcpipguide.com/free/diagrams/tcpswpointersreceive.png" alt=""></p><p>接收窗口结构简单，包括已经接收且已经回复 ACK、允许对方发送但还未收到、目前不允许对方发送的部分。</p><h5 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h5><p>接收方收到一个数据包后，返回一个 ACK，根据自己的可用接收缓存大小设置 ACK 报文里的窗口大小。发送方收到这个窗口通告后，根据可用窗口大小调整自己的发送窗口，以达到调节发送速率的目的。</p><h4 id="零窗口与-TCP-持续计时器"><a href="#零窗口与-TCP-持续计时器" class="headerlink" title="零窗口与 TCP 持续计时器"></a>零窗口与 TCP 持续计时器</h4><p>当发送方不停发送，接收方又比较忙的时候，可能会导致可用窗口大小为 0。当出现零窗口时，发送方收到一个 ACK 报文，其中的窗口大小为零，那么就表示暂时不能发送数据。而当接收方应用程序开始处理收到的数据，使得接收缓存里又有了空间，但是我们知道，窗口通告是包含在 ACK 报文里的，没有收到新的数据，就没法发送窗口通告，这时就会造成死锁。</p><p>所以当出现零窗口时，发送方会采用一个<strong>持续计时器</strong>间歇地查询接收端是否有可用窗口，持续计时器会触发<strong>窗口探测</strong>（window probe）的传输。为了保证对方能够收到查询，我们必须要往数据段放一些数据，以保证超时重发，通常会放一个字节的数据 。接收方收到窗口探测后，会被强制返回一个 ACK，并且包含自己当前可用窗口大小（这个大小会有特殊情况）。注意这里采用指数退避来计算持续计时器的超时时间。</p><p>前面谈到，大量数据量较小的包会造成传输速度的下降，也会造成网络负担。当接收端可用缓存从 0 慢慢增大到一个较小的值，这时候收到一个窗口探测，为了避免发送较小的包，接收端可以仍然在 ACK 中回复一个零窗口。</p><p><img src="https://www.brianstorti.com/assets/images/tcp-flow-control/window-probe.png" alt=""></p><h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h4><p>当发送方发送的报文大小不固定时，可能会出现<strong>糊涂窗口综合征</strong>（Silly Window Syndrome，SWS）。当出现该问题时，交换的报文数据段大小较小，耗费的资源较多。</p><p>TCP 连接两端都可能导致 SWS：当接收端的通告窗口较小（或者是还没等到窗口变得够大），或者发送端发送的包较小（或者是没有等待其他小数据组合成大数据包）。为了避免 SWS，发送方要遵循一定规则。</p><p>对于接收方：</p><ul><li>不应通告小的窗口值。在窗口增至 min(MSS，接收端缓存的一半) 之前，不能通告比当前窗口（可能为 0）更大的值</li></ul><p>对于发送方，满足任意一个：</p><ul><li>全长报文段可以发送</li><li>数据段长度 &gt;= 最大窗口通告的一半</li><li>该连接禁用 Nagle 算法</li><li>没有未经确认的在传数据</li></ul><h4 id="大容量缓存与自动调优"><a href="#大容量缓存与自动调优" class="headerlink" title="大容量缓存与自动调优"></a>大容量缓存与自动调优</h4><p>在相似的环境下，较小的接收缓存的 TCP 应用吞吐性能会较低。很多 TCP 协议栈中上层应用不能指定接收缓存大小，由操作系统来指定一个固定的或者动态变化的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-数据流与窗口管理&quot;&gt;&lt;a href=&quot;#TCP-数据流与窗口管理&quot; class=&quot;headerlink&quot; title=&quot;TCP 数据流与窗口管理&quot;&gt;&lt;/a&gt;TCP 数据流与窗口管理&lt;/h2&gt;&lt;h3 id=&quot;交互式通信&quot;&gt;&lt;a href=&quot;#交互式通信&quot; c
      
    
    </summary>
    
      <category term="network protocol" scheme="https://littlechao.top/categories/network-protocol/"/>
    
    
      <category term="tcp" scheme="https://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 超时重传</title>
    <link href="https://littlechao.top/network-protocol/tcp_retransmission.html"/>
    <id>https://littlechao.top/network-protocol/tcp_retransmission.html</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-06-12T08:17:05.138Z</updated>
    
    <content type="html"><![CDATA[<p>##TCP超时重传</p><blockquote><p>TCP 提供可靠数据传输服务，为保证传输正确性，TCP 重传其认为已经丢失的包。TCP 有两套重传机制，一是基于定时器（超时），二是基于确认信息的构成（快速重传）。</p></blockquote><p>###基于计时器的重传</p><h4 id="简单的超时重传"><a href="#简单的超时重传" class="headerlink" title="简单的超时重传"></a>简单的超时重传</h4><p><img src="https://image.littlechao.top/20180315023638000003.jpg" alt=""></p><p>图中黑色那条就是因为定时器超时仍没有收到 ACK，所以引起了发送方超时重传。实际上 TCP 有两个阈值来决定如何重传同一个报文段：一是愿意重传的次数 R1、二是应该放弃当前连接的时机 R2。R1 和 R2 的值应分别至少为 3 次和 100 秒，如果超过任何一个但还没能重传成功，会放弃该连接。当然这两个值是可以设置的，在不同系统里默认值也不同。</p><p>那么如何设定一个合适的超时的值呢？假设 TCP 工作在静态环境中，这很容易，但真实网络环境不断变化，需要根据当前状态来设定合适的值。</p><h4 id="超时时间-RTO"><a href="#超时时间-RTO" class="headerlink" title="超时时间 RTO"></a>超时时间 RTO</h4><p>RTO（retransmission timeout）一般是根据RTT（round trip time）也就是往返时间来设置的。若 RTO 小于   RTT，则会造成很多不必要的重传；若 RTO 远大于 RTT，则会降低整体网络利用率，RTO 是保证 TCP 性能的关键。并且不同连接的RTT不相同，同一个连接不同时间的 RTT 也不相同，所以 RTO 的设置一直都是研究热点。</p><p>所以凭我们的直觉，RTO 应该比 RTT 稍大：</p><p>​                                    <strong>RTO=RTT+Δt</strong></p><p>那么，RTT 怎么算呢：</p><p>​                            <strong>SRTT=(1−α)×SRTT+α×RTTnew</strong></p><p>SRTT(smooth RTT)，RTTnew 是新测量的值。如上，为了防止 RTT 抖动太大，给了一个权值 <strong>a</strong> ，也叫平滑因子。a 的值建议在 10%~20%。举个例子，当前 RTTs=200ms，RTTs=200ms，最新一次测量的 RTT=800ms，RTT=800ms，那么更新后的 RTTs=200×0.875+800×0.125=275ms，RTTs=200×0.875+800×0.125=275ms.</p><p><strong>Δt</strong>如何得到呢？RFC 2988 规定：</p><p>​                                <strong>RTO=SRTT+4×RTTD</strong></p><p>因此，按照上面的定义，<strong>Δt=4×RTTD</strong>. 而 RTTD 计算公式如下：</p><p>​                            <strong>RTTD=(1−β)×RTTD+β×|SRTT−RTTnew|</strong></p><p>实际上，RTTD 就是一个均值偏差，它就相当于某个样本到其总体平均值的距离。这就好比你的成绩与你班级平均成绩差了多少。RFC 推荐 β=0.25。</p><h5 id="退避指数"><a href="#退避指数" class="headerlink" title="退避指数"></a>退避指数</h5><p>根据前面的公式，我们可以得到 RTO。一旦超过 RTO 还没收到 ACK，就会引起发送方重传。但如果重传后还是没有在 RTO 时间内收到 ACK，这时候会认为是网络拥堵，会引发 TCP 拥塞控制行为，使 RTO 翻倍。则第 n 次重传的 RTOn 值为：</p><p>​                                <strong>RTOn=2^(n−1)×RTO1</strong></p><p>下图是一个例子：</p><p><img src="http://img.blog.csdn.net/20170422182458581?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTEwMDc3Mjk5OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源：http://blog.csdn.net/q1007729991/article/details/70196099"></p><p>如上，在时间为0.22531时开始第一次重传，此后重传时间开始指数增大，（在尝试了8次后停下，说明其 R2 的值可能为8）。</p><h4 id="带时间戳的-RTT-测量"><a href="#带时间戳的-RTT-测量" class="headerlink" title="带时间戳的 RTT 测量"></a>带时间戳的 RTT 测量</h4><p>前面说了 RTO 的公式，它和 RTT 有关，那么每一次的 RTT 是如何得到的呢？在之前 TCP 连接管理的时候讲过，TCP有一个 TSOPT (timestamp option) 选项，它包含两个时间戳值。它允许发送者在报文中带上一个32比特的时间戳值（TSV），然后接收方 将收到的值原封不动的填入 ACK 报文段中 TSOPT 选项的第二部分，时间戳回显字段（TSER）。发送方收到 ACK 以后，将当前时间戳减去 TSOPT 选项的 TSER 就可得到精确的RTT值。</p><blockquote><p>但是这里有很微妙的细节：接收方在收到数据包后，并不是立即发送 ACK，通常会延时“一小会儿”，多等待几个数据包后返回一个累积 ACK。此时接收方将确认时间最近的报文段的 TSV 填入 TSER 发送给发送方。</p></blockquote><h5 id="重传二义性与-Karn-算法"><a href="#重传二义性与-Karn-算法" class="headerlink" title="重传二义性与 Karn 算法"></a>重传二义性与 Karn 算法</h5><p>还有另一个重要的细节，如果测量 RTT 的样本出现了超时重传，但是我们收到了 ACK 时无法分辨是对哪一次的确认，这时候 RTT 的值可能是不正确的。</p><p>因此，Karn 算法规定：<strong>此时不更新 RTTnew 的值</strong>。并且如果发生再次重传，则采用退避后的 RTO 的值，直到发送成功，退避指数重新设定为 1 。</p><h5 id="丢包和失序的情况"><a href="#丢包和失序的情况" class="headerlink" title="丢包和失序的情况"></a>丢包和失序的情况</h5><p>假设有三个数据包依次发送，1号和3号先到达，2号数据包由于网络因素最后到达。接收方收到3号时，会发送一个1号的冗余 ACK，然后2号到达，此时会发送一个3号的累积 ACK 表明这三个到达。在这个例子里，3号 ACK 并没有立即返回，发送方收到3号的 ACK 后，根据其 TSER 计算此时的 RTT，就会导致发送方过高的估计 RTT，降低重传积极性，使得 RTO 相应增大，当然这在失序时是有好处的，因为过分积极会导致大量的伪重传。</p><h4 id="伪超时与重传"><a href="#伪超时与重传" class="headerlink" title="伪超时与重传"></a>伪超时与重传</h4><p>如下图，在发送第四个 ACK 后出现延迟高峰，导致发送方在 RTO 时间内没有收到 5 ~ 8 的 ACK，于是发生重传，然后之前的 ACK 到达，于是又依次发送 6 ~ 8，就导致了不必要的重传。可以用 Eifel 算法来解决（略）。</p><p><img src="https://image.littlechao.top/20180315075511000005.jpg" style="height:400px"></p><h4 id="目的度量"><a href="#目的度量" class="headerlink" title="目的度量"></a>目的度量</h4><p>从前面可以看出，TCP 可以学习链路特征，如 RTT、SRTT 等，但一旦连接关闭，这些信息就会丢失。即使相同的接收方与发送方建立新的连接，也必须从头开始“学习”。较新的 TCP 实现维护了这些值，在 Linux 中可以通过如下命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route show cache [ip]</span><br></pre></td></tr></table></figure><p>###基于确认信息的重传</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>在大多数情况下，计时器超时并触发重传是不必要的，也不是期望的，因为 RTO 通常是大于 RTT（约2倍或更大），因此基于计时器的重传会导致网络利用率降低。</p><p>首先我们要知道，接收方收到失序报文段时，应立即生成确认信息（重复 ACK），以便发送方尽快、高效地填补空缺。而发送方在收到重复 ACK 时，无法判断是由于数据包丢失还是仅仅因为延迟，所以发送方等待一定数目的重复 ACK （重复 ACK 阈值，dupthresh），这时可以认为是数据包丢失，即便还未超时，也立即发送丢失的分组。</p><p>所以快速重传概括如下：TCP 发送方在观测到至少 dupthresh ( 通常是 3 ) 个重复 ACK，立即重传，而不必得到计时器超时。当然也可以同时发送新的数据。</p><p>示例如下：<img src="https://image.littlechao.top/20180315024222000004.jpg" alt=""></p><h4 id="包失序与包重复"><a href="#包失序与包重复" class="headerlink" title="包失序与包重复"></a>包失序与包重复</h4><h5 id="失序"><a href="#失序" class="headerlink" title="失序"></a>失序</h5><p>当然快速重传也会造成一些问题。在轻微失序的情况下(左图)，不会有什么影响。但在严重失序时(右图)，4号数据包延迟到达，接收方发送 4 个冗余 ACK ，让发送方认为 4 号分组丢失，造成伪快速重传。</p><p><img src="https://image.littlechao.top/20180315092324000007.jpg" alt=""></p><h5 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h5><p>尽管可能性较小，但 IP 协议也可能将单个包传输多次。假如 IP 协议将一个包传输了 4 次，然后发送方接收到 3 个冗余 ACK ，也会让发送方以为分组丢失，导致伪快速重传。</p><h4 id="带选择确认的重传"><a href="#带选择确认的重传" class="headerlink" title="带选择确认的重传"></a>带选择确认的重传</h4><p>在上一篇文章中提到过 TCP 的 SACK 选项，它通过若干个 SACK 块来帮助发送方知道接收方有哪些空缺，可以减少不必要的重传。</p><h5 id="接收端的-SACK-行为"><a href="#接收端的-SACK-行为" class="headerlink" title="接收端的 SACK 行为"></a>接收端的 SACK 行为</h5><p>接收端在 TCP 连接建立期间收到 SACK 选项即可生成 SACK。通常来说，当收到失序报文段，接收方就会生成 SACK。</p><p>第一个 SACK 块包含的应该是<strong>最近收到的</strong>报文段的序列号范围。由于 SACK 选项空间有限，应尽可能向发送方提供最新信息。其余的 SACK 按先后顺序依次排列，也就是说，该 ACK 报文段除了包含最新接收的序列号信息，还应重复之前的 SACK 信息。这是因为 ACK 报文段是没有重发机制的，可能会丢失，重复提高了其鲁棒性。</p><h5 id="发送端的-SACK-行为"><a href="#发送端的-SACK-行为" class="headerlink" title="发送端的 SACK 行为"></a>发送端的 SACK 行为</h5><p>发送方应该充分利用 SACK 信息来进行重传，称为<strong>选择性重传</strong>。发送方记录累积 ACK 信息和 SACK 信息，当接收到相应序列号范围内的 ACK 时，在其重传缓存中标记该报文段重传成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##TCP超时重传&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 提供可靠数据传输服务，为保证传输正确性，TCP 重传其认为已经丢失的包。TCP 有两套重传机制，一是基于定时器（超时），二是基于确认信息的构成（快速重传）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###
      
    
    </summary>
    
      <category term="network protocol" scheme="https://littlechao.top/categories/network-protocol/"/>
    
    
      <category term="tcp" scheme="https://littlechao.top/tags/tcp/"/>
    
  </entry>
  
</feed>
