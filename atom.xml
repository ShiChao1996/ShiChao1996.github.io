<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://littlechao.top/"/>
  <updated>2018-04-20T08:30:16.305Z</updated>
  <id>http://littlechao.top/</id>
  
  <author>
    <name>Lovae</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>netstack TCP(II) 连接管理与三次握手</title>
    <link href="http://littlechao.top/2018/04/20/netstack_conn_handshake/"/>
    <id>http://littlechao.top/2018/04/20/netstack_conn_handshake/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netsatck-TCP-II-连接的建立与三次握手"><a href="#Netsatck-TCP-II-连接的建立与三次握手" class="headerlink" title="Netsatck TCP(II) 连接的建立与三次握手"></a>Netsatck TCP(II) 连接的建立与三次握手</h2><h4 id="protocolListenLoop"><a href="#protocolListenLoop" class="headerlink" title="protocolListenLoop"></a>protocolListenLoop</h4><p>当新建一个 endpoint 并且将其 Bind 到一个端口后，这个endpoint 进入 protocolListenLoop，负责监听与连接建立。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">e.protocolListenLoop(seqnum.Size(e.receiveBufferAvailable()))&#123;<span class="comment">// 同时设置了 rcvBuf 的大小</span></span><br><span class="line">    ctx := newListenContext(e.stack, rcvWnd, v6only, e.netProto)<span class="comment">// 只是为了带一些参数</span></span><br><span class="line"></span><br><span class="line">s := sleep.Sleeper&#123;&#125;</span><br><span class="line">s.AddWaker(&amp;e.notificationWaker, wakerForNotification)</span><br><span class="line">s.AddWaker(&amp;e.newSegmentWaker, wakerForNewSegment)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> index, _ := s.Fetch(<span class="literal">true</span>); index &#123;</span><br><span class="line"><span class="keyword">case</span> wakerForNotification:</span><br><span class="line">n := e.fetchNotifications()</span><br><span class="line"><span class="keyword">if</span> n&amp;notifyClose != <span class="number">0</span> &#123;<span class="comment">// 表示收到退出通知</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> wakerForNewSegment:</span><br><span class="line"><span class="comment">// Process at most maxSegmentsPerWake segments.</span></span><br><span class="line">mayRequeue := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxSegmentsPerWake; i++ &#123; </span><br><span class="line">                <span class="comment">// maxSegmentsPerWake==100,因为收到一个通知可能对应受到了多个数据包，所以每次 wake</span></span><br><span class="line">                <span class="comment">// 都处理多次</span></span><br><span class="line">s := e.segmentQueue.dequeue()</span><br><span class="line">                <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">e.handleListenSegment(ctx, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mayRequeue &amp;&amp; !e.segmentQueue.empty() &#123;</span><br><span class="line">e.newSegmentWaker.Assert()</span><br><span class="line"><span class="comment">// maxSegmentsPerWake 次循环仍然没有处理完所有的包，再次唤醒 waker，继续处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/netstack/tcp_listenLoop.png" alt=""></p><p>handleListenSegment  处理收到的数据包，优先判定是否有 SYN 标识。如果改数据包没有 SYN 而有 ACK 标识的话，那么根据三次握手，它属于第三步，验证其合法后，该数据包对应的连接已经建立，那么为该连接创建一个新的 endpoint，将其发给 Accept 队列。</p><p>只要包含 SYN标识，那么说明该连接处于三步握手的第一步。为什么不是第二步？因为这是 Listen 函数，当前处于连接的被动方。这里会有一个队列，称为 SYN_RCVD 队列或半连接队列。长度为 max(64,/proc/sys/net/ipv4/tcp_max_syn_backlog) ，在机器的tcp_max_syn_backlog值在/proc/sys/net/ipv4/tcp_max_syn_backlog下配置。</p><p><img src="/images/netstack/handshake.png" alt=""></p><p>当这个队列满了，不开启 syncookies 的时候，Server 会丢弃新来的 SYN 包，而 Client 端在多次重发 SYN 包得不到响应而返回（<code>connection time out</code>）错误。但是，当 Server 端开启了 syncookies=1，那么 SYN 半连接队列就没有逻辑上的最大值了，并且 /proc/sys/net/ipv4/tcp_max_syn_backlog 设置的值也会被忽略。在 netstack 中开启了 syncookies。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">handleListenSegment</span><span class="params">(ctx *listenContext, s *segment)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s.flags &#123;</span><br><span class="line"><span class="keyword">case</span> flagSyn:</span><br><span class="line">opts := parseSynSegmentOptions(s)</span><br><span class="line"><span class="keyword">if</span> incSynRcvdCount() &#123; <span class="comment">// 半连接队列长度 +1，成功返回 true，队列已满返回 false</span></span><br><span class="line"><span class="keyword">go</span> e.handleSynSegment(ctx, s, &amp;opts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里采用 SYNCookies 策略，SYN 半连接队列就没有逻辑上的最大值</span></span><br><span class="line">cookie := ctx.createCookie(s.id, s.sequenceNumber, encodeMSS(opts.MSS))</span><br><span class="line">...</span><br><span class="line">sendSynTCP(&amp;s.route, s.id, flagSyn|flagAck, cookie, s.sequenceNumber+<span class="number">1</span>, ctx.rcvWnd, synOpts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> flagAck:</span><br><span class="line"><span class="keyword">if</span> data, ok := ctx.isCookieValid(s.id, s.ackNumber<span class="number">-1</span>, s.sequenceNumber<span class="number">-1</span>); ok &amp;&amp; <span class="keyword">int</span>(data) &lt; <span class="built_in">len</span>(mssTable) &#123; <span class="comment">// 验证 ACK 的正确性</span></span><br><span class="line">...</span><br><span class="line">n, err := ctx.createConnectedEndpoint(s, s.ackNumber<span class="number">-1</span>, s.sequenceNumber<span class="number">-1</span>, rcvdSynOptions)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">e.deliverAccepted(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e.handleSynSegment 做的事情就是创建 handshake 结构体，执行三步握手，然后将完成握手的新的 endpoint 传入 Accept 队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">handleSynSegment</span><span class="params">(ctx *listenContext, s *segment, opts *header.TCPSynOptions)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> decSynRcvdCount() <span class="comment">// 不论最后有没有成功建立连接，把半连接数量 -1</span></span><br><span class="line"></span><br><span class="line">n, err := ctx.createEndpointAndPerformHandshake(s, opts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">e.deliverAccepted(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *listenContext)</span> <span class="title">createEndpointAndPerformHandshake</span><span class="params">(s *segment, opts *header.TCPSynOptions)</span> <span class="params">(*endpoint, *tcpip.Error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create new endpoint.</span></span><br><span class="line">    irs := s.sequenceNumber <span class="comment">// irs: initial remote sequenceNUmber</span></span><br><span class="line">cookie := l.createCookie(s.id, irs, encodeMSS(opts.MSS)) <span class="comment">// 同样需要使用 cookie 来实现验证</span></span><br><span class="line">ep, err := l.createConnectedEndpoint(s, cookie, irs, opts)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform the 3-way handshake.</span></span><br><span class="line">h, err := newHandshake(ep, l.rcvWnd)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> err := h.execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ep.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> ep, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看下 handshake 的 excute 方法，也就是具体执行握手的方法。在看代码之前我们要做到心中有 B 树，哦不，是连接状态机：</p><p><img src="/images/netstack/tcp_state.png" alt=""></p><p>注意这个函数可以在被动的 Listen 函数里调用，也可以在主动的 Connect 里被调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">execute</span><span class="params">()</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="comment">// Initialize the resend timer.</span></span><br><span class="line">resendWaker := sleep.Waker&#123;&#125;</span><br><span class="line">timeOut := time.Duration(time.Second) <span class="comment">// 设置初始 RTO 为 1s</span></span><br><span class="line">rt := time.AfterFunc(timeOut, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">resendWaker.Assert() <span class="comment">// RTO 后触发超时重传</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> rt.Stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up the wakers.</span></span><br><span class="line">s := sleep.Sleeper&#123;&#125;</span><br><span class="line">s.AddWaker(&amp;resendWaker, wakerForResend)</span><br><span class="line">s.AddWaker(&amp;h.ep.notificationWaker, wakerForNotification)</span><br><span class="line">s.AddWaker(&amp;h.ep.newSegmentWaker, wakerForNewSegment)</span><br><span class="line"><span class="keyword">defer</span> s.Done()</span><br><span class="line"></span><br><span class="line">synOpts := header.TCPSynOptions&#123;</span><br><span class="line">WS:    h.rcvWndScale, <span class="comment">// 这里设置的是自己这一端的 wndScale</span></span><br><span class="line">TS:    <span class="literal">true</span>,</span><br><span class="line">TSVal: h.ep.timestamp(),</span><br><span class="line">TSEcr: h.ep.recentTS,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> h.state == handshakeSynRcvd &#123;</span><br><span class="line">synOpts.TS = h.ep.sendTSOk </span><br><span class="line">        <span class="comment">// handshakeSynRcvd 说明当前是由 Listen 调用的被动连接，由对方决定是否使用 TS 选项</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意以下的 ACK 序列号，如果是主动发起连接，该值为 0，相反，则值为 irs + 1</span></span><br><span class="line">sendSynTCP(&amp;h.ep.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> h.state != handshakeCompleted &#123;</span><br><span class="line"><span class="keyword">switch</span> index, _ := s.Fetch(<span class="literal">true</span>); index &#123;</span><br><span class="line"><span class="keyword">case</span> wakerForResend: <span class="comment">// SYN+ACK 超时重传的情况</span></span><br><span class="line">timeOut *= <span class="number">2</span> <span class="comment">// 指数退避行为</span></span><br><span class="line"><span class="keyword">if</span> timeOut &gt; <span class="number">60</span>*time.Second &#123; <span class="comment">// 最大超时时间</span></span><br><span class="line"><span class="keyword">return</span> tcpip.ErrTimeout</span><br><span class="line">&#125;</span><br><span class="line">rt.Reset(timeOut)</span><br><span class="line">sendSynTCP(&amp;h.ep.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> wakerForNotification: <span class="comment">// 收到关闭信号</span></span><br><span class="line">n := h.ep.fetchNotifications()</span><br><span class="line"><span class="keyword">if</span> n&amp;notifyClose != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrAborted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> wakerForNewSegment: <span class="comment">// 等待并处理新的 SYN 数据包或握手第三步的 ACK</span></span><br><span class="line"><span class="keyword">if</span> err := h.processSegments(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，excute 首先发送一个 SYN + ACK 报文（注意这里对应主动和被动两种情况），然后进入循环直到建立连接。同理，h.processSegments 也对应两种情况。如果自己是主动连接，那么自己目前处于 SYN_SENT 状态，等待一个 SYN + ACK 报文并执行 synSentState：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">synSentState</span><span class="params">(s *segment)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="comment">// RFC 793, page 37, states that in the SYN-SENT state, a reset is</span></span><br><span class="line"><span class="comment">// acceptable if the ack field acknowledges the SYN.</span></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagRst) &#123;</span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &amp;&amp; s.ackNumber == h.iss+<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrConnectionRefused</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !h.checkAck(s) || !s.flagIsSet(flagSyn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rcvSynOpts := parseSynSegmentOptions(s)</span><br><span class="line">h.ep.maybeEnableTimestamp(&amp;rcvSynOpts) <span class="comment">// 设置是否允许时间戳选项</span></span><br><span class="line"></span><br><span class="line">h.ackNum = s.sequenceNumber + <span class="number">1</span></span><br><span class="line">h.flags |= flagAck</span><br><span class="line">h.mss = rcvSynOpts.MSS</span><br><span class="line">h.sndWndScale = rcvSynOpts.WS</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &#123; <span class="comment">// 发出 SYN 后收到了 SYN + ACK，再发送一个 ACK，连接就完成建立了</span></span><br><span class="line">h.state = handshakeCompleted</span><br><span class="line">h.ep.sendRaw(<span class="literal">nil</span>, flagAck, h.iss+<span class="number">1</span>, h.ackNum, h.rcvWnd&gt;&gt;h.effectiveRcvWndScale())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这一端对应的是状态机那张图里的‘同时连接’的情况，此时作为主动方已经发出了一个 SYN，然后又收到了一个 SYN，此时只要发送一个 SYN + ACK，对于对方来说这个连接就已经建立了，对于自己来说，再收到一个 SYN + ACK 也算完成连接。</span></span><br><span class="line">h.state = handshakeSynRcvd</span><br><span class="line">synOpts := header.TCPSynOptions&#123;</span><br><span class="line">WS:    h.rcvWndScale,</span><br><span class="line">TS:    rcvSynOpts.TS,</span><br><span class="line">TSVal: h.ep.timestamp(),</span><br><span class="line">TSEcr: h.ep.recentTS,</span><br><span class="line">&#125;</span><br><span class="line">sendSynTCP(&amp;s.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是被动连接，那么自己目前处于 SYN_RCVD 状态，等待一个 ACK：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">synRcvdState</span><span class="params">(s *segment)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagRst) &#123; <span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> s.sequenceNumber.InWindow(h.ackNum, h.rcvWnd) &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrConnectionRefused</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !h.checkAck(s) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagSyn) &amp;&amp; s.sequenceNumber != h.ackNum<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// 之前已经收到过了一个 SYN，然后又收到了一个 SYN，并且两次 seq 不同，那么认为对方抽风，发送 RST 关闭连接。</span></span><br><span class="line">ack := s.sequenceNumber.Add(s.logicalLen())</span><br><span class="line">seq := seqnum.Value(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &#123;</span><br><span class="line">seq = s.ackNumber</span><br><span class="line">&#125;</span><br><span class="line">h.ep.sendRaw(<span class="literal">nil</span>, flagRst|flagAck, seq, ack, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !h.active &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrInvalidEndpointState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := h.resetState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">synOpts := header.TCPSynOptions&#123;</span><br><span class="line">WS:    h.rcvWndScale,</span><br><span class="line">TS:    h.ep.sendTSOk,</span><br><span class="line">TSVal: h.ep.timestamp(),</span><br><span class="line">TSEcr: h.ep.recentTS,</span><br><span class="line">&#125;</span><br><span class="line">sendSynTCP(&amp;s.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &#123;</span><br><span class="line"><span class="comment">// 如果之前协商好了要带上 timeStamp 选项，但是握手第三步没有带上时间戳，那么丢弃这个 ACK 数据包</span></span><br><span class="line"><span class="keyword">if</span> h.ep.sendTSOk &amp;&amp; !s.parsedOptions.TS &#123;</span><br><span class="line">atomic.AddUint64(&amp;h.ep.stack.MutableStats().DroppedPackets, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新时间戳</span></span><br><span class="line">h.ep.updateRecentTimestamp(s.parsedOptions.TSVal, h.ackNum, s.sequenceNumber)</span><br><span class="line"></span><br><span class="line">h.state = handshakeCompleted </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netsatck-TCP-II-连接的建立与三次握手&quot;&gt;&lt;a href=&quot;#Netsatck-TCP-II-连接的建立与三次握手&quot; class=&quot;headerlink&quot; title=&quot;Netsatck TCP(II) 连接的建立与三次握手&quot;&gt;&lt;/a&gt;Netsatc
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="http://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>netstack TCP(I) 总览</title>
    <link href="http://littlechao.top/2018/04/16/netstack%20%E6%80%BB%E8%A7%88/"/>
    <id>http://littlechao.top/2018/04/16/netstack 总览/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-04-20T08:33:07.288Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>netstack 是 Google 开源的用 Go 语言实现的网络协议栈。在之前的几篇文章中我们简要的了解了 TCP 协议的基本内容，接下来我会通过读源码来加深对协议的理解，学习如何架构一个比较复杂的项目。当然只会对源码进行大致的分析以及梳理关键点，源码还需要详细的去阅读。这里附上我 fork 的 <a href="github.com/shichao1996/netstack">netstack项目</a>,我在原来的基础上加了一些自己的注释或一些问题，为了区别原有注释，注释中以 ‘note：’ 开头的是我自己的笔记。如果你是用的 Intellij 的编辑器，参照<a href="http://blog.littlechao.top/2018/04/18/intellij%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A/" target="_blank" rel="noopener">这篇</a>设置高亮。</p></blockquote><h4 id="主要结构及其关联"><a href="#主要结构及其关联" class="headerlink" title="主要结构及其关联"></a>主要结构及其关联</h4><p><img src="/images/netstack/tcp_struct_map.png" alt=""></p><p>TCP 实现里暴露出来的最主要的接口是 EndPoint，它对应 Socket 的概念，提供了应用层常用的 Listen、Accept、Bind、Connect 等等方法。endpoint 结构体实现了 EndPoint 接口，它是一个 TCP 连接一端的实体，主要包含 sender、receiver、handshake 这三个结构体，这三个结构体也实现了一个 TCP 端所需的主要功能。</p><p>还有另一个非常重要的自段：stack，它是整个网络协议栈的抽象，这里负责把网络层和传输层连接起来。</p><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p><img src="/images/netstack/tcp_process.png" alt=""></p><p>整个运行的核心在图中标红的两个循环里，其余的部分代码较少，实现也简单。endpoint 的 Listen 函数在 protocolListenLoop 中监听新的连接请求，主要处理三步握手的 SYN 报文和 ACK 报文，负责连接的被动建立。可以看到，这里会有一个<strong>处于 SYN_RCVD 状态的半连接的队列</strong>。建立好的连接通过一个长度为 <strong>backlog</strong> 的channel，把新建连接对应的 endpoint 放到 backlog 队列，然后执行 Accept 的逻辑。</p><p>需要注意的是，负责 Listen 的 endpoint 管理的是所有未完成的连接，而连接建立以后会获得一个新的 endpoint，专门负责那一个连接。</p><p>Accept 和 Connect 函数处理的都是已经建立好的连接，不同之处是 Connect 是主动发起连接，而 Accept 是被动的。</p><h5 id="sleep-包"><a href="#sleep-包" class="headerlink" title="sleep 包"></a>sleep 包</h5><p>进入 protocolMainLoop 之前，先注册了一些回调函数，然后进入循环，当对应事件发生时，通过 sleeper-waker 机制，调用提前注册的函数。sleep 实现了一个边缘触发的 epoll</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It is similar to edge-triggered epoll waits, where the user registers each object of interest once, and then can repeatedly wait on all of them.</span><br></pre></td></tr></table></figure><p>用法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protocolMainLoop</span><span class="params">()</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// One time set-up.</span></span><br><span class="line">    s := sleep.Sleeper&#123;&#125;</span><br><span class="line"></span><br><span class="line">    funcs := []<span class="keyword">struct</span> &#123;</span><br><span class="line">            w *sleep.Waker</span><br><span class="line">            f <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">        &#125;</span>&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.sndWaker,</span><br><span class="line">                f: e.handleWrite,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.sndCloseWaker,</span><br><span class="line">                f: e.handleClose,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.newSegmentWaker,</span><br><span class="line">                f: e.handleSegments,</span><br><span class="line">            &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        s.AddWaker(funcs[i].w, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called repeatedly.</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v, _ := s.Fetch(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> !funcs[v].f() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入循环以后，就是 endpoint 的 sender 和 receiver 的工作了，TCP 实现的总体结构就是这样了。接下来需要仔细看看连接如何建立，如何三次握手，以及连接建立后如何控制流量与拥塞控制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;netstack 是 Google 开源的用 Go 语言实现的网络协议栈。在之前的几篇文章中我们简要的了解了 TCP 协议的基本内容，接下来我会通过读源码来加深对协议的理解，学习如何架构一个比较复杂的项目。当然只会对源码进行大致的分析以及梳理关键点
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="http://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>Intellij 自定义注释</title>
    <link href="http://littlechao.top/2018/04/15/intellij%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A/"/>
    <id>http://littlechao.top/2018/04/15/intellij 自定义注释/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.312Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有时候在读好的代码的时候想要自己加上一些注释，并且为了和原来的注释区分开，想让它高亮显示，应该怎么设置呢？</p><h4 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h4><ul><li>打开 preference –&gt; editor –&gt; TODO </li><li>在 Patterns 里添加一行, 填写 \b<strong>name</strong>\b.*, 其中 name 就是你的自定义注释，选择颜色，然后就 OK 啦！</li><li>使用的时候按照 todo 那种注释写，不过把 todo 换成你自定义的就好啦</li></ul></blockquote><p>如图：<br><img src="/images/intellij/example.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有时候在读好的代码的时候想要自己加上一些注释，并且为了和原来的注释区分开，想让它高亮显示，应该怎么设置呢？&lt;/p&gt;
&lt;h4 id=&quot;steps&quot;&gt;&lt;a href=&quot;#steps&quot; class=&quot;headerlink&quot; title=&quot;steps&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Intellij" scheme="http://littlechao.top/tags/Intellij/"/>
    
  </entry>
  
  <entry>
    <title>TCP 疑难杂症</title>
    <link href="http://littlechao.top/2018/04/05/tcp_faq/"/>
    <id>http://littlechao.top/2018/04/05/tcp_faq/</id>
    <published>2018-04-04T16:00:00.000Z</published>
    <updated>2018-05-06T15:43:42.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-的一些问题与解答"><a href="#TCP-的一些问题与解答" class="headerlink" title="TCP 的一些问题与解答"></a>TCP 的一些问题与解答</h2><h4 id="TCP-连接的初始化序列号能否固定"><a href="#TCP-连接的初始化序列号能否固定" class="headerlink" title="TCP 连接的初始化序列号能否固定"></a>TCP 连接的初始化序列号能否固定</h4><p>如果初始化序列号（缩写为ISN：Inital Sequence Number）可以固定，我们来看看会出现什么问题：</p><ul><li>假设ISN固定是1，Client和Server建立好一条TCP连接后，Client连续给Server发了10个包，这10个包不知怎么被链路上的路由器缓存了(路由器会毫无先兆地缓存或者丢弃任何的数据包)，这个时候碰巧Client挂掉了；</li><li>然后Client用同样的端口号重新连上Server，Client又连续给Server发了几个包，假设这个时候Client的序列号变成了5；</li><li>接着，之前被路由器缓存的10个数据包全部被路由到Server端了，Server给Client回复确认号10，这个时候，Client整个都不好了，这是什么情况？我的序列号才到5，你怎么给我的确认号是10了，整个都乱了。</li></ul><p>RFC793](<a href="https://tools.ietf.org/html/rfc793)中，建议ISN和一个假的时钟绑在一起，这个时钟会在每4微秒对" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc793)中，建议ISN和一个假的时钟绑在一起，这个时钟会在每4微秒对</a> ISN 做加一操作，直到超过2^32，又从0开始，这需要4小时才会产生 ISN 的回绕问题，这几乎可以保证每个新连接的ISN不会和旧的连接的 ISN 产生冲突。这种递增方式的 ISN，很容易让攻击者猜测到TCP连接的ISN，现在的实现大多是在一个基准值的基础上进行随机的。</p><h4 id="初始化连接的-SYN-超时问题"><a href="#初始化连接的-SYN-超时问题" class="headerlink" title="初始化连接的 SYN 超时问题"></a>初始化连接的 SYN 超时问题</h4><p>Client发送SYN包给Server后挂了，Server 回给 Client 的 SYN-ACK 一直没收到 Client 的 ACK 确认，这个时候这个连接既没建立起来，也不能算失败。这就需要一个超时时间让 Server 将这个连接断开，否则这个连接就会一直占用Server的SYN连接队列中的一个位置，大量这样的连接就会将Server的 SYN 连接队列耗尽，让正常的连接无法得到处理。</p><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了.所以，总共需要 63s，TCP才会把断开这个连接。</p><p>由于，SYN 超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称 SYN flood 攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p><h4 id="TIME-WAIT-状态"><a href="#TIME-WAIT-状态" class="headerlink" title="TIME_WAIT 状态"></a>TIME_WAIT 状态</h4><p><code>TIME_WAIT</code>状态是TCP连接中<strong>主动关闭</strong>连接的一方会进入的状态，在发出最后一个 ACK 包之后，主动关闭方进入 <code>TIME_WAIT</code> 状态，从而确保 ACK 包到达对端，以及等待网络中之前迷路的数据包完全消失，防止端口被复用的时候收到迷路包从而出现收包错误。</p><p><code>TIME_WAIT</code> 状态会持续 2MSL（max segment lifetime）的时间，一般 1 分钟到 4 分钟。在这段时间内端口不能被重新分配使用。</p><p><img src="./images/four_shakes.png" alt=""></p><p>Linux 上使用 <code>sysctl -a | grep time | grep wait</code> 命令查看如下：</p><p><img src="./images/msl.png" alt=""></p><h5 id="TIME-WAIT会带来哪些问题呢？"><a href="#TIME-WAIT会带来哪些问题呢？" class="headerlink" title="TIME_WAIT会带来哪些问题呢？"></a>TIME_WAIT会带来哪些问题呢？</h5><ul><li>作为服务器，短时间内关闭了大量的 Client 连接，就会造成服务器上出现大量的TIME_WAIT连接，占据大量的tuple，严重消耗着服务器的资源；</li><li>作为客户端，短时间内大量的短连接，会大量消耗的Client机器的端口，毕竟端口只有65535个，端口被耗尽了，后续就无法在发起新的连接了。</li></ul><h5 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h5><p>服务端为了解决这个 TIME_WAIT 问题，可选的方式有3种：</p><ul><li>保证由客户端主动发起关闭</li><li>关闭的时候使用 RST 方式（set SO_LINGER）</li><li>对处于 TIME_WAIT 状态的 TPC 允许重用（set SO_REUSEADDR），设置TCP参数 net.ipv4.tcp_tw_reuse = 1 和 net.ipv4.tcp_tw_recycle = 1。注意：使用tcp_tw_reuse和tcp_tw_recycle解决TIME_WAIT过多问题是非常危险的，参考<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="noopener">RFC</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-的一些问题与解答&quot;&gt;&lt;a href=&quot;#TCP-的一些问题与解答&quot; class=&quot;headerlink&quot; title=&quot;TCP 的一些问题与解答&quot;&gt;&lt;/a&gt;TCP 的一些问题与解答&lt;/h2&gt;&lt;h4 id=&quot;TCP-连接的初始化序列号能否固定&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 保活机制</title>
    <link href="http://littlechao.top/2018/04/03/tcp_keepalive/"/>
    <id>http://littlechao.top/2018/04/03/tcp_keepalive/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-05-06T15:45:31.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-保活机制"><a href="#TCP-保活机制" class="headerlink" title="TCP 保活机制"></a>TCP 保活机制</h2><blockquote><p>TCP 协议没有轮询机制，对于一个没有传输数据的连接来说，连接也可以一直保持。理论上，中间路由器可以崩溃和重启，数据线也可以断开再重连，只要两端没有重启或更改 IP ，依然可以保持连接状态。</p></blockquote><p>有的情况下，服务端需要知道客户端是否已经离开以便回收空间；有的情况下，连接很久不需要数据交换，但是我们希望保持一定的数据流。于是设计了<strong>保活机制</strong>。</p><p>保活机制是一种在不影响数据流内容的情况下探测对方的方式。有一个<strong>保活计时器</strong>实现，定时器超时，就发送一个<strong>保活探测包</strong>，另一端收到后会返回相应的 ACK。</p><p>保活功能默认情况下是关闭的。如果在一段时间（保活时间，keepalive time）连接处于非活动状态，开启了保活功能的一端向另一端发送一个探测报文，如果在一定时间（保活时间间隔，keepalive interval）没有收到响应，那么将继续每隔保活时间间隔发送一个探测报文，直到次数达到一个阈值（保活探测数，keepalive probe）,如果仍然没有响应，就认为对方不可达，连接中断。</p><p>在不同的系统中，这些变量默认值如下：</p><table><thead><tr><th style="text-align:left">times\os</th><th>Linux</th><th>FreeBSD</th><th>OSX</th><th>Windows</th></tr></thead><tbody><tr><td style="text-align:left">keepalive time</td><td>2h</td><td>2h</td><td>2h</td><td>2h</td></tr><tr><td style="text-align:left">keepalive interval</td><td>75s</td><td>75s</td><td>75s</td><td>1s</td></tr><tr><td style="text-align:left">Keepalive probe</td><td>9</td><td>8</td><td>9</td><td>10</td></tr></tbody></table><p>保活报文段可以为空报文段，但通常包含一个字节的数据，它的序列号为对方发送的 ACK 的最大序号减 1（为了不影响已到达的报文段）。即使探测报文丢失也不会重传。</p><h4 id="对方的四种状态"><a href="#对方的四种状态" class="headerlink" title="对方的四种状态"></a>对方的四种状态</h4><ul><li>对方主机正常工作，并且可以到达。对方 TCP 响应正常。</li><li>对方主机已崩溃，包括已经关机或正在重启。对方不会响应探测报文，请求端持续发送 Keepalive probe 次的报文，然后关闭连接</li><li>对方主机崩溃并且已经重启。此时对方收到保活探测报文，会返回一个重置报文段，于是请求方关闭连接</li><li>对方主机正常工作，但是网络不可达。</li></ul><p>一般来说主机无法分辨第二种和第四种情况，这也是一种缺陷，比如当中间路由器崩溃时，连接一方发送保活探测，于是只好断开连接。除了第一种情况，请求端的应用层会收到来自 TCP 层的差错报告，比如连接超时、连接重置等等。</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h5 id="为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过-2-小时，连接也会关闭呢？"><a href="#为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过-2-小时，连接也会关闭呢？" class="headerlink" title="为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过 2 小时，连接也会关闭呢？"></a>为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过 2 小时，连接也会关闭呢？</h5><p><img src="/images/tcp/keepalive.png" alt=""></p><p>如图，两个主机之间 TCP 连接的保持同样会受到中间节点的影响，尤其是会受到防火墙（软件或硬件防火墙）的限制。防火墙的工作特性决定了要维护一个网络连接就需要耗费较多的资源，并且企业防火墙常常位于企业网络的出入口，长时间维护非活跃的 TCP 连接必将导致网络性能的下降。因此，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 TCP 连接断连。</p><p>解决方案：</p><ul><li>延长防火墙终止非活跃的 TCP 连接的时间。例如，针对上述案例，可以调节防火墙设置，将时间设置为大于服务器端设定的 2 小时。</li><li>缩短服务器端的 TCP 连接保活时间。缩短该时间的目的是为了在连接被防火墙终止之前发送保活探测报文，既可以探测客户端状态，又可以使连接变为活跃状态。</li></ul><h5 id="为什么说基于TCP的移动端IM仍然需要心跳保活？"><a href="#为什么说基于TCP的移动端IM仍然需要心跳保活？" class="headerlink" title="为什么说基于TCP的移动端IM仍然需要心跳保活？"></a>为什么说基于TCP的移动端IM仍然需要心跳保活？</h5><p>Keep Alive 机制开启后，TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。一般时间为 7200 s（2h），失败后重试 10 次，每次超时时间 75 s。显然默认值无法满足我们的需求，而修改过设置后就可以满足了吗？答案仍旧是否定的。</p><p>考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的<em>连接活着但业务提供方已死的状态</em>，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态，一直向当前服务器发送些必然会失败的请求。</p><p>KeepAlive 并不适用于检测双方存活的场景，这种场景还得依赖于应用层的心跳。应用层心跳有着更大的灵活性，可以控制检测时机，间隔和处理流程，甚至可以在心跳包上附带额外信息。从这个角度而言，应用层的心跳的确是最佳实践。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-保活机制&quot;&gt;&lt;a href=&quot;#TCP-保活机制&quot; class=&quot;headerlink&quot; title=&quot;TCP 保活机制&quot;&gt;&lt;/a&gt;TCP 保活机制&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;TCP 协议没有轮询机制，对于一个没有传输数据的连接来说，连接也可
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 拥塞控制</title>
    <link href="http://littlechao.top/2018/03/30/tcp_congestion_control/"/>
    <id>http://littlechao.top/2018/03/30/tcp_congestion_control/</id>
    <published>2018-03-29T16:00:00.000Z</published>
    <updated>2018-05-06T15:46:07.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><blockquote><p>在上一篇文章中，讲了通过滑动窗口实现发送方和接收方之间一对一的流量控制。这次我们来看一下 TCP 协议是如何对网络进行宏观调控，也就是 TCP 拥塞控制。</p></blockquote><h3 id="网络拥塞"><a href="#网络拥塞" class="headerlink" title="网络拥塞"></a>网络拥塞</h3><p>网络中的路由器因无法处理高速到达的流量而被迫丢弃数据信息的现象称为拥塞。这里可能是因为路由器缓存较小或者处理不及时，虽然和流量控制时接收方的情况相似，但是这里有本质区别。因为后者是一对一的，几乎只影响一条连接；后者则影响多个连接。</p><p>当网络中大量的发送方和接收方被要求承担超负荷的通信任务时，可以采用<strong>降低发送方发送速率</strong>或者<strong>丢弃部分数据</strong>（也可二者结合）来降低拥塞。</p><h4 id="TCP-拥塞检测"><a href="#TCP-拥塞检测" class="headerlink" title="TCP 拥塞检测"></a>TCP 拥塞检测</h4><p>通常来说，接收方没有一个精确的方法去知道中间路由器的状态。目前基本的方法有：</p><ul><li>依据丢包情况，如果有丢包发生，可以认为是网络拥堵引发的丢包，但是丢包本身就是不能精确判断的。并且有时候我们不能判断丢包是因为路由器拥塞造成的还是由传输错误造成的（在无线网络中，传输和接收错误是丢包主要原因）</li><li>通过时延测量，当感知到 RTT 明显增大时，可以认为是网络拥堵。但是 RTT 测量本身也没有精确的方法。</li><li>显式收到一个丢包的消息，也称<strong>显式拥塞通知</strong>（Explicit Congestion Notification, ECN）。路由器在发生拥堵的时候，向数据包的 IP 首部中设置两个 ENC 标志位，发送方收到后可知拥塞发生。接收方收到则将其放到 ACK 报文中返回给发送方，直到发送方发来的报文中 CWR（接下来会说到） 字段被置为了 1。但是这个方法主要的限制是，它还没有被很好的推广，网络中很多路由器还不支持它。</li></ul><h4 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h4><p>之前的文章提到，发送方为了适应接收方接受速度，设置了一个发送窗口来控制流量。同样的，当拥堵发生时，也需要控制发送速率，于是引入了一个窗口变量，来反映网络传输能力，称为<strong>拥塞窗口</strong>（Congestion window），记作 cwnd。很直观的，我们可以知道，发送端实际可用窗口 W 表示如下,其中 awnd 表示接收方窗口大小：</p><p>​                                    <strong>W = min(cwnd, awnd)</strong></p><p>也就是说，还没有收到 ACK 的数据量（也称在外数据量）不能多于 W 。通常 W 以字节或包为单位。很明显， W 的值是在随时变化的，并且我们希望 W 接近一个最佳窗口大小——带宽延时积（Bandwidth-Delay Product, BDP）,BDP 表示某一时刻的在外数据量，但是确定一个连接的 BDP 也是一个难点。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><h4 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h4><p>当连接建立之初，还无法获知可用的连接资源，也无法确定 cwnd 初始值（有例外，就是之前文章里提到的目的度量）。这时候不应该直接大量快速的向网络中发送数据，因为会造成更严重的网络拥堵。获得 cwnd 最佳值的唯一方法就是以越来越快的速度发包，直到有数据包丢失（或网络拥堵）。可以考虑<strong>慢启动</strong>发送。在讨论具体算法之前，需要先了解<strong>数据包守恒</strong>的概念。</p><p><img src="/images/tcp_congestion/packet_balance.png" alt=""></p><p>TCP 发送端的拥塞控制行为是由 ACK 的接收来驱动或“控制”的。并且链路的传输能力是固定的，当发送方接收到一个 ACK 时，就表示链路上多了一个“空位”，于是发送方可以再发送一个数据包。数据包守恒就是指链路中最大包的数量守恒。</p><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p><strong>当一个连接刚启动时，或者检测到重传超时导致的丢包时，需要执行慢启动</strong>； TCP 长时间处于空闲状态也可能触发慢启动。其目的是探寻到 cwnd 值已经帮助 TCP 建立 ACK 时钟。</p><p>TCP 发送一定数目的报文开始慢启动，该数目称为初始窗口（IInitial Window，IW）。为了简便，我们讨论 IW 为一个 SMSS （sender’s MSS）的情况。意味着初始 cwnd 大小为 1 SMSS。</p><p>假设没有丢包且每一个数据都有相应的 ACK。那么第一个 ACK 到达，说明可以再发送一个新的报文段（数据包守恒），每收到一个“好的” ACK，<strong>cwnd = cwnd + min(N, SMSS)</strong>，这里的 N 是指那个“好的” ACK 所确认的字节数。所谓“好的”是指 ACK 号使窗口更新了。</p><p>因为通常来说 N 的值等于 SMSS，使得 cwnd 在收到一个 ACK 后增大一倍。所以慢启动实际上是以指数增长，在 K 轮之后，cwnd = 2^K。如下图：</p><p><img src="/images/tcp_congestion/slow_start.png" alt=""></p><p>当接收方开启延时 ACK，则发送方 cwnd 增长曲线如图中蓝色曲线，虽然起步看起来慢，但仍是指数增长。当然这对于带宽延时积很大的网络来说，确实有所浪费，应该采用更好的办法。</p><p>当然不可能让窗口大小无限增长，否则会造成严重的网络拥堵直至网络瘫痪。在上述情况下，cwnd 将大幅减小（减至原值一半），也是慢启动和<strong>拥塞避免</strong>的转折点，与<strong>慢启动阈值</strong>（slow start threshold, ssthresh）有关。</p><h4 id="避免拥塞"><a href="#避免拥塞" class="headerlink" title="避免拥塞"></a>避免拥塞</h4><p>当 cwnd 达到 ssthresh 时，可能还有一些传输资源未被占用。但这时候需要谨慎的试探，不能再以较快速度增大 cwnd。采用避免拥塞算法，每接收到一个新的 ACK，cwnd 会做以下更新：</p><p>​                            <strong>cwnd = cwnd + SMSS * SMSS / cwnd</strong></p><p>假设 cwnd = k * SMSS，则可推导如下：</p><p>​                                <strong>cwnd = cwnd + SMSS / k</strong></p><p>发包来看像这样：</p><p><img src="/images/tcp_congestion/ss_ca.png" alt=""></p><p>通常认为拥塞避免阶段 cwnd 呈线性增长，称为累加增长。</p><h4 id="慢启动-和-拥塞避免-的选择"><a href="#慢启动-和-拥塞避免-的选择" class="headerlink" title="慢启动 和 拥塞避免 的选择"></a>慢启动 和 拥塞避免 的选择</h4><p>通常 TCP 连接总是会选择慢启动和拥塞避免中的一个，依据就是之前提到的慢启动阈值。当 cwnd &lt; ssthresh，采用慢启动算法， cwnd &gt; ssthresh 采用拥塞避免，相等时选择任意都行。所以关键就是 ssthresh 的值，该值并不是固定的，它的主要目的是，<strong>记录上一次最好的窗口估计值</strong>。</p><p>ssthresh 初始值可以任意设定（如 awnd 或更大），这通常会使 TCP 总是以慢启动开始。当出现重传，无论是超时重传还是快速重传，都会导致 ssthresh 值更新如下：</p><p>​                            <strong>ssthresh = max(在外数据值 / 2, 2 * SMSS)</strong></p><p>在外数据值其实就是当前窗口大小。这样通常会使 ssthresh 变小（但也可能使其变大），然后触发拥塞避免。</p><h4 id="Tahoe、Reno、快速恢复-、-标准-TCP"><a href="#Tahoe、Reno、快速恢复-、-标准-TCP" class="headerlink" title="Tahoe、Reno、快速恢复 、 标准 TCP"></a>Tahoe、Reno、快速恢复 、 标准 TCP</h4><blockquote><p>接下来讨论的几个算法是将慢启动和拥塞避免结合使用，并且实现一些优化。</p></blockquote><p>Tahoe 算法规定当重传时，都会进入慢启动，并且丢包时，将 cwnd 设为 1 SMSS。这显然性能不太好，已被弃用，不用深究。</p><p>Reno 算法是标准 TCP 的基础，它根据之前提到的“包守恒”实现了快速恢复，较好的利用了带宽。快速恢复是针对快速重传的情景实现的，来看一下它在标准 TCP 中的使用：</p><ul><li><p>TCP 连接之初采用慢启动，cwnd = 1 SMSS</p></li><li><p>每收到一个好的 ACK，cwnd 就会相应更新：</p><ul><li>cwnd += SMSS     (cwnd &lt; ssthresh )</li></ul></li></ul><ul><li>cwnd += SMSS * SMSS / cwnd       (cwnd &gt; ssthresh)</li></ul><ul><li><p>收到三次冗余 ACK时，执行以下行为：</p><ul><li><p>更新 ssthresh</p></li><li><p>启动快速重传算法，<strong>将 cwnd 设为 ssthresh + 3 * SMSS</strong>（依据包守恒，因为已经有三个包已经收到）</p></li><li><p>每收到一个冗余 ACK，再将 cwnd 增加 1 SMSS</p></li><li><p>当收到一个好的 ACK，说明已经恢复正常，则将 cwnd 重新置为 ssthresh</p><p>注：以上 2、3 步构成了快速恢复,如图：</p></li></ul></li></ul><p><img src="http://7fvbl4.com1.z0.glb.clouddn.com/mmtrix_TCP%E5%8D%8F%E8%AE%AE%E6%A0%886" alt=""></p><p>以下是 Reno 的状态转换图：</p><p><img src="/images/tcp_congestion/reno_fsm.png" alt=""></p><h4 id="NewReno"><a href="#NewReno" class="headerlink" title="NewReno"></a>NewReno</h4><p>Reno 算法在同一窗口下丢失多个包时，其中一个包快速重传成功，就会停止 cwnd 膨胀，造成其它丢失的包可能触发超时重传，然后 cwnd 降为 1 SMSS，吞吐量大大降低。NewReno 采用了一个“恢复点”，指的是收到的 ACK 号大于已发送包的序列号的最大值，达到这个恢复点，才会退出快速恢复。下图最右图中， ACK11 达到了恢复点。</p><p><img src="/images/tcp_congestion/reno_newReno.png" alt=""></p><h4 id="限制传输"><a href="#限制传输" class="headerlink" title="限制传输"></a>限制传输</h4><p>限制传输策略对 TCP 做了微小改进，主要是为了解决窗口较小时，出现丢包，但是没有足够的包去引发快速重传/快速恢复机制。为了尽快触发快速重传，每接收两个连续重复 ACK，就发送一个新的包，使网络中的数据量维持一定数量。这是 TCP 推荐策略。</p><h4 id="拥塞窗口校验"><a href="#拥塞窗口校验" class="headerlink" title="拥塞窗口校验"></a>拥塞窗口校验</h4><h5 id="发送端受限"><a href="#发送端受限" class="headerlink" title="发送端受限"></a>发送端受限</h5><blockquote><p>发送端可能出现发送受限， cwnd 的值就会变的不那么准确。</p></blockquote><ul><li>空闲阶段（idle period）：发送端暂时没有发送的需求，并且之前发送的数据都已经收到 ACK</li><li>应用受限（application-limited period）：发送方实际发送的数据小于 cwnd，并且可能仍有 ACK 未收到</li></ul><p>这里对应 TCP/IP 详解卷一里，书上对于“应用受限”说法不正确。书上说此时“无法发送”，但是查阅 rfc 原文如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;application-limited period&quot; for the time when the sender sends less than is allowed by the congestion or receiver windows.</span><br></pre></td></tr></table></figure><h5 id="CWV"><a href="#CWV" class="headerlink" title="CWV"></a>CWV</h5><p>拥塞窗口校验（Congestion Window Validation）机制规定，需要发送新数据时，距离上次发送操作超过一个 RTO，如果是：</p><ul><li>空闲阶段：<ul><li>ssthresh = max(ssthresh, 0.75 * cwnd)</li><li>每隔一个 RTT，cwnd 减半，但不小于 1 SMSS</li></ul></li><li>应用受限：<ul><li>实际使用的窗口大小记为 W_used</li><li>ssthresh = max(ssthresh, 0.75 * cwnd)</li><li>cwnd = (cwnd + W_used) / 2</li></ul></li></ul><p>在长时间发送暂停后，cwnd 低于 ssthresh，再次发送时会进入慢启动。Linux 默认开启 CWV。</p><h3 id="伪-RTO-处理-——-Eifel-算法"><a href="#伪-RTO-处理-——-Eifel-算法" class="headerlink" title="伪 RTO 处理 —— Eifel 算法"></a>伪 RTO 处理 —— Eifel 算法</h3><p>在之前的超时重传里，我们提到了 伪超时，再来回顾下(注意下图是相当简易的情形，没有考虑延时 ACK 以及 cwnd 增长，会意即可)：</p><p><img src="/images/tcp_congestion/fake_timeout_retrans.png" style="height:400px"></p><p>伪超时可能引起“回退 N 步”的行为，并且可能触发快速重传，浪费不少资源。</p><h5 id="Eifel-检测算法"><a href="#Eifel-检测算法" class="headerlink" title="Eifel 检测算法"></a>Eifel 检测算法</h5><p>该算法利用 TCP 的 TSOPT 选项，在发送生超时后，重传报文并记录 TSV，期待一个 ACK，若 ACK 的 TSER 小于重传报文的 TSV，则认为该 ACK 是对原始报文的确认而不是对重传报文的确认，即认定该重传是伪重传。</p><h5 id="Eifel-响应"><a href="#Eifel-响应" class="headerlink" title="Eifel 响应"></a>Eifel 响应</h5><p>前面提到过，发生超时，则 ssthresh 减半，cwnd 降为 1 SMSS。发生伪超时的话，在 RTO 之后到来的 ACK 会使 cwnd 快速变大，但仍会有不必要重传。</p><p>采用 Eifel 算法，在判定伪超时后，会撤销对 ssthresh 的修改。在每次超时对 ssthresh 修改之前，会用 pipe_prev 变量来保存当前的 ssthresh，以便撤销修改。</p><p>若出现伪重传，当 ACK 到达时，假设 ACK 确认的报文段长度为 A：</p><ul><li>cwnd = 在外数据值 + min(A，IW)</li><li>ssthresh = pipe_prev</li></ul><h3 id="窗口缩减行为"><a href="#窗口缩减行为" class="headerlink" title="窗口缩减行为"></a>窗口缩减行为</h3><p>前面讨论了当失序或者超时的时候 TCP 的行为，这些行为都是通过 ACK 的反馈来触发或者驱动的，换句话说，这些“拥塞”的情况是“猜出来的”。当明确知道发生拥堵了，TCP 会执行<strong>拥塞窗口缩减</strong>（congestion window reducing，CWR）。明确知道拥堵的情况主要有两种：</p><ul><li>收到携带了 ENC-Echo 的报文，由路由器给出的网络拥堵信息</li><li>本地拥堵，上层应用发送速率大于下层协议发送速率</li></ul><p>CWR 处理过程如下：</p><ul><li>ssthresh = cwnd / 2</li><li>cwnd = min(cwnd, 在外数据值 + 1)</li><li>每收到 2 个 ACK，将 cwnd 减 1</li></ul><p>直到 cwnd 达到新的 ssthresh 值或者由于其他原因（如丢包）打断 CWR。</p><h3 id="拥塞控制状态机"><a href="#拥塞控制状态机" class="headerlink" title="拥塞控制状态机"></a>拥塞控制状态机</h3><blockquote><p>这部分内容 TCP/IP 详解卷没有，是从<a href="https://pdfs.semanticscholar.org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf" target="_blank" rel="noopener">这篇论文</a>里总结的，希望能够帮助理解拥塞控制状态。</p></blockquote><p>到此，我们总结一下 TCP 拥塞控制的几个重要状态：</p><ul><li>Open —— 未出现超时或者失序，按照慢启动或者避免拥塞正常处理 ACK</li><li>Lost —— 出现超时重传</li><li>DisOrder —— 失序</li><li>Recover —— 快速重传引发的快速恢复</li><li>CWR —— 明确拥塞时的窗口缩减状态，可打断</li></ul><p><img src="/images/tcp_congestion/congestion_fsm.png" alt=""></p><h3 id="缓冲区膨胀"><a href="#缓冲区膨胀" class="headerlink" title="缓冲区膨胀"></a>缓冲区膨胀</h3><p>这个问题还是很有趣的，所以拿出来讲一下。先说结论，网络设备的缓冲区并不是越大越好，也不是越小越好，而是需要根据链路速率和RTT进行计算，得到一个经验值。</p><h5 id="缓存区过小"><a href="#缓存区过小" class="headerlink" title="缓存区过小"></a>缓存区过小</h5><p>缓冲区过小的问题很明显，如果缓冲区太小，很容易就被写满了，只要不能进行适当的排队，丢包率会高，导致传输效率差。</p><h5 id="缓存区过大"><a href="#缓存区过大" class="headerlink" title="缓存区过大"></a>缓存区过大</h5><p>假设如下场景：</p><p><img src="/images/tcp_congestion/big_cache.png" alt=""></p><p>上图中，我们假设中间的路由设备的buffer极大，理论来说无论来多少数据，都能buffer起来。中间的路由设备，接收速率是1M/s，而发送速率只有10k/s。</p><p>到某一时刻，发送方认为某一数据超时丢失（实际上没有丢失，而是在缓冲区没来得及处理），于是重发，导致缓存区有冗余数据。大量的冗余数据导致利用率变得极低。</p><p>而缓冲区为正常大小的时候，多的数据会被丢弃，过一会而缓冲区有新的位置，新的数据会到来，接收方收到数据是失序的，于是发送冗余 ACK，促进快速重传，反而使链路利用率得到保障。</p><h3 id="与拥塞控制相关的攻击"><a href="#与拥塞控制相关的攻击" class="headerlink" title="与拥塞控制相关的攻击"></a>与拥塞控制相关的攻击</h3><p>大多数攻击是强迫 TCP 发送速率比一般情况更快或更慢。</p><h5 id="ACK-分割攻击"><a href="#ACK-分割攻击" class="headerlink" title="ACK 分割攻击"></a>ACK 分割攻击</h5><p>原理是接收方将原来的确认范围划分成很多小块，把一个 ACK 变成多个 ACK，使得发送方不断增大 cwnd，使网络变的拥堵。可以通过计算每个 ACK 的确认量（而不是一个包）来判断是否是正确的 ACK。</p><h5 id="乐观响应攻击"><a href="#乐观响应攻击" class="headerlink" title="乐观响应攻击"></a>乐观响应攻击</h5><p>接收方对还没到达的数据进行提前确认，使得 RTT 变得比较小，同样使得发送方不断增大 cwnd。可以采用一个可累加的随机数，动态匹配 ACK。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://tools.ietf.org/html/rfc7661" target="_blank" rel="noopener">rfc</a></li></ul><ul><li><p><a href="https://pdfs.semanticscholar.org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf" target="_blank" rel="noopener">Congestion Control in Linux TCP</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-拥塞控制&quot;&gt;&lt;a href=&quot;#TCP-拥塞控制&quot; class=&quot;headerlink&quot; title=&quot;TCP 拥塞控制&quot;&gt;&lt;/a&gt;TCP 拥塞控制&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在上一篇文章中，讲了通过滑动窗口实现发送方和接收方之间一对一的流量
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 数据流与窗口管理</title>
    <link href="http://littlechao.top/2018/03/26/tcp_window_management/"/>
    <id>http://littlechao.top/2018/03/26/tcp_window_management/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-05-06T15:46:24.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-数据流与窗口管理"><a href="#TCP-数据流与窗口管理" class="headerlink" title="TCP 数据流与窗口管理"></a>TCP 数据流与窗口管理</h2><h3 id="交互式通信"><a href="#交互式通信" class="headerlink" title="交互式通信"></a>交互式通信</h3><p>ssh 是一个典型的交互式通信协议，它是加密了的，通常每次按键都会生成一个单独的包。另外，ssh 会在服务端对客户端输入的字符进行回显。因此，服务端收到数据包会先发送一个 ACK，然后发送一个回显报文，再由客户端发送对回显报文段的 ACK，如下左图。</p><p><img src="https://image.littlechao.top/20180317033327000018.jpg" alt=""></p><p>但通常第二段和第三段可以合并来减少传输次数，这种方法称为捎带延时确认，如上右图。我们可以再来看看 wireshark 抓的包:</p><p><img src="https://image.littlechao.top/20180317041434000021.jpg" alt=""></p><p>不难发现，这些包三个为一组，先是客户端(192.168.0.120)发送一个加密的包，然后收到服务端一个加密包，然后客户端回复一个 ACK。看一下服务端发过来的包：</p><p><img src="https://image.littlechao.top/20180317043335000022.jpg" alt=""></p><p>可以看到，标志位的 ACK 置为了 1，ACK 值为 145，PSH 位也置为了 1（表明收到后立刻返回给应用层），并且数据段不为空，说明包含了回显的部分。很明显这里采用了捎带延时确认。</p><h3 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h3><p>在很多情况下，TCP 累计确认可以允许延迟一小会儿发送 ACK，以便结合相同方向的数据一起传送。但是显然，TCP 不能延时任意时长，通常建议：TCP 实现延迟应小于 500 ms，实践中延时应小于 200 ms。该延时值是可以配置的可选值如下：禁用延时，始终延时，每隔一个包回复一个 ACK，自动确认时间；默认值为 3。</p><h3 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h3><p>通常在类似于 ssh 这样的应用里，每次传输的数据包非常小，称为微型报文，这些报文会造成相当高的传输代价。可以采用 Nagle 算法来解决这类问题。</p><p>Nagle 算法规定，当一个 TCP 连接有在传数据时，小的报文段（长度小于 SMSS）不会被发送，直到所有在传数据都收到 ACK。并且收到 ACK 后，会收集小数据并整合到一个报文段发送。</p><p>下图为 ssh 应用中没有开启 Nagle 算法（左图）和开启 Nagle 算法（右图）的差别。</p><p><img src="https://image.littlechao.top/20180317121248000003.jpg" height="400px"></p><p>可以看到，没有开启时，同一时刻有很多包在传输，并且有很多小包（tinygram），总体时间短，但是网络负担大。开启了 Nagle 算法时，同一时刻只有一个方向的传输，并且在合适的情况下，合并小包一起发送，时间较长，但传输次数少，网络负担小。</p><h4 id="延时-ACK-与-Nagle-结合"><a href="#延时-ACK-与-Nagle-结合" class="headerlink" title="延时 ACK 与 Nagle 结合"></a>延时 ACK 与 Nagle 结合</h4><p>无论是延迟 ACK 还是 Nagle 算法，其目的都是减少网络中传输的包，减轻网络负担。但是二者一起使用时，可能会出现问题。</p><p>考虑如下情况：客户端依次要发送一个全长报文段以及若干个小包，服务端收到第一个全长包，然后延迟发送 ACK（延时，或者期待第二个全长报文段到达），而客户端采用了 Nagle 算法，需要等到 ACK 到达才能继续发送。这样就会形成一个短暂的死锁，性能反而变差。所以在有些情况下，如 ssh ，可以禁用 Nagle 算法。</p><h3 id="流量控制与窗口管理"><a href="#流量控制与窗口管理" class="headerlink" title="流量控制与窗口管理"></a>流量控制与窗口管理</h3><p> 每个 TCP 报文段的首部里都包含了一个窗口大小字段，该字段占 16 位，最大表示 65536，也就是 64 KB，但 TCP 选项中的窗口缩放选项可以让它表示更大的窗口。</p><p>一般来说每个连接的接收端会有一个大小固定的缓存，用来暂存发送端发来的数据，然后由应用程序读取。当应用程序来不及处理缓存数据，而发送方又不停的发送数据，超出缓存大小，就会造成数据丢失和不必要的重传。窗口大小字段用于 TCP 的流量控制，用于表示接收端可用缓存大小。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h5 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h5><p>每个 TCP 连接的两端都维护了一个发送窗口，结构如下：</p><p><img src="http://www.tcpipguide.com/free/diagrams/tcpswwindows.png"></p><p>主要分四部分：已经发送并收到确认、已经发送但未收到确认、未发送但可以发送、未发送并且目前不能发送。第三部分称为<strong>可用窗口</strong>，第二部分和第三部分合称<strong>发送窗口</strong>。随着时间推移，窗口可以有几种运动：</p><ul><li>关闭：随着 ACK 到来，发送窗口左边界向右移，窗口减小。</li><li>打开：窗口右边界右移，即接收方可用缓存增大，发送方可用窗口也就增大。</li><li>收缩：右边界左移，主机不支持这种做法，但 TCP 必须能处理这种问题。</li></ul><h5 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h5><p>除了发送窗口，接收方还维护了一个接收窗口。</p><p><img src="http://www.tcpipguide.com/free/diagrams/tcpswpointersreceive.png" alt=""></p><p>接收窗口结构简单，包括已经接收且已经回复 ACK、允许对方发送但还未收到、目前不允许对方发送的部分。</p><h5 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h5><p>接收方收到一个数据包后，返回一个 ACK，根据自己的可用接收缓存大小设置 ACK 报文里的窗口大小。发送方收到这个窗口通告后，根据可用窗口大小调整自己的发送窗口，以达到调节发送速率的目的。</p><h4 id="零窗口与-TCP-持续计时器"><a href="#零窗口与-TCP-持续计时器" class="headerlink" title="零窗口与 TCP 持续计时器"></a>零窗口与 TCP 持续计时器</h4><p>当发送方不停发送，接收方又比较忙的时候，可能会导致可用窗口大小为 0。当出现零窗口时，发送方收到一个 ACK 报文，其中的窗口大小为零，那么就表示暂时不能发送数据。而当接收方应用程序开始处理收到的数据，使得接收缓存里又有了空间，但是我们知道，窗口通告是包含在 ACK 报文里的，没有收到新的数据，就没法发送窗口通告，这时就会造成死锁。</p><p>所以当出现零窗口时，发送方会采用一个<strong>持续计时器</strong>间歇地查询接收端是否有可用窗口，持续计时器会触发<strong>窗口探测</strong>（window probe）的传输。为了保证对方能够收到查询，我们必须要往数据段放一些数据，以保证超时重发，通常会放一个字节的数据 。接收方收到窗口探测后，会被强制返回一个 ACK，并且包含自己当前可用窗口大小（这个大小会有特殊情况）。注意这里采用指数退避来计算持续计时器的超时时间。</p><p>前面谈到，大量数据量较小的包会造成传输速度的下降，也会造成网络负担。当接收端可用缓存从 0 慢慢增大到一个较小的值，这时候收到一个窗口探测，为了避免发送较小的包，接收端可以仍然在 ACK 中回复一个零窗口。</p><p><img src="https://www.brianstorti.com/assets/images/tcp-flow-control/window-probe.png" alt=""></p><h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h4><p>当发送方发送的报文大小不固定时，可能会出现<strong>糊涂窗口综合征</strong>（Silly Window Syndrome，SWS）。当出现该问题时，交换的报文数据段大小较小，耗费的资源较多。</p><p>TCP 连接两端都可能导致 SWS：当接收端的通告窗口较小（或者是还没等到窗口变得够大），或者发送端发送的包较小（或者是没有等待其他小数据组合成大数据包）。为了避免 SWS，发送方要遵循一定规则。</p><p>对于接收方：</p><ul><li>不应通告小的窗口值。在窗口增至 min(MSS，接收端缓存的一半) 之前，不能通告比当前窗口（可能为 0）更大的值</li></ul><p>对于发送方，满足任意一个：</p><ul><li>全长报文段可以发送</li><li>数据段长度 &gt;= 最大窗口通告的一半</li><li>该连接禁用 Nagle 算法</li><li>没有未经确认的在传数据</li></ul><h4 id="大容量缓存与自动调优"><a href="#大容量缓存与自动调优" class="headerlink" title="大容量缓存与自动调优"></a>大容量缓存与自动调优</h4><p>在相似的环境下，较小的接收缓存的 TCP 应用吞吐性能会较低。很多 TCP 协议栈中上层应用不能指定接收缓存大小，由操作系统来指定一个固定的或者动态变化的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-数据流与窗口管理&quot;&gt;&lt;a href=&quot;#TCP-数据流与窗口管理&quot; class=&quot;headerlink&quot; title=&quot;TCP 数据流与窗口管理&quot;&gt;&lt;/a&gt;TCP 数据流与窗口管理&lt;/h2&gt;&lt;h3 id=&quot;交互式通信&quot;&gt;&lt;a href=&quot;#交互式通信&quot; c
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 超时重传</title>
    <link href="http://littlechao.top/2018/03/20/tcp_retransmission/"/>
    <id>http://littlechao.top/2018/03/20/tcp_retransmission/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-05-06T15:45:31.351Z</updated>
    
    <content type="html"><![CDATA[<p>##TCP超时重传</p><blockquote><p>TCP 提供可靠数据传输服务，为保证传输正确性，TCP 重传其认为已经丢失的包。TCP 有两套重传机制，一是基于定时器（超时），二是基于确认信息的构成（快速重传）。</p></blockquote><p>###基于计时器的重传</p><h4 id="简单的超时重传"><a href="#简单的超时重传" class="headerlink" title="简单的超时重传"></a>简单的超时重传</h4><p><img src="https://image.littlechao.top/20180315023638000003.jpg" alt=""></p><p>图中黑色那条就是因为定时器超时仍没有收到 ACK，所以引起了发送方超时重传。实际上 TCP 有两个阈值来决定如何重传同一个报文段：一是愿意重传的次数 R1、二是应该放弃当前连接的时机 R2。R1 和 R2 的值应分别至少为 3 次和 100 秒，如果超过任何一个但还没能重传成功，会放弃该连接。当然这两个值是可以设置的，在不同系统里默认值也不同。</p><p>那么如何设定一个合适的超时的值呢？假设 TCP 工作在静态环境中，这很容易，但真实网络环境不断变化，需要根据当前状态来设定合适的值。</p><h4 id="超时时间-RTO"><a href="#超时时间-RTO" class="headerlink" title="超时时间 RTO"></a>超时时间 RTO</h4><p>RTO（retransmission timeout）一般是根据RTT（round trip time）也就是往返时间来设置的。若 RTO 小于   RTT，则会造成很多不必要的重传；若 RTO 远大于 RTT，则会降低整体网络利用率，RTO 是保证 TCP 性能的关键。并且不同连接的RTT不相同，同一个连接不同时间的 RTT 也不相同，所以 RTO 的设置一直都是研究热点。</p><p>所以凭我们的直觉，RTO 应该比 RTT 稍大：</p><p>​                                    <strong>RTO=RTT+Δt</strong></p><p>那么，RTT 怎么算呢：</p><p>​                            <strong>SRTT=(1−α)×SRTT+α×RTTnew</strong></p><p>SRTT(smooth RTT)，RTTnew 是新测量的值。如上，为了防止 RTT 抖动太大，给了一个权值 <strong>a</strong> ，也叫平滑因子。a 的值建议在 10%~20%。举个例子，当前 RTTs=200ms，RTTs=200ms，最新一次测量的 RTT=800ms，RTT=800ms，那么更新后的 RTTs=200×0.875+800×0.125=275ms，RTTs=200×0.875+800×0.125=275ms.</p><p><strong>Δt</strong>如何得到呢？RFC 2988 规定：</p><p>​                                <strong>RTO=SRTT+4×RTTD</strong></p><p>因此，按照上面的定义，<strong>Δt=4×RTTD</strong>. 而 RTTD 计算公式如下：</p><p>​                            <strong>RTTD=(1−β)×RTTD+β×|SRTT−RTTnew|</strong></p><p>实际上，RTTD 就是一个均值偏差，它就相当于某个样本到其总体平均值的距离。这就好比你的成绩与你班级平均成绩差了多少。RFC 推荐 β=0.25。</p><h5 id="退避指数"><a href="#退避指数" class="headerlink" title="退避指数"></a>退避指数</h5><p>根据前面的公式，我们可以得到 RTO。一旦超过 RTO 还没收到 ACK，就会引起发送方重传。但如果重传后还是没有在 RTO 时间内收到 ACK，这时候会认为是网络拥堵，会引发 TCP 拥塞控制行为，使 RTO 翻倍。则第 n 次重传的 RTOn 值为：</p><p>​                                <strong>RTOn=2^(n−1)×RTO1</strong></p><p>下图是一个例子：</p><p><img src="http://img.blog.csdn.net/20170422182458581?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTEwMDc3Mjk5OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源：http://blog.csdn.net/q1007729991/article/details/70196099"></p><p>如上，在时间为0.22531时开始第一次重传，此后重传时间开始指数增大，（在尝试了8次后停下，说明其 R2 的值可能为8）。</p><h4 id="带时间戳的-RTT-测量"><a href="#带时间戳的-RTT-测量" class="headerlink" title="带时间戳的 RTT 测量"></a>带时间戳的 RTT 测量</h4><p>前面说了 RTO 的公式，它和 RTT 有关，那么每一次的 RTT 是如何得到的呢？在之前 TCP 连接管理的时候讲过，TCP有一个 TSOPT (timestamp option) 选项，它包含两个时间戳值。它允许发送者在报文中带上一个32比特的时间戳值（TSV），然后接收方 将收到的值原封不动的填入 ACK 报文段中 TSOPT 选项的第二部分，时间戳回显字段（TSER）。发送方收到 ACK 以后，将当前时间戳减去 TSOPT 选项的 TSER 就可得到精确的RTT值。</p><blockquote><p>但是这里有很微妙的细节：接收方在收到数据包后，并不是立即发送 ACK，通常会延时“一小会儿”，多等待几个数据包后返回一个累积 ACK。此时接收方将确认时间最近的报文段的 TSV 填入 TSER 发送给发送方。</p></blockquote><h5 id="重传二义性与-Karn-算法"><a href="#重传二义性与-Karn-算法" class="headerlink" title="重传二义性与 Karn 算法"></a>重传二义性与 Karn 算法</h5><p>还有另一个重要的细节，如果测量 RTT 的样本出现了超时重传，但是我们收到了 ACK 时无法分辨是对哪一次的确认，这时候 RTT 的值可能是不正确的。</p><p>因此，Karn 算法规定：<strong>此时不更新 RTTnew 的值</strong>。并且如果发生再次重传，则采用退避后的 RTO 的值，直到发送成功，退避指数重新设定为 1 。</p><h5 id="丢包和失序的情况"><a href="#丢包和失序的情况" class="headerlink" title="丢包和失序的情况"></a>丢包和失序的情况</h5><p>假设有三个数据包依次发送，1号和3号先到达，2号数据包由于网络因素最后到达。接收方收到3号时，会发送一个1号的冗余 ACK，然后2号到达，此时会发送一个3号的累积 ACK 表明这三个到达。在这个例子里，3号 ACK 并没有立即返回，发送方收到3号的 ACK 后，根据其 TSER 计算此时的 RTT，就会导致发送方过高的估计 RTT，降低重传积极性，使得 RTO 相应增大，当然这在失序时是有好处的，因为过分积极会导致大量的伪重传。</p><h4 id="伪超时与重传"><a href="#伪超时与重传" class="headerlink" title="伪超时与重传"></a>伪超时与重传</h4><p>如下图，在发送第四个 ACK 后出现延迟高峰，导致发送方在 RTO 时间内没有收到 5 ~ 8 的 ACK，于是发生重传，然后之前的 ACK 到达，于是又依次发送 6 ~ 8，就导致了不必要的重传。可以用 Eifel 算法来解决（略）。</p><p><img src="https://image.littlechao.top/20180315075511000005.jpg" style="height:400px"></p><h4 id="目的度量"><a href="#目的度量" class="headerlink" title="目的度量"></a>目的度量</h4><p>从前面可以看出，TCP 可以学习链路特征，如 RTT、SRTT 等，但一旦连接关闭，这些信息就会丢失。即使相同的接收方与发送方建立新的连接，也必须从头开始“学习”。较新的 TCP 实现维护了这些值，在 Linux 中可以通过如下命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route show cache [ip]</span><br></pre></td></tr></table></figure><p>###基于确认信息的重传</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>在大多数情况下，计时器超时并触发重传是不必要的，也不是期望的，因为 RTO 通常是大于 RTT（约2倍或更大），因此基于计时器的重传会导致网络利用率降低。</p><p>首先我们要知道，接收方收到失序报文段时，应立即生成确认信息（重复 ACK），以便发送方尽快、高效地填补空缺。而发送方在收到重复 ACK 时，无法判断是由于数据包丢失还是仅仅因为延迟，所以发送方等待一定数目的重复 ACK （重复 ACK 阈值，dupthresh），这时可以认为是数据包丢失，即便还未超时，也立即发送丢失的分组。</p><p>所以快速重传概括如下：TCP 发送方在观测到至少 dupthresh ( 通常是 3 ) 个重复 ACK，立即重传，而不必得到计时器超时。当然也可以同时发送新的数据。</p><p>示例如下：<img src="https://image.littlechao.top/20180315024222000004.jpg" alt=""></p><h4 id="包失序与包重复"><a href="#包失序与包重复" class="headerlink" title="包失序与包重复"></a>包失序与包重复</h4><h5 id="失序"><a href="#失序" class="headerlink" title="失序"></a>失序</h5><p>当然快速重传也会造成一些问题。在轻微失序的情况下(左图)，不会有什么影响。但在严重失序时(右图)，4号数据包延迟到达，接收方发送 4 个冗余 ACK ，让发送方认为 4 号分组丢失，造成伪快速重传。</p><p><img src="https://image.littlechao.top/20180315092324000007.jpg" alt=""></p><h5 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h5><p>尽管可能性较小，但 IP 协议也可能将单个包传输多次。假如 IP 协议将一个包传输了 4 次，然后发送方接收到 3 个冗余 ACK ，也会让发送方以为分组丢失，导致伪快速重传。</p><h4 id="带选择确认的重传"><a href="#带选择确认的重传" class="headerlink" title="带选择确认的重传"></a>带选择确认的重传</h4><p>在上一篇文章中提到过 TCP 的 SACK 选项，它通过若干个 SACK 块来帮助发送方知道接收方有哪些空缺，可以减少不必要的重传。</p><h5 id="接收端的-SACK-行为"><a href="#接收端的-SACK-行为" class="headerlink" title="接收端的 SACK 行为"></a>接收端的 SACK 行为</h5><p>接收端在 TCP 连接建立期间收到 SACK 选项即可生成 SACK。通常来说，当收到失序报文段，接收方就会生成 SACK。</p><p>第一个 SACK 块包含的应该是<strong>最近收到的</strong>报文段的序列号范围。由于 SACK 选项空间有限，应尽可能向发送方提供最新信息。其余的 SACK 按先后顺序依次排列，也就是说，该 ACK 报文段除了包含最新接收的序列号信息，还应重复之前的 SACK 信息。这是因为 ACK 报文段是没有重发机制的，可能会丢失，重复提高了其鲁棒性。</p><h5 id="发送端的-SACK-行为"><a href="#发送端的-SACK-行为" class="headerlink" title="发送端的 SACK 行为"></a>发送端的 SACK 行为</h5><p>发送方应该充分利用 SACK 信息来进行重传，称为<strong>选择性重传</strong>。发送方记录累积 ACK 信息和 SACK 信息，当接收到相应序列号范围内的 ACK 时，在其重传缓存中标记该报文段重传成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##TCP超时重传&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 提供可靠数据传输服务，为保证传输正确性，TCP 重传其认为已经丢失的包。TCP 有两套重传机制，一是基于定时器（超时），二是基于确认信息的构成（快速重传）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Node 异步 I/O</title>
    <link href="http://littlechao.top/2018/03/17/node_async_io/"/>
    <id>http://littlechao.top/2018/03/17/node_async_io/</id>
    <published>2018-03-16T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.340Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要讲 nodejs 中的异步 IO，关于同步、异步、阻塞、非阻塞 请移步<a href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/" target="_blank" rel="noopener">这里</a>。</p><h3 id="事件循环-和-消息队列"><a href="#事件循环-和-消息队列" class="headerlink" title="事件循环 和 消息队列"></a>事件循环 和 消息队列</h3><p>我们常说“JavaScript是单线程的”。</p><p>所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。</p><p>但是实际上还存在其他的线程。例如：处理AJAX请求的线程、定时器线程、读写文件的线程等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。</p><p><img src="/images/async/async_pic.png" alt=""></p><h4 id="node-执行过程"><a href="#node-执行过程" class="headerlink" title="node 执行过程"></a>node 执行过程</h4><p><img src="/images/async/node_event.png" alt=""></p><p>处理并执行完 js 代码，main函数继续往下调用libuv的事件循环入口uv_run()，node进程进入事件循环。 <code>uv_run()</code> 的 while 循环做的就是一件事，判断 <code>default_loop_struct</code> 是否有存活的 io 观察者 或 定时器。</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><blockquote><p>事件循环是指主线程重复从消息队列中取消息、执行的过程</p></blockquote><p>事件循环对应上图 3 号标注的部分。用代码表示大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = queue.get();</span><br><span class="line">    execute(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/async/event_loop.png" alt=""></p><p>如上图，每一次执行一次循环体的过程称为 Tick。</p><p><strong>事件循环的阶段：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │ 执行定时器(setTimeout/setInterval)注册的回调函数，也是进入事</span><br><span class="line">│  └──────────┬────────────┘ 件循环第一个阶段。</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │ I/O 事件相关联的回调或者报错会在这里执行</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │ 内部使用，不讨论</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │ 最重要的一个阶段，I/O 观察者观察到线程池</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │里有任务已经完成，就会在这里执行回调。</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │ 专门用来执行 setImmediate() 的回调</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │ 一个连接或 handle 突然被关闭，close 事件会被发送到这里执行回调</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p>如上图，共有六个阶段（官方称为 phase）。特别要说明的是 poll 阶段，在这个阶段，如果暂时没有事件到来，主线程便会阻塞在这里，等待事件发生。当然它不会一直等下去：</p><ul><li>它首先会判断后面的 Check Phase 以及 Close Phase 是否还有等待处理的回调. 如果有, 则不等待, 直接进入下一个 Phase. </li><li>如果没有其他回调等待执行, 它会给 epoll 这样的方法设置一个 timeout. 可以猜一下, 这个 timeout 设置为多少合适呢? 答案就是 Timer Phase 中最近要执行的回调启动时间到现在的差值, 假设这个差值是 delta. 因为 Poll Phase 后面没有等待执行的回调了. 所以这里最多等待 delta 时长, 如果期间有事件唤醒了消息循环, 那么就继续下一个 Phase 的工作; 如果期间什么都没发生, 那么到了 timeout 后, 消息循环依然要进入后面的Phase, 让下一个迭代的 Timer Phase 也能够得到执行.</li></ul><p>来看一下流程：</p><p><img src="/images/async/phases.png" alt=""></p><p>到这里你一定发现少了一些问题：process.nextTick() 和 Promise 都是异步的，它们对应以上哪个阶段呢？往下看 </p><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、运行主线程（函数调用栈）中的同步任务</span><br><span class="line">2、主线程（函数调用栈）执行到任务源时，通知相应的webAPIs进行相应的执行异步任务，将任务源指定的异步任务放入任务队列中</span><br><span class="line">3、主线程（函数调用栈）中的任务执行完毕后，然后执行所有的微任务，再执行宏任务，找到一个任务队列执行完毕，再执行所有的微任务</span><br><span class="line">4、不断执行第三步</span><br></pre></td></tr></table></figure><blockquote><p> 任务队列也叫消息队列。主要分两类任务：宏任务(macro-task)、微任务(micro-task)</p></blockquote><p>宏任务：setTimeout    setInterval    setImmediate    I/O</p><p>微任务：process.nextTick    Promise 的回调</p><p>在上面的图中，各个 phase 完成了宏任务对应的事件。微任务的执行时机在<strong>每一次进入下一个阶段之前</strong>，process.nextTick    优先级大于 Promise 的回调。</p><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><h5 id="setTimeout-和-setImmediate-的比较"><a href="#setTimeout-和-setImmediate-的比较" class="headerlink" title="setTimeout 和 setImmediate 的比较"></a>setTimeout 和 setImmediate 的比较</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这段代码的结果实际上是不确定的。可是，为什么？按照流程图，应该是 timer 先于 check 阶段，所以应该是 setTimeout 先执行，可是为什么结果不是这样呢？首先我们要知道：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(fn) ==&gt; setTimeout(fn, <span class="number">0</span>) ==&gt; setTimeout(fn, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>上面三个效果是一样的！前两个好理解，给定的默认值是0。其实在 node 源码中，最低为 1 ms，官方文档如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When delay is larger than 2147483647 or less than 1, the delay will be set to 1.</span><br></pre></td></tr></table></figure><p>所以当进入 timer 阶段时，1ms 可能超时也可能没有，这个影响因素有很多。如果还没超时，则进入下一个 phase，依次往下，所以先输出 2 。如果已经超时，则先输出 1。</p><blockquote><p>但是！如果它们在 I/O 事件回调中，那么输出顺序是固定了的，如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'fs'</span>).readFile(<span class="string">'path.txt'</span>, () =&gt; &#123;</span><br><span class="line"> setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line"> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出: 2 1</span></span><br></pre></td></tr></table></figure><p>如果不知道为什么，答案就在循环图中。</p><p>(完)</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">The Node.js Event Loop, Timers, and <code>process.nextTick()</code></a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要讲 nodejs 中的异步 IO，关于同步、异步、阻塞、非阻塞 请移步&lt;a href=&quot;https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlechao.top/tags/JavaScript/"/>
    
      <category term="node" scheme="http://littlechao.top/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>TCP 连接管理</title>
    <link href="http://littlechao.top/2018/03/17/TCPConn/"/>
    <id>http://littlechao.top/2018/03/17/TCPConn/</id>
    <published>2018-03-16T16:00:00.000Z</published>
    <updated>2018-05-06T15:46:39.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP-连接的建立和终止"><a href="#TCP-连接的建立和终止" class="headerlink" title="TCP 连接的建立和终止"></a>TCP 连接的建立和终止</h3><p>一个TCP连接由一个四元组构成：源IP、源端口、目的IP、目的端口。一个连接通常分为三个阶段：启动、数据传输（也称“连接已建立”）、关闭。以下是建立连接是三步握手和关闭时四步挥手的过程。</p><p><img src="https://notes.shichao.io/tcpv1/figure_13-1.png" alt=""></p><h6 id="握手："><a href="#握手：" class="headerlink" title="握手："></a>握手：</h6><ul><li>客户端先发一个SYN（synchronous）报文段，并指明客户端的初始序列号（Initial Sequence Number），图中值为ISN(c)。（注意这里可能出现超时或报文丢失的情况）</li><li>服务端收到后返回一个ACK（acknowledgement）,并指明ACK确认号的值为ISN(c) + 1来表明已经收到Seq值为ISN(c)的SYN报文段。服务端在同一个报文段还发送了一个SYN并指明自己的初始序列号ISN(s).</li><li>客户端收到ACK+SYN，发送ACK向服务端确认收到来自服务端的SYN，并指明Seq=ISN(s) + 1.</li></ul><blockquote><p>重要的细节：对于client来说，第三步似乎是多余的，但是对服务端来说，是一个防止SYN泛洪攻击的手段：服务端在建立连接后需要为该连接分配变量和内存，如果没有第三步，恶意客户端通过不停伪造IP和端口发起SYN（客户端没有太大内存消耗），导致服务端不停分配变量，最后内存消耗完崩溃。所以第三步可以让服务端辨别恶意客户端。</p></blockquote><p>######挥手：</p><ul><li>关闭发起者（TCP连接是双向的，任何一方都可以主动断开连接）向另一方发送一个FIN（final）段表示要开始关闭连接。此时的ACK值是确认最近一次发来的数据。</li><li>被动方接收FIN，发回一个ACK。</li><li>被动方向发起方发送一个FIN，同时再次确认之前的FIN，ACK和上次相同。</li><li>发起方收到FIN，发回ACK</li></ul><p>挥手断开这里同样有很多重要细节：</p><ul><li>前两步完成后，发起方到被动方的连接已经关闭，但TCP是双向的，此时由于被动方还没有发送FIN，所以被动方到发起方的连接还打开着，TCP连接目前处于<strong>半关闭</strong>状态，此时被动方仍然可以向发起方发送数据，发起方也可以正常接受数据。但是如果被动方既不再发送数据，也不发送最后的FIN，就会出现问题。所以发起方收到FIN的ACK时，设置了一个定时器，在规定时间内没有数据发过来，就自动断开连接。</li><li>另一个问题是，如果发起方发送了最后一个ACK用于确认被动方的FIN之后立刻关闭，但是此ACK超时未达或者丢失了，就会造成问题—被动方的FIN得不到确认。这时被动方会在超时后重新发送FIN，直到收到ACK为止。所以发起方发送完最后一个ACK后不能马上离开，而要等一段时间，用于确保对方收到ACK，这段时间叫<strong>静默时间</strong>，并且这个时间是强制的。静默时间大小一般为2*MSL（Max Segment Lifetime,报文段在被丢弃前允许的最长存活时间）所以它还有另一个重要的作用，就是让属于这个已经关闭连接的报文段过期，以免相同的客户端和服务端再次建立连接时受到之前已经关闭连接的影响。</li></ul><h3 id="TCP-FSM"><a href="#TCP-FSM" class="headerlink" title="TCP FSM"></a>TCP FSM</h3><p>以下是TCP三步握手和四步挥手的有限状态机。应该掌握。</p><p><img src="https://image.littlechao.top/20180313081609000002.jpg" alt=""></p><h3 id="TCP-选项"><a href="#TCP-选项" class="headerlink" title="TCP 选项"></a>TCP 选项</h3><p>TCP有若干选项，每个选项的头一个字节表示“种类”，指明了选项的类型。</p><h5 id="MSS-最大段大小选项"><a href="#MSS-最大段大小选项" class="headerlink" title="MSS 最大段大小选项"></a>MSS 最大段大小选项</h5><p>Max segment size。当一条TCP连接建立时，通信双方都要在SYN报文段的MSS选项说明自己允许的最大段大小。注意最大段大小不是双方协商的结果，而是表明自己不愿意接收任何大于该尺寸的报文段。</p><h5 id="SACK-选择确认段"><a href="#SACK-选择确认段" class="headerlink" title="SACK 选择确认段"></a>SACK 选择确认段</h5><p>Select ACK。在滑动窗口中，TCP采用累计ACK确认，不能正确的确认已经收到的但是是失序的报文段，接收方的数据队列就会出现空洞。SACK能够使发送方了解到空洞出现并进行更有效的重传工作。通过接收SYN报文段中的“允许确认选项”，TCP通信方会知道自身拥有了发布SACK的能力。SACK选项由n个SACK块构成，每个SACK块是一对32位的序列号（a，b），表明已经接受a到b的数据。</p><h5 id="WSOPT"><a href="#WSOPT" class="headerlink" title="WSOPT"></a>WSOPT</h5><p>Window scale option。窗口本来大小只有16位，若wsopt值为s，则窗口大小为16*2^s,最大值为1G</p><p>#####TSOPT</p><p>timestamp option。发送方发出的报文段带有发出时的时间戳，接收方收到后将该值写入ACK报文段发回给发送方。发送方据此可以精确地计算RTT（round trip time）。同时该选项还可用于防回绕：假如存在一个过期了的报文段恰好和下一次要接受的报文段序列号相同，这时候可以通过时间戳来判断，如果该报文时间戳小于最近一次收到的报文段，说明改报文段是过期了的。</p><h3 id="TCP服务器选项"><a href="#TCP服务器选项" class="headerlink" title="TCP服务器选项"></a>TCP服务器选项</h3><p>TCP服务端会为每一个客户端分配一个新的进程或线程，这样负责监听的服务器就能始终准备着处理下一个到来的连接请求。但是如果服务器正在创建一个新进程（线程）时有更多的连接到来，应该如何处理？</p><p>在被用于应用程序之前，新的连接可能会有两种状态：1、SYN_RCVD 状态         2、    ESTABLISHED 状态 但未被应用程序所接受。</p><p>TCP为这两种状态的连接准备了两个队列，可以通过限制它们的大小来管理连接。</p><ul><li>当一个SYN报文段到达，将会检查SYN_RCVD队列是否已满（Linux中默认为1000），未满则加入队列，否则拒绝连接。</li><li>ESTABLISHED状态的队列通常被称为<strong>未完成连接</strong>（backlog，虽然叫未完成，但是三次握手已经完成，只是还没被应用程序处理），backlog队列最大长度默认为128</li><li>如果backlog队列未满，则会根据SYN_RCVD队列应答SYN并完成握手，握手完成后，加入backlog队列，由负责监听的服务器依次分配线程。注意当客户端发送ACK后，会认为服务端已经做好接收数据的准备来，所以会立即发送数据，但此时连接可能还处于backlog队列，还未被应用程序处理，所以TCP还有一个专门的数据队列。</li><li>如果backlog已满，则会延迟应答SYN。正常的TCP机制里，客户端会等待SYN超时，但在Linux客户端中，既不超时也不重置。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP-连接的建立和终止&quot;&gt;&lt;a href=&quot;#TCP-连接的建立和终止&quot; class=&quot;headerlink&quot; title=&quot;TCP 连接的建立和终止&quot;&gt;&lt;/a&gt;TCP 连接的建立和终止&lt;/h3&gt;&lt;p&gt;一个TCP连接由一个四元组构成：源IP、源端口、目的IP、目
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>node 模块机制</title>
    <link href="http://littlechao.top/2018/03/14/node_commonJS/"/>
    <id>http://littlechao.top/2018/03/14/node_commonJS/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node-模块机制"><a href="#node-模块机制" class="headerlink" title="node 模块机制"></a>node 模块机制</h1><h3 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h3><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br></pre></td></tr></table></figure><p>在 CommonJS 规范中，require 接受一个模块标志，以此引入模块的 API。</p><p>模块提供了 exports 对象来导出方法或变量，另外还有一个 module 对象，该对象即模块本身，而在 nodejs 中，文件就是模块。在 module 对象上有一个 module.exports 属性，这是其导出的内容，变量 exports 指向的地址就是 module.exports。也就是说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports === exports</span><br></pre></td></tr></table></figure><p>这里注意，可以在 exports 上添加属性或方法来导出，但不可修改 exports 本身的值，因为改了以后，exports 不在指向 module.exports, 也就不会被导出。如果想要导出一个类，可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = &#123;&#125;</span><br><span class="line">A.prototype.foo = foo;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = A;</span><br></pre></td></tr></table></figure><h3 id="node-模块实现"><a href="#node-模块实现" class="headerlink" title="node 模块实现"></a>node 模块实现</h3><blockquote><p>node 会将加载过的模块放入缓存，下次引用直接从缓存加载。</p></blockquote><h4 id="路径分析-和-文件定位"><a href="#路径分析-和-文件定位" class="headerlink" title="路径分析 和 文件定位"></a>路径分析 和 文件定位</h4><ul><li>核心模块，如 fs 、path、http 等，直接引用模块名。node 启动时就已经加载到内存，加载速度最快</li><li>“.” 或”..”开头，相对路径查找，知道路径，查找快，但仍需动态加载，速度稍慢</li><li>“/“开头，从根目录查找，同上</li><li>自定义模块，根据 <code>module.paths</code> 变量递归向上查找 node_modules 目录</li></ul><h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><blockquote><p>require 查找模块时，需要 fs 模块同步阻塞的判断是否存在。</p></blockquote><p>require 时一般不需要指定文件后缀名，但也可以加上。如果没有后缀，node 会依次在对应路径查找 <code>.js</code>、<code>.json</code>、<code>.node</code>。如果是后两种，加上后缀名查找会稍快。</p><p>很可能最后找不到对应的<code>.js</code>、<code>.json</code>、<code>.node</code>文件，但找到的是一个目录。则会查看该目录<code>package.json</code>下main 项对应的值。示例如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"webpack.config.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>于是找到了 webpack.config.js 文件。如果没有 main 项或者不存在 package.json，则会依次查找 index.js , index.json, index.node。如果仍然没有，就按照 module.path 数组依次递归向上查找。最终找不到，则抛出异常。</p><h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>node 中模块定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span>(parent &amp;&amp; parent.children)&#123;</span><br><span class="line">    parent.children.push(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.filename = <span class="literal">null</span>;<span class="comment">//定义时还不能确定该值</span></span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位到具体文件后，对不同类型的文件操作不一样：</p><ul><li>.js 文件，通过 fs 模块同步读取后编译执行</li><li>.node 文件，这是 c/c++ 写的扩展文件</li><li>.json 文件，读取后通过 JSON.parse() 解析并返回结果</li></ul><p>每一个编译后的模块都被缓存起来。</p><h5 id="javaScript-模块的编译"><a href="#javaScript-模块的编译" class="headerlink" title="javaScript 模块的编译"></a>javaScript 模块的编译</h5><p>我们前面知道有 require 方法和 exports 对象，可是这些变量和方法在哪里声明的呢？实际上，node 对读取到的 js 文件做了包装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// module content</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>node 读取 js 文件后执行的就是这个包装函数，然后得到 module.exports 。</p><p>(待续)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;node-模块机制&quot;&gt;&lt;a href=&quot;#node-模块机制&quot; class=&quot;headerlink&quot; title=&quot;node 模块机制&quot;&gt;&lt;/a&gt;node 模块机制&lt;/h1&gt;&lt;h3 id=&quot;模块引用&quot;&gt;&lt;a href=&quot;#模块引用&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlechao.top/tags/JavaScript/"/>
    
      <category term="node" scheme="http://littlechao.top/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>golang unsafe 包</title>
    <link href="http://littlechao.top/2018/03/04/Go%20unsafe%20%E5%8C%85/"/>
    <id>http://littlechao.top/2018/03/04/Go unsafe 包/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-04-20T08:35:41.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="golang-unsafe-包"><a href="#golang-unsafe-包" class="headerlink" title="golang unsafe 包"></a>golang unsafe 包</h2><h4 id="ArbitraryType-和-Pointer"><a href="#ArbitraryType-和-Pointer" class="headerlink" title="ArbitraryType 和 Pointer"></a>ArbitraryType 和 Pointer</h4><p>Go 语言是强类型语言，并且出于安全的考虑，它不允许不同类型的指针互相转换，比如<code>*int</code>不能转为<code>*float64</code>。但是它提供了 unsafe 包来做转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure><p>从命名可以看出，ArbitraryType 代表了任意类型，其实，ArbitraryType不是一个真正的类型，它只是一个占位符。而 Pointer 是其指针，并且是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于 C 语言里的<code>void*</code> 指针，全能型的。</p><p>ArbitraryType 上有三个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span>（<span class="title">variable</span> <span class="title">ArbitraryType</span>）<span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Offsetof</span>（<span class="title">selector</span> <span class="title">ArbitraryType</span>）<span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Sizeof</span>（<span class="title">variable</span> <span class="title">ArbitraryType</span>）<span class="title">uintptr</span></span></span><br></pre></td></tr></table></figure><p>与Golang中的大多数函数不同，上述三个函数的调用将始终在编译时求值，而不是运行时。 这意味着它们的返回结果可以分配给常量。（BTW，unsafe包中的函数中非唯一调用将在编译时求值。当传递给len和cap的参数是一个数组值时，内置函数和cap函数的调用也可以在编译时被求值。）</p><h4 id="uintptr"><a href="#uintptr" class="headerlink" title="uintptr"></a>uintptr</h4><p><code>uintptr</code> 不是 <code>unsafe</code> 包的一部分，但是它总是和 <code>unsafe</code> 一起用。<code>uintptr</code> 是底层内置类型，用于表示指针的值，区别在于<code>go</code> 语言中指针不可以参与计算，而 <code>uintptr</code> 可以。另外，指针和 uintptr 也是不可以直接转换的。</p><p>特别需要注意的是，GC 不会把 uintptr 当成指针，所以由 uintptr 变量表示的地址处的数据也可能被GC回收。</p><h3 id="用法及注意事项"><a href="#用法及注意事项" class="headerlink" title="用法及注意事项"></a>用法及注意事项</h3><h4 id="转换不同类型的指针"><a href="#转换不同类型的指针" class="headerlink" title="转换不同类型的指针"></a>转换不同类型的指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Float64bits(f float64) uint64 &#123;</span><br><span class="line">    return *(*uint64)(unsafe.Pointer(&amp;f))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="把指针转换成-uintptr"><a href="#把指针转换成-uintptr" class="headerlink" title="把指针转换成 uintptr"></a>把指针转换成 uintptr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Converting a Pointer to a uintptr creates an integer value with no pointer semantics</span><br><span class="line">//上面说过的，uintptr 没有指针的含义</span><br></pre></td></tr></table></figure><p>如下转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">pa := &amp;a</span><br><span class="line">up := <span class="keyword">uintptr</span>(unsafe.Pointer(pa))</span><br><span class="line">pa = &amp;<span class="keyword">int64</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>当 pa 地址改变，uintptr 是不会更新的。且当只有 up 包含了变量 a 的地址，但是 GC 不会把 up 当做指针，所以GC 会回收变量 a 。</p><h4 id="uintptr-转指针"><a href="#uintptr-转指针" class="headerlink" title="uintptr 转指针"></a>uintptr 转指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := &amp;T&#123;&#125;</span><br><span class="line">p = unsafe.Pointer(<span class="keyword">uintptr</span>(p) + offset)</span><br></pre></td></tr></table></figure><p>这里的 offset 得当的话，可以取到 T 类型中没有导出的值，这也是一个巧妙的用法，但是不推荐。注意这里不能写成这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p := &amp;T&#123;&#125;<span class="comment">// 1</span></span><br><span class="line">up := <span class="keyword">uintptr</span>(p)<span class="comment">// 2</span></span><br><span class="line">p = unsafe.Pointer(up + offset)<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这样非常危险，因为有可能在 3 执行之前，up 这个临时变量被 GC ，最终操作的不知道是哪个内存了。因此不能将 uintptr(p) 保存在变量中。</p><p>另外，在 C语言 中我们可以将 offset 设成 T 的长度，然后直接对得到的地址进行操作。但是在 go 语言中是不合法的，可以读取，但不应该操作分配给 T 内存之外的部分，会引发 panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure><h4 id="系统调用时转换指针"><a href="#系统调用时转换指针" class="headerlink" title="系统调用时转换指针"></a>系统调用时转换指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Syscall(SYS_READ, <span class="keyword">uintptr</span>(fd), <span class="keyword">uintptr</span>(unsafe.Pointer(p)), <span class="keyword">uintptr</span>(n))</span><br></pre></td></tr></table></figure><p>如上，当系统调用需要一个 uintptr 作为参数，也一定把 uintptr(..) 放在系统调用表达式的参数里，以防止被 GC。在系统调用过程中，不必担心 uintptr 失效，它所持有的对象不会被 GC 。</p><h4 id="reflect-Value-Pointer"><a href="#reflect-Value-Pointer" class="headerlink" title="reflect.Value.Pointer"></a>reflect.Value.Pointer</h4><p>在一些函数的返回值中，也可能出现 uintptr，比如 <code>reflect.Value.Pointer</code>和<code>reflect.Value.UnsafeAddr</code>,对其转换成指针的时候也要注意，不能有中间变量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p := (*<span class="keyword">int</span>)(unsafe.Pointer(reflect.ValueOf(<span class="built_in">new</span>(<span class="keyword">int</span>)).Pointer()))</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As in the cases above, it is invalid to store the result before the conversion:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">//  before conversion back to Pointer.</span></span><br><span class="line"><span class="comment">//u := reflect.ValueOf(new(int)).Pointer()</span></span><br><span class="line"><span class="comment">//p := (*int)(unsafe.Pointer(u))</span></span><br></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li>unsafe包用于Go编译器，而不是Go运行时。</li><li>使用unsafe作为程序包名称只是让你在使用此包是更加小心。</li><li>使用unsafe.Pointer并不总是一个坏主意，有时我们必须使用它。</li><li>Golang的类型系统是为了安全和效率而设计的。 但是在Go类型系统中，安全性比效率更重要。 通常Go是高效的，但有时安全真的会导致Go程序效率低下。 unsafe包用于有经验的程序员通过安全地绕过Go类型系统的安全性来消除这些低效。</li><li>unsafe包可能被滥用并且是危险的</li><li>涉及到 uintptr 转指针时，一定注意不能有中间变量</li></ul><hr><h4 id="续-question"><a href="#续-question" class="headerlink" title="(续)question"></a>(续)question</h4><p>在关于操作不可知内存的时候，会有一些莫名其妙的现象，如下代码是 gocn 上一篇<a href="https://gocn.io/question/371" target="_blank" rel="noopener">文章</a>里的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">illegalUseB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">illegalUseB</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">p := unsafe.Pointer(&amp;a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">*(*<span class="keyword">int</span>)(p) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(i, <span class="string">":"</span>, *(*<span class="keyword">int</span>)(p))</span><br><span class="line"><span class="comment">// panic at the above line for the last iteration, when i==4.</span></span><br><span class="line"><span class="comment">// runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line">p = unsafe.Pointer(<span class="keyword">uintptr</span>(p) + <span class="number">8</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码，报错如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> : <span class="number">1</span></span><br><span class="line"><span class="number">1</span> : <span class="number">1</span></span><br><span class="line"><span class="number">2</span> : <span class="number">1</span></span><br><span class="line"><span class="number">3</span> : <span class="number">1</span></span><br><span class="line"><span class="built_in">panic</span>: runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=<span class="number">0x1</span> addr=<span class="number">0x1</span> pc=<span class="number">0x100ca32</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是比较诡异的情况如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">illegalUseB</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">p := unsafe.Pointer(&amp;a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">fmt.Println(i, <span class="string">":"</span>, *(*<span class="keyword">int</span>)(p))</span><br><span class="line"><span class="comment">// panic at the above line for the last iteration, when i==4.</span></span><br><span class="line"><span class="comment">// runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line">p = unsafe.Pointer(<span class="keyword">uintptr</span>(p) + <span class="number">8</span>)</span><br><span class="line">        *(*<span class="keyword">int</span>)(p) = <span class="number">1</span><span class="comment">// 调整了位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">illegalUseB</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">a := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">p := unsafe.Pointer(&amp;a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">*(*<span class="keyword">int</span>)(p) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(i, <span class="string">":"</span>, *(*<span class="keyword">int</span>)(p), (*<span class="keyword">int</span>)(p))<span class="comment">// 多输出了一个值</span></span><br><span class="line"><span class="comment">// panic at the above line for the last iteration, when i==4.</span></span><br><span class="line"><span class="comment">// runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line">p = unsafe.Pointer(<span class="keyword">uintptr</span>(p) + <span class="number">8</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种情况都不会报错。按理说都是操作了声明变量以外的内存，但是没有向之前一样报错，不知道是什么原因。我的 go SDK 版本是 1.9.1，如果你知道的话麻烦告诉我，谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;golang-unsafe-包&quot;&gt;&lt;a href=&quot;#golang-unsafe-包&quot; class=&quot;headerlink&quot; title=&quot;golang unsafe 包&quot;&gt;&lt;/a&gt;golang unsafe 包&lt;/h2&gt;&lt;h4 id=&quot;ArbitraryType
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go http/server.go</title>
    <link href="http://littlechao.top/2018/03/04/Go%20net:http:serve.go%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://littlechao.top/2018/03/04/Go net:http:serve.go 阅读笔记/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.330Z</updated>
    
    <content type="html"><![CDATA[<p>先从一个简单的例子开始吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启web服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"ListenAndServer:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Hello Guest!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，此时浏览器访问<code>localhost:9090</code>就会看到输出“Hello Guest!”，其实访问<code>localhost:9090/</code>+任意字符串，都能得到结果。这段代码先用<code>http.HandleFunc</code>注册了一个处理函数，然后调用<code>http.ListenAndServe</code>监听端口，当有请求到来时，会根据访问路径找到并执行对应的处理函数。</p><p>我们通常还能看到另一种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启web服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.Handle(<span class="string">"/"</span>, &amp;handler&#123;&#125;)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"ListenAndServer:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">sayHello(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码效果一样。区别就是<code>http.HandleFunc</code>和<code>http.Handle</code>需要的第二个参数，前者要一个<code>func (w http.ResponseWriter, r *http.Request)</code>函数，后者要一个实现了该函数的结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123; DefaultServeMux.Handle(pattern, handler) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，两个函数都会调用<code>mux.handle</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span></span><br></pre></td></tr></table></figure><p>第二个参数是Handler，是一个接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回到上面的<code>HandleFunc</code>,注意这个：<code>HandlerFunc(handler)</code>,这里很容易让人误以为HandlerFunc是一个函数并且包装了传入的handler，再返回一个<code>Handler</code>类型。而实际上这里是<strong>类型转换</strong>，来看HandlerFunc的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ServeHTTP</span> <span class="title">calls</span> <span class="title">f</span><span class="params">(w, r)</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>HandlerFunc</code>的类型是一个函数，但它是一种类型，因为是以<code>type</code>来定义而不是<code>func</code>，并且实现了<code>ServeHTTP(w ResponseWriter, r *Request)</code>，在这个函数里，它又调用了自身。这个细节是十分重要的，因为这一步关乎到当路由规则匹配时，相应的响应方法是否会被调用的问题！这里的类型转换用法使一个函数自身实现了一个接口，就不用每次都要先写一个本身无用结构体，再用结构体实现接口。请仔细体会这种技巧！</p><p>接着看<code>mux.Handle</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">mux.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: invalid pattern "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mux.m[pattern].explicit &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">&#125;</span><br><span class="line">mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">mux.hosts = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下是很有用的功能:当pattern == “/tree/”时,</span></span><br><span class="line">  <span class="comment">// 会插入一条永久的重定向到“/tree”,注意最后的斜杠。</span></span><br><span class="line">  <span class="comment">// 当然前提是在这之前没有“/tree”这条路由</span></span><br><span class="line">n := <span class="built_in">len</span>(pattern)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; pattern[n<span class="number">-1</span>] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]].explicit &#123;</span><br><span class="line"><span class="comment">//如果包含host，</span></span><br><span class="line">path := pattern</span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line"><span class="comment">// In pattern, at least the last character is a '/', so</span></span><br><span class="line"><span class="comment">// strings.Index can't be -1.</span></span><br><span class="line">path = pattern[strings.Index(pattern, <span class="string">"/"</span>):]</span><br><span class="line">&#125;</span><br><span class="line">url := &amp;url.URL&#123;Path: path&#125;</span><br><span class="line">mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码挺多，其实主要就做了一件事，向<code>DefaultServeMux</code>的<code>map[string]muxEntry</code>中增加对应的路由规则和<code>handler</code>。那什么是<code>DefaultServeMux</code>的<code>muxEntry</code>?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">mu    sync.RWMutex</span><br><span class="line">m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">  <span class="comment">//路由规则，一个string对应一个mux实例对象，map的key就是注册的路由表达式(string类型的)</span></span><br><span class="line">hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123; <span class="comment">// 代表着一个 路由-处理函数 组合</span></span><br><span class="line">explicit <span class="keyword">bool</span> <span class="comment">//表示patern是否是明确清晰的</span></span><br><span class="line">h        Handler</span><br><span class="line">pattern  <span class="keyword">string</span> <span class="comment">//路由表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先从一个简单的例子开始吧：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go net/dial.go (II)</title>
    <link href="http://littlechao.top/2018/03/02/Go%20net:dial.go%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://littlechao.top/2018/03/02/Go net:dial.go 阅读笔记(二)/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.321Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.littlechao.top/#/index/article?_id=5a9823ceebc087002a3e7259" target="_blank" rel="noopener">上一篇文章</a> 我们大致分析了dial.go中的代码，起主要的功能就是为真正发起连接做一些准备，起到了应用层的作用（DNS解析等）。但是一个连接完整的连接还需要更深层次的网络协议来完成协作，所以我们接着上篇来分析，由于篇(懒)幅原因，只将<code>dialTcp</code>作为传输层的例子。。。话不多说，上代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialTCP</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, laddr, raddr *TCPAddr)</span> <span class="params">(*TCPConn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> testHookDialTCP != <span class="literal">nil</span> &#123; <span class="comment">//testHookDialTCP 是语言开发者为了测试留的钩子函数，不用管</span></span><br><span class="line"><span class="keyword">return</span> testHookDialTCP(ctx, net, laddr, raddr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> doDialTCP(ctx, net, laddr, raddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意现在所在文件是在<code>tcpsock_posix.go</code> 这部分是<strong>传输层</strong>的内容了。</p></blockquote><p>来看<code>doDialTCP</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doDialTCP</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, laddr, raddr *TCPAddr)</span> <span class="params">(*TCPConn, error)</span></span> &#123;</span><br><span class="line">fd, err := internetSocket(ctx, net, laddr, raddr, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">"dial"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; (laddr == <span class="literal">nil</span> || laddr.Port == <span class="number">0</span>) &amp;&amp; (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line">&#125;</span><br><span class="line">fd, err = internetSocket(ctx, net, laddr, raddr, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">"dial"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTCPConn(fd), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数里的ctx自然不言而喻了，是为了控制请求超时取消请求释放资源的；<code>laddr</code>是 local address ， <code>raddr</code>是指 remote address；返回值这里会得到 <code>TCPConn</code>。代码不长，就是调用了 <code>internetSocket</code>得到一个文件描述符，并用其新建一个conn返回。但这里我想多说几句，因为不难发现， <code>internetSocket</code>可能会被调用多次，为什么呢？</p><p>首先我们需要知道 Tcp 有一个极少使用的机制，叫<code>simultaneous connection</code>（同时连接）。正常的连接是：A主机 dial B主机，B主机 listen。 而同时连接则是： A 向 B dial 同时 B 向 A dial，那么 A 和 B 都不需要监听。</p><p>我们知道，当 传入 dial  函数的参数<code>laddr</code>==<code>raddr</code>时，内核会拒绝dial。但如果传入的<code>laddr</code>为nil，kernel 会自动选择一个本机端口，这时候有可能会使得新的<code>laddr</code>==<code>raddr</code>,这个时候，kernel不会拒绝dial，并且这个dial会成功，原因是就<code>simultaneous connection</code>，这可能是kernel的bug。所以会判断是否是 <code>selfConnect</code>或者<code>spuriousENOTAVAIL</code>(spurious error not avail)来判断上一次调用<code>internetSocket</code>返回的 err 类型，在特定的情况下重新尝试<code>internetSocket</code>.关于这个问题的讨论参见<a href="https://stackoverflow.com/questions/4949858/how-can-you-have-a-tcp-connection-back-to-the-same-port" target="_blank" rel="noopener">这里</a>。</p><p>好了，我们接下来看看<code>internetSocket</code>，该函数在<code>ipsock_posix.go</code>文件，到了<strong>网络层</strong>的范围了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internetSocket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, laddr, raddr sockaddr, sotype, proto <span class="keyword">int</span>, mode <span class="keyword">string</span>)</span> <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (runtime.GOOS == <span class="string">"windows"</span> || runtime.GOOS == <span class="string">"openbsd"</span> || runtime.GOOS == <span class="string">"nacl"</span>) &amp;&amp; mode == <span class="string">"dial"</span> &amp;&amp; raddr.isWildcard() &#123;</span><br><span class="line">raddr = raddr.toLocal(net) </span><br><span class="line">      <span class="comment">// 如果 raddr 是零地址，把它转化成当前系统对应的零地址格式(local system address 127.0.0.1 or ::1)</span></span><br><span class="line">&#125;</span><br><span class="line">family, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode)</span><br><span class="line"><span class="keyword">return</span> socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（sotype 和 proto 是生成 socket 文件d的系统调用时用的）首先判断了运行系统的类型，<code>favoriteAddrFamily</code>返回了当前 dial 最合适的地址族，主要是判断应该用ipv4还是ipv6或者都用，其返回值 family 有两种可能值：<code>AF_INET</code>和<code>AF_INET6</code>，都是int类型，感兴趣的朋友可以参见<a href="https://stackoverflow.com/questions/1593946/what-is-af-inet-and-why-do-i-need-it" target="_blank" rel="noopener">这里</a>。</p><p>让我们接着关注<code>socket</code>,该函数在<code>sock_posix.go</code>文件，意味着接下来将是更加底层的系统调用了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket returns a network file descriptor that is ready for</span></span><br><span class="line"><span class="comment">// asynchronous I/O using the network poller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, family, sotype, proto <span class="keyword">int</span>, ipv6only <span class="keyword">bool</span>, laddr, raddr sockaddr)</span> <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line">s, err := sysSocket(family, sotype, proto)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = setDefaultSockopts(s, family, sotype, ipv6only); err != <span class="literal">nil</span> &#123;</span><br><span class="line">poll.CloseFunc(s)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fd, err = newFD(s, family, sotype, net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">poll.CloseFunc(s)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function makes a network file descriptor for the</span></span><br><span class="line"><span class="comment">// following applications:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens a passive stream</span></span><br><span class="line"><span class="comment">//   connection, known as a stream listener</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens a destination-unspecific</span></span><br><span class="line"><span class="comment">//   datagram connection, known as a datagram listener</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens an active stream or a</span></span><br><span class="line"><span class="comment">//   destination-specific datagram connection, known as a</span></span><br><span class="line"><span class="comment">//   dialer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens the other connection, such</span></span><br><span class="line"><span class="comment">//   as talking to the protocol stack inside the kernel</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For stream and datagram listeners, they will only require</span></span><br><span class="line"><span class="comment">// named sockets, so we can assume that it's just a request</span></span><br><span class="line"><span class="comment">// from stream or datagram listeners when laddr is not nil but</span></span><br><span class="line"><span class="comment">// raddr is nil. Otherwise we assume it's just for dialers or</span></span><br><span class="line"><span class="comment">// the other connection holders.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> laddr != <span class="literal">nil</span> &amp;&amp; raddr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> sotype &#123;</span><br><span class="line"><span class="keyword">case</span> syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:</span><br><span class="line"><span class="keyword">if</span> err := fd.listenStream(laddr, listenerBacklog); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> syscall.SOCK_DGRAM:</span><br><span class="line"><span class="keyword">if</span> err := fd.listenDatagram(laddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := fd.dial(ctx, laddr, raddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码隐含了大量细节，首先看最上面函数的注释，返回值是一个使用了<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener"><code>network poller</code></a>的<strong>异步I/O</strong>的文件描述符。前面三个 if 里，先创建了一个 socket，然后设置基本参数，再 new 一个文件描述符，其中包含了大量的系统调用和底层细节，这里先跳过。我想说的在下面。</p><p>socket 这个函数可以为一下几种应用创建一个文件描述符：</p><ul><li>一个打开了 被动的、流式的 连接的终端，通常叫<code>stream listener</code></li><li>一个打开了 没有具体目的地的、数据报格式的 连接的终端，通常叫<code>datagram listener</code></li><li>一个打开了 主动的、有明确目的地的、数据报格式的 连接的终端，通常叫<code>dialer</code></li><li>一个打开了其他连接的终端，比如与内核中的协议栈通信</li></ul><blockquote><p>通常可以认为当 <code>laddr</code>不为空但<code>raddr</code>为空时的 request 是来自stream or datagram listeners。否则就是来自 dialers 或者其他系统连接。</p></blockquote><p>所以一个dialer和listener的区别就是 laddr， 也就是dialer在一定情况下可以当做listener，到这里就可以解释之前tcp的<code>simultaneous connection</code>同时连接了。</p><p>接下来调用了fd的dial函数，这里才真正通过socket开始发送连接请求。</p><p>(待续)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.littlechao.top/#/index/article?_id=5a9823ceebc087002a3e7259&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt; 我们大致分析了dial.go
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go net/dial.go（I）</title>
    <link href="http://littlechao.top/2018/03/01/golang%20net:dial.go/"/>
    <id>http://littlechao.top/2018/03/01/golang net:dial.go/</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实际上dial.go这个文件中并没有实际发起连接的部分，基本上是在为真正发起连接做一系列的准备，比如：解析网络类型、从addr解析ip地址。。。实际发起连接的函数在<code>tcpsock_posix.go</code>、<code>udpsock_posix.go</code>。。。</p></blockquote><p>首先看一下最主要的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dialer <span class="keyword">struct</span> &#123;</span><br><span class="line">Timeout time.Duration</span><br><span class="line">  </span><br><span class="line">Deadline time.Time</span><br><span class="line"></span><br><span class="line">  LocalAddr Addr <span class="comment">//真正dial时的本地地址，兼容各种类型(TCP、UDP...),如果为nil，则系统自动选择一个地址</span></span><br><span class="line"></span><br><span class="line">DualStack <span class="keyword">bool</span> <span class="comment">// 双协议栈，即是否同时支持ipv4和ipv6.当network值为tcp时，dial函数会向host主机的v4和v6地址都发起连接</span></span><br><span class="line"></span><br><span class="line">FallbackDelay time.Duration <span class="comment">// 当DualStack为真，ipv6会延后于ipv4发起，此字段即为延迟时间，默认为300ms</span></span><br><span class="line"></span><br><span class="line">KeepAlive time.Duration </span><br><span class="line"></span><br><span class="line">Resolver *Resolver</span><br><span class="line"></span><br><span class="line">  Cancel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 用于取消dial</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dial是最主要的函数，看一下源码注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dial connects to the address on the named network.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only),</span></span><br><span class="line"><span class="comment">// "udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4"</span></span><br><span class="line"><span class="comment">// (IPv4-only), "ip6" (IPv6-only), "unix", "unixgram" and</span></span><br><span class="line"><span class="comment">// "unixpacket".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For TCP and UDP networks, the address has the form "host:port".</span></span><br><span class="line"><span class="comment">// The host must be a literal IP address, or a host name that can be</span></span><br><span class="line"><span class="comment">// resolved to IP addresses.</span></span><br><span class="line"><span class="comment">// The port must be a literal port number or a service name.</span></span><br><span class="line"><span class="comment">// If the host is a literal IPv6 address it must be enclosed in square</span></span><br><span class="line"><span class="comment">// brackets, as in "[2001:db8::1]:80" or "[fe80::1%zone]:80".</span></span><br><span class="line"><span class="comment">// The zone specifies the scope of the literal IPv6 address as defined</span></span><br><span class="line"><span class="comment">// in RFC 4007.</span></span><br><span class="line"><span class="comment">// The functions JoinHostPort and SplitHostPort manipulate a pair of</span></span><br><span class="line"><span class="comment">// host and port in this form.</span></span><br><span class="line"><span class="comment">// When using TCP, and the host resolves to multiple IP addresses,</span></span><br><span class="line"><span class="comment">// Dial will try each IP address in order until one succeeds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//Dial("tcp", "golang.org:http")</span></span><br><span class="line"><span class="comment">//Dial("tcp", "192.0.2.1:http")</span></span><br><span class="line"><span class="comment">//Dial("tcp", "198.51.100.1:80")</span></span><br><span class="line"><span class="comment">//Dial("udp", "[2001:db8::1]:domain")</span></span><br><span class="line"><span class="comment">//Dial("udp", "[fe80::1%lo0]:53")</span></span><br><span class="line"><span class="comment">//Dial("tcp", ":80")</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For IP networks, the network must be "ip", "ip4" or "ip6" followed</span></span><br><span class="line"><span class="comment">// by a colon and a literal protocol number or a protocol name, and</span></span><br><span class="line"><span class="comment">// the address has the form "host". The host must be a literal IP</span></span><br><span class="line"><span class="comment">// address or a literal IPv6 address with zone.</span></span><br><span class="line"><span class="comment">// It depends on each operating system how the operating system</span></span><br><span class="line"><span class="comment">// behaves with a non-well known protocol number such as "0" or "255".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//Dial("ip4:1", "192.0.2.1")</span></span><br><span class="line"><span class="comment">//Dial("ip6:ipv6-icmp", "2001:db8::1")</span></span><br><span class="line"><span class="comment">//Dial("ip6:58", "fe80::1%lo0")</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For TCP, UDP and IP networks, if the host is empty or a literal</span></span><br><span class="line"><span class="comment">// unspecified IP address, as in ":80", "0.0.0.0:80" or "[::]:80" for</span></span><br><span class="line"><span class="comment">// TCP and UDP, "", "0.0.0.0" or "::" for IP, the local system is</span></span><br><span class="line"><span class="comment">// assumed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For Unix networks, the address must be a file system path.</span></span><br></pre></td></tr></table></figure><blockquote><p>从注释可以看出，Dial 支持多种网络类型；支持ipv4、ipv6；还支持用host名代替ip地址。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d Dialer</span><br><span class="line"><span class="keyword">return</span> d.Dial(network, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTimeout</span><span class="params">(network, address <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">d := Dialer&#123;Timeout: timeout&#125;</span><br><span class="line"><span class="keyword">return</span> d.Dial(network, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dialer)</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> d.DialContext(context.Background(), network, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上前两个是导出的主要函数，都调用了d.dial()，d.DialContext()。d.DialContext()可以传入一个context，如果context的生命周期在connect完成之前结束，那么会立即返回错误。如果context在连接建立完成之后结束，则不会影响连接。另外如果addr是一组ip地址的话，会把当前剩下的所有时间均分到每个ip上去尝试连接。只要有一个成功，就会立即返回成功的连接并取消其他尝试。具体看代码(有删减)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dialer)</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">  deadline := d.deadline(ctx, time.Now()) </span><br><span class="line">  <span class="comment">//d.deadline() 比较d.deadline、ctx.deadline、now+timeout，返回其中最小.如果都为空，返回0</span></span><br><span class="line">  ...</span><br><span class="line">  subCtx, cancel := context.WithDeadline(ctx, deadline) <span class="comment">//设置新的超时context</span></span><br><span class="line">  <span class="keyword">defer</span> cancel()</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// Shadow the nettrace (if any) during resolve so Connect events don't fire for DNS lookups.</span></span><br><span class="line">resolveCtx := ctx</span><br><span class="line">...<span class="comment">//给resolveCtx带上一些value</span></span><br><span class="line"></span><br><span class="line">addrs, err := d.resolver().resolveAddrList(resolveCtx, <span class="string">"dial"</span>, network, address, d.LocalAddr) <span class="comment">// 解析IP地址，返回值是一个切片</span></span><br><span class="line"></span><br><span class="line">dp := &amp;dialParam&#123;</span><br><span class="line">Dialer:  *d,</span><br><span class="line">network: network,</span><br><span class="line">address: address,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> primaries, fallbacks addrList</span><br><span class="line"><span class="keyword">if</span> d.DualStack &amp;&amp; network == <span class="string">"tcp"</span> &#123; <span class="comment">//表示同时支持ipv4和ipv6</span></span><br><span class="line">primaries, fallbacks = addrs.partition(isIPv4) <span class="comment">// 将addrs分成两个切片，前者包含ipv4地址，后者包含ipv6地址</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">primaries = addrs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c Conn</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fallbacks) &gt; <span class="number">0</span> &#123;<span class="comment">//有ipv6的情况，v4和v6一起dial</span></span><br><span class="line">c, err = dialParallel(ctx, dp, primaries, fallbacks)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c, err = dialSerial(ctx, dp, primaries)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码看到，DialContext最终调用的是<code>dialParallel</code>和<code>dialSerial</code>,先看dialParallel，该函数将v4地址和v6地址分开，先尝试v4地址组，在dialer.fallbackDelay 时间后开始尝试v6地址组，每一组都是调用dialSerial(),让两组竞争：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialParallel</span><span class="params">(ctx context.Context, dp *dialParam, primaries, fallbacks addrList)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fallbacks) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dialSerial(ctx, dp, primaries)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dialResult <span class="keyword">struct</span> &#123;</span><br><span class="line">Conn</span><br><span class="line">error</span><br><span class="line">primary <span class="keyword">bool</span></span><br><span class="line">done    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> dialResult) <span class="comment">// unbuffered</span></span><br><span class="line"></span><br><span class="line">startRacer := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, primary <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">ras := primaries <span class="comment">// ras 意思是 remote addresses</span></span><br><span class="line"><span class="keyword">if</span> !primary &#123;</span><br><span class="line">ras = fallbacks</span><br><span class="line">&#125;</span><br><span class="line">c, err := dialSerial(ctx, dp, ras)</span><br><span class="line">      ...</span><br><span class="line">results &lt;- dialResult&#123;Conn: c, error: err, primary: primary, done: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> primary, fallback dialResult</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the main racer.</span></span><br><span class="line">primaryCtx, primaryCancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> primaryCancel()</span><br><span class="line"><span class="keyword">go</span> startRacer(primaryCtx, <span class="literal">true</span>)<span class="comment">//先尝试ipv4地址组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the timer for the fallback racer.</span></span><br><span class="line">fallbackTimer := time.NewTimer(dp.fallbackDelay())</span><br><span class="line"><span class="keyword">defer</span> fallbackTimer.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-fallbackTimer.C: <span class="comment">// ipv6延迟时间到，开始尝试ipv6地址组</span></span><br><span class="line">fallbackCtx, fallbackCancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> fallbackCancel()</span><br><span class="line"><span class="keyword">go</span> startRacer(fallbackCtx, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> res := &lt;-results: <span class="comment">//表示至少有一组已经建立连接</span></span><br><span class="line"><span class="keyword">if</span> res.error == <span class="literal">nil</span> &#123; <span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> res.Conn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.primary &#123;</span><br><span class="line">primary = res</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fallback = res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> primary.done &amp;&amp; fallback.done &#123;<span class="comment">//同时建立连接，抛弃</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, primary.error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.primary &amp;&amp; fallbackTimer.Stop() &#123;</span><br><span class="line"><span class="comment">// If we were able to stop the timer, that means it</span></span><br><span class="line"><span class="comment">// was running (hadn't yet started the fallback), but</span></span><br><span class="line"><span class="comment">// we just got an error on the primary path, so start</span></span><br><span class="line"><span class="comment">// the fallback immediately (in 0 nanoseconds).</span></span><br><span class="line">fallbackTimer.Reset(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看<code>dialSerial</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialSerial</span><span class="params">(ctx context.Context, dp *dialParam, ras addrList)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> firstErr error <span class="comment">// The error from the first address is most relevant.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ra := <span class="keyword">range</span> ras &#123; <span class="comment">// ra =&gt; remote address</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//表示</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: dp.LocalAddr, Addr: ra, Err: mapErr(ctx.Err())&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deadline, _ := ctx.Deadline()</span><br><span class="line">partialDeadline, err := partialDeadline(time.Now(), deadline, <span class="built_in">len</span>(ras)-i)</span><br><span class="line">        <span class="comment">// 这里表示前 i 个IP地址的连接失败，然后将剩下的时间均分到剩余的IP地址</span></span><br><span class="line">...<span class="comment">//判断是否超时并处理</span></span><br><span class="line">      </span><br><span class="line">dialCtx := ctx</span><br><span class="line">        dialCtx, cancel := context.WithDeadline(ctx, partialDeadline)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">c, err := dialSingle(dialCtx, dp, ra)<span class="comment">// 对单个IP地址发起连接</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> firstErr == <span class="literal">nil</span> &#123;</span><br><span class="line">firstErr = err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> firstErr == <span class="literal">nil</span> &#123;</span><br><span class="line">firstErr = &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: <span class="literal">nil</span>, Addr: <span class="literal">nil</span>, Err: errMissingAddress&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, firstErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终所有的对单个IP地址发起链接的任务是由dialSingle分配的（此处简单看下就好），该函数解决了兼容不同网络类型的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialSingle</span><span class="params">(ctx context.Context, dp *dialParam, ra Addr)</span> <span class="params">(c Conn, err error)</span></span> &#123;</span><br><span class="line">trace, _ := ctx.Value(nettrace.TraceKey&#123;&#125;).(*nettrace.Trace)</span><br><span class="line"><span class="keyword">if</span> trace != <span class="literal">nil</span> &#123;</span><br><span class="line">raStr := ra.String()</span><br><span class="line"><span class="keyword">if</span> trace.ConnectStart != <span class="literal">nil</span> &#123;</span><br><span class="line">trace.ConnectStart(dp.network, raStr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> trace.ConnectDone != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; trace.ConnectDone(dp.network, raStr, err) &#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">la := dp.LocalAddr</span><br><span class="line"><span class="keyword">switch</span> ra := ra.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *TCPAddr:</span><br><span class="line">la, _ := la.(*TCPAddr)</span><br><span class="line">c, err = dialTCP(ctx, dp.network, la, ra)</span><br><span class="line"><span class="keyword">case</span> *UDPAddr:</span><br><span class="line">la, _ := la.(*UDPAddr)</span><br><span class="line">c, err = dialUDP(ctx, dp.network, la, ra)</span><br><span class="line"><span class="keyword">case</span> *IPAddr:</span><br><span class="line">la, _ := la.(*IPAddr)</span><br><span class="line">c, err = dialIP(ctx, dp.network, la, ra)</span><br><span class="line"><span class="keyword">case</span> *UnixAddr:</span><br><span class="line">la, _ := la.(*UnixAddr)</span><br><span class="line">c, err = dialUnix(ctx, dp.network, la, ra)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: la, Addr: ra, Err: &amp;AddrError&#123;Err: <span class="string">"unexpected address type"</span>, Addr: dp.address&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: la, Addr: ra, Err: err&#125; <span class="comment">// c is non-nil interface containing nil pointer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，dial.go基本就这么多内容，真正通过socket建立连接的部分下篇再写吧(其实是偷懒)。</p><h4 id="待续"><a href="#待续" class="headerlink" title="(待续)"></a>(待续)</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;实际上dial.go这个文件中并没有实际发起连接的部分，基本上是在为真正发起连接做一系列的准备，比如：解析网络类型、从addr解析ip地址。。。实际发起连接的函数在&lt;code&gt;tcpsock_posix.go&lt;/code&gt;、&lt;code&gt;udpsoc
      
    
    </summary>
    
    
      <category term="golang" scheme="http://littlechao.top/tags/golang/"/>
    
      <category term="net" scheme="http://littlechao.top/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>Go bytes.go</title>
    <link href="http://littlechao.top/2018/02/05/byte/"/>
    <id>http://littlechao.top/2018/02/05/byte/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.359Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习bytes的时候，网上找了很多文章，但基本上是用法，很少对代码的分析。这篇文章对bytes.go 做了简要的分析。</p></blockquote><p>首先从 <code>import</code> 的包来看，只引入了<code>unicode</code> 包的部分函数，所以这个文件代码主要是对字节切片做字符处理。从主要的功能来分，bytes.go 分为几个部分：</p><ul><li>index/contain 系列函数</li><li>splite、fields 拆分函数</li><li>Map 遍历函数</li></ul><h3 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h3><p>开始对每个部分分析前，先来看一下 <code>unicode</code> 包里用的比较多的内容。</p><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">RuneError = <span class="string">'\uFFFD'</span>     <span class="comment">// 这是一个特殊的字符，用于表示“非法”的unicode</span></span><br><span class="line">RuneSelf  = <span class="number">0x80</span>         <span class="comment">// 十六进制的80，等于十进制的127，0~127刚好表示128个ASCII码。一个字符的字节码大于127，表示不是ASCII，可能是unicode</span></span><br><span class="line">MaxRune   = <span class="string">'\U0010FFFF'</span> <span class="comment">// 最大的unicode编码</span></span><br><span class="line">UTFMax    = <span class="number">4</span>            <span class="comment">// 一个unicode码最大的字节长度</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>utf8.DecodeRune(p []byte)(r rune, size int):从字节切片中解析出第一个完整的unicode码，<br>返回一个<code>rune</code>类型的<code>r</code>（第一个unicode），和<code>r</code>的真实长度size，从代码中可看出，size的值是0~4。简单看一下返回值就好，这不是本文的重点：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeRune</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(p)</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> RuneError, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">p0 := p[<span class="number">0</span>]</span><br><span class="line">x := first[p0]</span><br><span class="line"><span class="keyword">if</span> x &gt;= as &#123;</span><br><span class="line"><span class="comment">// The following code simulates an additional check for x == xx and</span></span><br><span class="line"><span class="comment">// handling the ASCII and invalid cases accordingly. This mask-and-or</span></span><br><span class="line"><span class="comment">// approach prevents an additional branch.</span></span><br><span class="line">mask := <span class="keyword">rune</span>(x) &lt;&lt; <span class="number">31</span> &gt;&gt; <span class="number">31</span> <span class="comment">// Create 0x0000 or 0xFFFF.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">rune</span>(p[<span class="number">0</span>])&amp;^mask | RuneError&amp;mask, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">sz := x &amp; <span class="number">7</span></span><br><span class="line">accept := acceptRanges[x&gt;&gt;<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="keyword">int</span>(sz) &#123;</span><br><span class="line"><span class="keyword">return</span> RuneError, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">b1 := p[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> b1 &lt; accept.lo || accept.hi &lt; b1 &#123;</span><br><span class="line"><span class="keyword">return</span> RuneError, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sz == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">rune</span>(p0&amp;mask2)&lt;&lt;<span class="number">6</span> | <span class="keyword">rune</span>(b1&amp;maskx), <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">b2 := p[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> b2 &lt; locb || hicb &lt; b2 &#123;</span><br><span class="line"><span class="keyword">return</span> RuneError, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sz == <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">rune</span>(p0&amp;mask3)&lt;&lt;<span class="number">12</span> | <span class="keyword">rune</span>(b1&amp;maskx)&lt;&lt;<span class="number">6</span> | <span class="keyword">rune</span>(b2&amp;maskx), <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">b3 := p[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> b3 &lt; locb || hicb &lt; b3 &#123;</span><br><span class="line"><span class="keyword">return</span> RuneError, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">rune</span>(p0&amp;mask4)&lt;&lt;<span class="number">18</span> | <span class="keyword">rune</span>(b1&amp;maskx)&lt;&lt;<span class="number">12</span> | <span class="keyword">rune</span>(b2&amp;maskx)&lt;&lt;<span class="number">6</span> | <span class="keyword">rune</span>(b3&amp;maskx), <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意以上函数返回值， rune 是一个 int32， 占4字节，size则是返回的unicode占的真实长度</strong>。这里统一用四个字节来表示一个unicode。</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>这里有一系列的index的函数:</p><ul><li>func Contains(b, subslice []byte) bool</li><li>func Count(s, sep []byte) int</li><li>func Index(s, sep []byte) int</li><li>func IndexByte(s []byte, c byte) int</li><li>func IndexRune(s []byte, r rune) int</li><li>func IndexAny(s []byte, chars string) int</li><li>func IndexFunc(s []byte, f func(r rune) bool) int</li><li>func LastIndex(s, sep []byte) int</li><li>func LastIndexAny(s []byte, chars string) int</li><li>func LastIndexFunc(s []byte, f func(r rune) bool) int</li><li>…</li></ul><p>但是基本上是在调用同一个函数： <code>func Index(s, sep []byte) int</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(sep)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> n == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> n == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> IndexByte(s, sep[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">case</span> n == <span class="built_in">len</span>(s):</span><br><span class="line"><span class="keyword">if</span> Equal(sep, s) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">case</span> n &gt; <span class="built_in">len</span>(s):</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">case</span> n &lt;= shortStringLen:</span><br><span class="line"><span class="comment">// Use brute force when s and sep both are small</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> indexShortStr(s, sep)</span><br><span class="line">&#125;</span><br><span class="line">c := sep[<span class="number">0</span>]</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">t := s[:<span class="built_in">len</span>(s)-n+<span class="number">1</span>]</span><br><span class="line">fails := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(t) &#123;</span><br><span class="line"><span class="keyword">if</span> t[i] != c &#123;</span><br><span class="line"><span class="comment">// IndexByte skips 16/32 bytes per iteration,</span></span><br><span class="line"><span class="comment">// so it's faster than indexShortStr.</span></span><br><span class="line">o := IndexByte(t[i:], c)</span><br><span class="line"><span class="keyword">if</span> o &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">i += o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> Equal(s[i:i+n], sep) &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">fails++</span><br><span class="line">i++</span><br><span class="line"><span class="comment">// Switch to indexShortStr when IndexByte produces too many false positives.</span></span><br><span class="line"><span class="comment">// Too many means more that 1 error per 8 characters.</span></span><br><span class="line"><span class="comment">// Allow some errors in the beginning.</span></span><br><span class="line"><span class="keyword">if</span> fails &gt; (i+<span class="number">16</span>)/<span class="number">8</span> &#123;</span><br><span class="line">r := indexShortStr(s[i:], sep)</span><br><span class="line"><span class="keyword">if</span> r &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r + i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> indexRabinKarp(s, sep)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，是几个 case，主要是排除掉一些简单的情况。从<code>s</code>中找到第一次出现<code>sep</code>的位置，当sep长度为1，sep就是一个字节，<br>直接调用<code>IndexByte（s, sep[0]）</code>,就是把<code>s</code>里的字节挨个取出和sep[0]对比。<br><code>case n &lt;= shortStringLen:</code>表示最普遍的情况，这里使用了相关匹配算法，就不深入谈论了。</p><p>再简单看下<code>func IndexAny(s []byte, chars string) int</code>函数，返回<code>s</code>中第一次出现<code>chars</code>中任一字符的位置。<br>注意chars是string类型，可能包含ASCII和unicode，所以要先对<code>chars</code>做处理：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> chars == <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// Avoid scanning all of s.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">8</span> &#123;<span class="comment">// 为什么这里判断len(s) &gt; 8,我也不知道，如果你知道麻烦告诉我哦</span></span><br><span class="line">      <span class="comment">// 这里 `makeASCIISet(chars)` 尝试将chars解析成ASCII码并生成集合，如果chars全都是ASCII码，isAscii 为 TRUE，反之为false</span></span><br><span class="line"><span class="keyword">if</span> as, isASCII := makeASCIISet(chars); isASCII &#123;</span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> as.contains(c) &#123;<span class="comment">//找到第一个元素，返回下标</span></span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当len(s)&lt;=8 或者 chars中包含unicode码会执行到这里。以下这段请仔细看，这样的套路会在bytes包里广泛使用。</span></span><br><span class="line"><span class="keyword">var</span> width <span class="keyword">int</span>  <span class="comment">//记录每个字符长度</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i += width &#123;</span><br><span class="line">r := <span class="keyword">rune</span>(s[i])</span><br><span class="line"><span class="keyword">if</span> r &lt; utf8.RuneSelf &#123;<span class="comment">// 表示r是一个ASCII码，则长度为一字节</span></span><br><span class="line">width = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r, width = utf8.DecodeRune(s[i:]) <span class="comment">// 从第 i 个开始到第 i+width 个字节，可能解析成一个unicode</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> chars &#123;<span class="comment">//依次取出chars中每一个rune，和r比较</span></span><br><span class="line"><span class="keyword">if</span> r == ch &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基本上<code>index</code>类的函数理解以上两个就够了，其余的是在他们的基础上有小的调节。</p><h3 id="splite"><a href="#splite" class="headerlink" title="splite"></a>splite</h3><ul><li><a href="https://wizardforcel.gitbooks.io/golang-stdlib-ref/content/7.html#Split" target="_blank" rel="noopener">func Split(s, sep []byte) [][]byte</a></li><li><a href="https://wizardforcel.gitbooks.io/golang-stdlib-ref/content/7.html#SplitN" target="_blank" rel="noopener">func SplitN(s, sep []byte, n int) [][]byte</a></li><li><a href="https://wizardforcel.gitbooks.io/golang-stdlib-ref/content/7.html#SplitAfter" target="_blank" rel="noopener">func SplitAfter(s, sep []byte) [][]byte</a></li><li><a href="https://wizardforcel.gitbooks.io/golang-stdlib-ref/content/7.html#SplitAfterN" target="_blank" rel="noopener">func SplitAfterN(s, sep []byte, n int) [][]byte</a></li><li>…</li></ul><p>Splite 函数根据sep将字节切片切分成很多小切片，然后组成新的切片的切片。</p><p>和index函数一样，splite基本上是在调用<code>func genSplit(s, sep []byte, sepSave, n int) [][]byte</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genSplit</span><span class="params">(s, sep []<span class="keyword">byte</span>, sepSave, n <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span> &#123;</span><br><span class="line">  <span class="comment">//s是源切片，sep是分割切片，sepSave表示分割后要保留sep中的多少位，n表示取前n-1个分段，超出n个的部分不分割，直接返回</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sep) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> explode(s, n) <span class="comment">//长度为0，则按照“空”分割，也就是每个字符都分割，explode函数的功能是将切片分割成字符切片</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">n = Count(s, sep) + <span class="number">1</span> <span class="comment">//重新计算n，表示有多少sep段就分多少次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, n)</span><br><span class="line">n--</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">m := Index(s, sep)</span><br><span class="line"><span class="keyword">if</span> m &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">a[i] = s[: m+sepSave : m+sepSave]  <span class="comment">//m + sepSave</span></span><br><span class="line">s = s[m+<span class="built_in">len</span>(sep):]</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">a[i] = s</span><br><span class="line"><span class="keyword">return</span> a[:i+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fields 的功能也是分段，先来看一下<code>FieldsFunc</code>,该函数通过f()得返回值来判断是否应该在某个字符处分段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func FieldsFunc(s []byte, f func(rune) bool) [][]byte &#123;</span><br><span class="line">// A span is used to record a slice of s of the form s[start:end].</span><br><span class="line">// The start index is inclusive and the end index is exclusive.</span><br><span class="line">type span struct &#123;//用于记录每一段的起始和终点下标</span><br><span class="line">start int</span><br><span class="line">end   int</span><br><span class="line">&#125;</span><br><span class="line">spans := make([]span, 0, 32)</span><br><span class="line"></span><br><span class="line">// Find the field start and end indices.</span><br><span class="line">wasField := false// wasField 表示从fromIndex开始到当前的字符是否应该出现在结果中</span><br><span class="line">fromIndex := 0</span><br><span class="line">for i := 0; i &lt; len(s); &#123;</span><br><span class="line">size := 1</span><br><span class="line">r := rune(s[i])</span><br><span class="line">if r &gt;= utf8.RuneSelf &#123;</span><br><span class="line">r, size = utf8.DecodeRune(s[i:])</span><br><span class="line">&#125;</span><br><span class="line">if f(r) &#123;// r 应该分段</span><br><span class="line">if wasField &#123;// 从fromIndex到当前(i)应该出现在结果中</span><br><span class="line">spans = append(spans, span&#123;start: fromIndex, end: i&#125;)</span><br><span class="line">wasField = false</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if !wasField &#123;// 从fromIndex到当前(i)不应该出现在结果中</span><br><span class="line">fromIndex = i</span><br><span class="line">wasField = true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i += size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Last field might end at EOF.</span><br><span class="line">if wasField &#123;</span><br><span class="line">spans = append(spans, span&#123;fromIndex, len(s)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Create subslices from recorded field indices.</span><br><span class="line">a := make([][]byte, len(spans))</span><br><span class="line">for i, span := range spans &#123;</span><br><span class="line">a[i] = s[span.start:span.end:span.end]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个<code>Fields</code>函数，其实就是调用<code>FieldsFunc</code>函数，只不过传入的<code>f</code>参数是一个判断字符是否是空白符的函数，就不展示代码了</p><h3 id="Map函数"><a href="#Map函数" class="headerlink" title="Map函数"></a>Map函数</h3><p><code>func Map(mapping func(r rune) rune, s []byte) []byte</code>是对字节切片中每个字符进行遍历，并且根据传入的<code>mapping</code>函数对每个字符进行修改然后存到新的切片中，最后返回新的切片。</p><p><code>ToUpper</code>,<code>ToLower</code>,<code>ToTitle</code>…等函数都调用了Map函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">rune</span>, <span class="title">s</span> []<span class="title">byte</span>) []<span class="title">byte</span></span> &#123;</span><br><span class="line">   <span class="comment">// In the worst case, the slice can grow when mapped, making</span></span><br><span class="line">   <span class="comment">// things unpleasant. But it's so rare we barge in assuming it's</span></span><br><span class="line">   <span class="comment">// fine. It could also shrink but that falls out naturally.</span></span><br><span class="line">   maxbytes := <span class="built_in">len</span>(s) <span class="comment">// length of b</span></span><br><span class="line">   nbytes := <span class="number">0</span>        <span class="comment">// number of bytes encoded in b</span></span><br><span class="line">   b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, maxbytes)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">      wid := <span class="number">1</span></span><br><span class="line">      r := <span class="keyword">rune</span>(s[i])</span><br><span class="line">      <span class="keyword">if</span> r &gt;= utf8.RuneSelf &#123;</span><br><span class="line">         r, wid = utf8.DecodeRune(s[i:])</span><br><span class="line">      &#125;</span><br><span class="line">      r = mapping(r) <span class="comment">//r 即修改后的字符</span></span><br><span class="line">      <span class="keyword">if</span> r &gt;= <span class="number">0</span> &#123;</span><br><span class="line">         rl := utf8.RuneLen(r)</span><br><span class="line">         <span class="keyword">if</span> rl &lt; <span class="number">0</span> &#123;</span><br><span class="line">            rl = <span class="built_in">len</span>(<span class="keyword">string</span>(utf8.RuneError))</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> nbytes+rl &gt; maxbytes &#123;</span><br><span class="line">            <span class="comment">// Grow the buffer.</span></span><br><span class="line">            maxbytes = maxbytes*<span class="number">2</span> + utf8.UTFMax</span><br><span class="line">            nb := <span class="built_in">make</span>([]<span class="keyword">byte</span>, maxbytes)</span><br><span class="line">            <span class="built_in">copy</span>(nb, b[<span class="number">0</span>:nbytes])</span><br><span class="line">            b = nb</span><br><span class="line">         &#125;</span><br><span class="line">         nbytes += utf8.EncodeRune(b[nbytes:maxbytes], r)</span><br><span class="line">      &#125;</span><br><span class="line">      i += wid</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b[<span class="number">0</span>:nbytes]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学习bytes的时候，网上找了很多文章，但基本上是用法，很少对代码的分析。这篇文章对bytes.go 做了简要的分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先从 &lt;code&gt;import&lt;/code&gt; 的包来看，只引入了&lt;code&gt;unic
      
    
    </summary>
    
    
      <category term="golang" scheme="http://littlechao.top/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>dart 语法基础</title>
    <link href="http://littlechao.top/2017/12/15/dart%20%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://littlechao.top/2017/12/15/dart 语法基础/</id>
    <published>2017-12-14T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是对 Dart 语言的官方文档做了简单的翻译和总结，有不当之处敬请指正。<br>如果有时间和精力建议通读<a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><pre><code>// Define a function.printNumber(num aNumber) {  print(&apos;The number is $aNumber.&apos;); // Print to console.}// This is where the app starts executing.main() {  var number = 42; // Declare and initialize a variable.  printNumber(number); // Call a function.}</code></pre><hr><h3 id="重要的概念"><a href="#重要的概念" class="headerlink" title="重要的概念"></a>重要的概念</h3><ul><li>能赋值给变量的所以东西都是对象，包括 numbers, null, function, 都是继承自 Object 内置类</li><li>尽量给变量定义一个类型，会更安全，没有显示定义类型的变量在 debug 模式下会类型会是  dynamic（动态的）</li><li>dart 在 running 之前解析你的所有代码，指定数据类型和编译时的常量，可以提高运行速度</li><li>dart 提供了顶级函数(如：main())</li><li>dart 没有 public、private、protected 这些关键字，变量名以”_”开头意味着对它的 lib 是私有的</li></ul><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>没有初始化的变量都会被赋予默认值 null</p></blockquote><pre><code>var name = &apos;Bob&apos;;var unInitializeValue1;   //未给初值的变量，默认值为 nullInt unInitializeValue2;   //即使是Int 型，默认值也是 null</code></pre><p>程序中只当数据类型是为了指出自己的使用意图，并帮助语言进行语法检查。但是，指定类型不是必须的</p><h6 id="num"><a href="#num" class="headerlink" title="num"></a>num</h6><ul><li><p>int 取值范围：-2^53 to 2^53</p><pre><code>// String -&gt; intvar one = int.parse(&apos;1&apos;);// String -&gt; doublevar onePointOne = double.parse(&apos;1.1&apos;);// int -&gt; StringString oneAsString = 1.toString();// double -&gt; String 注意括号中要有小数点位数，否则报错String piAsString = 3.14159.toStringAsFixed(2);</code></pre></li></ul><h6 id="string"><a href="#string" class="headerlink" title="string"></a>string</h6><ul><li>‘’’…’’’，”””…”””表示多行字符串</li><li>r’…’,r”…”表示“raw”字符串</li><li>用 $ 或 ${} 来计算字符串中变量的值</li></ul><h6 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h6><ul><li>Dart 是强 bool 类型检查，<strong>只有bool 类型的值是true 才被认为是true</strong></li></ul><h6 id="list"><a href="#list" class="headerlink" title="list"></a>list</h6><blockquote><p>list 基本和 JavaScript 数组一样，它的方法如下：</p></blockquote><pre><code>// 使用List的构造函数，也可以添加int参数，表示List固定长度，不能进行添加 删除操作var vegetables = new List();// 或者简单的用List来赋值var fruits = [&apos;apples&apos;, &apos;oranges&apos;];// 添加元素fruits.add(&apos;kiwis&apos;);// 添加多个元素fruits.addAll([&apos;grapes&apos;, &apos;bananas&apos;]);// 获取第一个元素fruits.first;// 获取元素最后一个元素fruits.last;// 查找某个元素的索引号assert(fruits.indexOf(&apos;apples&apos;) == 0);// 删除指定位置的元素，返回删除的元素fruits.removeAt(index);// 删除指定元素,成功返回true，失败返回falsefruits.remove(&apos;apples&apos;);// 删除最后一个元素，返回删除的元素fruits.removeLast();// 删除指定范围元素，含头不含尾，成功返回nullfruits.removeRange(start,end);// 删除指定条件的元素，成功返回nullfruits.removeWhere((item) =&gt; item.length &gt;6)；// 删除所有的元素fruits.clear();// sort()对元素进行排序，传入一个函数作为参数，return &lt;0表示由小到大， &gt;0表示由大到小fruits.sort((a, b) =&gt; a.compareTo(b));</code></pre><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><blockquote><p>类似 JavaScript map</p></blockquote><pre><code>// Map的声明var hawaiianBeaches = {    &apos;oahu&apos; : [&apos;waikiki&apos;, &apos;kailua&apos;, &apos;waimanalo&apos;],    &apos;big island&apos; : [&apos;wailea bay&apos;, &apos;pololu beach&apos;],    &apos;kauai&apos; : [&apos;hanalei&apos;, &apos;poipu&apos;]};var searchTerms = new Map();// 指定键值对的参数类型var nobleGases = new Map&lt;int, String&gt;();// Map的赋值，中括号中是Key，这里可不是数组nobleGase[54] = &apos;dart&apos;;//Map中的键值对是唯一的//同Set不同，第二次输入的Key如果存在，Value会覆盖之前的数据nobleGases[54] = &apos;xenon&apos;;assert(nobleGases[54] == &apos;xenon&apos;);// 检索Map是否含有某Keyassert(nobleGases.containsKey(54));//删除某个键值对nobleGases.remove(54);assert(!nobleGases.containsKey(54));</code></pre><p>注：如果定义了一个 map 常量，那么value 也必须是常量</p><h6 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h6><h2 id="gt-symbol字面量是编译时常量，在标识符前面加-。如果是动态确定，则使用Symbol构造函数，通过new来实例化"><a href="#gt-symbol字面量是编译时常量，在标识符前面加-。如果是动态确定，则使用Symbol构造函数，通过new来实例化" class="headerlink" title="&gt;symbol字面量是编译时常量，在标识符前面加#。如果是动态确定，则使用Symbol构造函数，通过new来实例化"></a>&gt;symbol字面量是编译时常量，在标识符前面加#。如果是动态确定，则使用Symbol构造函数，通过new来实例化</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><p>所有的函数都会有返回值。如果没有指定函数返回值，则默认的返回值是null。没有返回值的函数，系统会在最后添加隐式的return 语句。</p></blockquote><h6 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h6><p>函数可以有两种类型的参数：</p><ul><li>必须的——必须的参数放在参数列表的前面。</li><li>可选的——可选的参数跟在必须的参数后面。</li></ul><p>注：可选参数必须放在最后</p><blockquote><p>通过【】来表示可选参数</p></blockquote><pre><code>String say(String from, String msg, [String device]) {  var result = &apos;$from says $msg&apos;;  if (device != null) {    result = &apos;$result with a $device&apos;;  }  return result;}</code></pre><blockquote><p>还可以设置默认参数值</p></blockquote><pre><code>String say(String from, String msg,    [String device = &apos;carrier pigeon&apos;, String mood]) {  var result = &apos;$from says $msg&apos;;  if (device != null) {    result = &apos;$result with a $device&apos;;  }  if (mood != null) {    result = &apos;$result (in a $mood mood)&apos;;  }  return result;}</code></pre><blockquote><p>函数还可以作为另一个函数的参数</p></blockquote><pre><code>printElement(element) {  print(element);}var list = [1, 2, 3];// Pass printElement as a parameter.list.forEach(printElement);</code></pre><blockquote><p>函数可以匿名，但是不像 JavaScript， 匿名函数不用加上 function 关键字</p></blockquote><pre><code>var list = [&apos;apples&apos;, &apos;oranges&apos;, &apos;grapes&apos;, &apos;bananas&apos;, &apos;plums&apos;];list.forEach((i) {  print(list.indexOf(i).toString() + &apos;: &apos; + i);});</code></pre><h6 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h6><pre><code>Function makeAdder(num addBy) {  return (num i) =&gt; addBy + i;}main() {  // Create a function that adds 2.  var add2 = makeAdder(2);  // Create a function that adds 4.  var add4 = makeAdder(4);  assert(add2(3) == 5);  assert(add4(3) == 7);}</code></pre><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>除了常见的，还有如下运算符：</p><ul><li>is 运算符，a is b，用于判断 a 对象是否是 b 类的实例，返回 bool 值</li><li>is！意义与上面相反</li><li><p>as 运算符；用于检查类型</p><pre><code>(emp as Person).firstName = &apos;Bob&apos;;</code></pre></li></ul><p>如果 emp 为空或者不是 Person 的实例，会抛出异常</p><ul><li><p>??= 运算符</p><pre><code>b ??= value; // 如果 b 为空，把 value 赋值给 b;             // 否则，b 不变</code></pre></li><li><p>?? 运算符</p><pre><code>String toString() =&gt; msg ?? super.toString();//如果 msg 不为空，返回 msg；否则返回后面的</code></pre></li><li><p>.. 运算符，把对同一对象的不同操作串联起来</p><pre><code>final addressBook = (new AddressBookBuilder()      ..name = &apos;jenny&apos;      ..email = &apos;jenny@example.com&apos;      ..phone = (new PhoneNumberBuilder()            ..number = &apos;415-555-0100&apos;            ..label = &apos;home&apos;)          .build())    .build();</code></pre></li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><ul><li>if…else</li><li>for</li><li>while do-while</li><li>break continue</li><li>switch…case  如果 case 后面有表达式但是没有 break，会抛出异常</li><li>assert（仅在checked模式有效），如果条件为假，抛出异常</li></ul><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><ul><li><p>抛出固定类型的异常：</p><pre><code>throw new FormatException(&apos;Expected at least 1 section&apos;);</code></pre></li><li><p>抛出任意类型的异常：</p><pre><code>throw &apos;out of llamas！&apos;</code></pre></li><li><p>因为抛出异常属于表达式，可以将throw语句放在=&gt;语句中，或者其它可以出现表达式的地方：</p><pre><code>distanceTo(Point other) =&gt;    throw new UnimplementedError();</code></pre><h5 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h5></li><li><p>可以通过 on语句来指定需要捕获的异常类型，使用catch来处理异常</p><pre><code>try {  breedMoreLlamas();} on OutOfLlamasException {  // A specific exception  buyMoreLlamas();} on Exception catch (e) {  // Anything else that is an exception  print(&apos;Unknown exception: $e&apos;);} catch (e, s) {  print(&apos;Exception details:\n $e&apos;);  print(&apos;Stack trace:\n $s&apos;);}</code></pre></li></ul><p>可以向catch()传递1个或2个参数。第一个参数表示：捕获的异常的具体信息，第二个参数表示：异常的堆栈跟踪(stack trace)</p><h5 id="rethrow"><a href="#rethrow" class="headerlink" title="rethrow"></a>rethrow</h5><blockquote><p>rethrow语句用来处理一个异常，同时希望这个异常能够被其它调用的部分使用</p></blockquote><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><blockquote><p>Dart 的finally用来执行那些无论异常是否发生都执行的操作。</p></blockquote><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><blockquote><p>使用new语句来构造一个类。构造函数的名字可能是ClassName，也可以是ClassName.identifier</p></blockquote><pre><code>var jsonData = JSON.decode(&apos;{&quot;x&quot;:1, &quot;y&quot;:2}&apos;);// Create a Point using Point().var p1 = new Point(2, 2);// Create a Point using Point.fromJson().var p2 = new Point.fromJson(jsonData);</code></pre><ul><li>使用.来调用实例的变量或者方法。</li><li>使用 ?. 来避免左边操作数为null引发异常。</li><li>使用const替代new来创建编译时的常量构造函数。</li><li>两个使用const构建的同一个构造函数，实例相等。</li><li>获取对象的运行时类型使用：o.runtimeType</li></ul><blockquote><p>所有实例变量会生成一个隐式的getter方法，不是final或const的实例变量也会生成一个隐式的setter方法</p></blockquote><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><pre><code>class Point {  num x;  num y;  // 推荐方式  Point(this.x, this.y);}</code></pre><blockquote><p>构造函数不能被继承</p></blockquote><p>子类不会继承父类的构造函数。如果不显式提供子类的构造函数，系统就提供默认的构造函数。</p><blockquote><p>命名构造函数</p></blockquote><pre><code>class Point {  num x;  num y;  Point(this.x, this.y);  // 命名构造函数  Point.fromJson(Map json) {    x = json[&apos;x&apos;];    y = json[&apos;y&apos;];  }}</code></pre><p>使用命名构造函数可以实现一个类多个构造函数。构造函数不能被继承，父类中的命名构造函数不能被子类继承。如果想要子类也拥有一个父类一样名字的构造函数，必须在子类实现这个构造函数</p><blockquote><p>如果父类不显式提供无参的非命名构造函数，在子类中必须手动调用父类的一个构造函数。在子类构造函数名后，大括号{前，使用super.调用父类的构造函数，中间使用:分割</p></blockquote><pre><code>class Person {  String firstName;  Person.fromJson(Map data) {    print(&apos;in Person&apos;);  }}class Employee extends Person {  // 父类没有无参数的非命名构造函数，必须手动调用一个构造函数 super.fromJson(data)  Employee.fromJson(Map data) : super.fromJson(data) {    print(&apos;in Employee&apos;);  }}</code></pre><blockquote><p>当在构造函数初始化列表中使用super()时，要把它放在最后。</p></blockquote><pre><code>View(Style style, List children)    : _children = children,      super(style) {}</code></pre><blockquote><p>除了调用父类的构造函数，也可以通过初始化列表 在子类的构造函数体前（大括号前）来初始化实例的变量值，使用逗号,分隔</p></blockquote><pre><code>class Point {  num x;  num y;  Point(this.x, this.y);  // 在构造函数体前 初始化列表 设置实例变量  Point.fromJson(Map jsonMap)      : x = jsonMap[&apos;x&apos;],        y = jsonMap[&apos;y&apos;] {    print(&apos;In Point.fromJson(): ($x, $y)&apos;);  }}</code></pre><h5 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h5><blockquote><p>当实例化了一个构造函数后，不想每次都创建该类的一个新的实例的时候使用factory关键字，定义工厂构造函数，从缓存中返回一个实例，或返回一个子类型的实例</p></blockquote><pre><code>class Logger {  final String name;  bool mute = false;  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{}; // 缓存保存对象  factory Logger(String name) {    if (_cache.containsKey(name)) {      return _cache[name];    } else {      final logger = new Logger._internal(name);      _cache[name] = logger;      return logger;    }  }  Logger._internal(this.name);// 命名构造函数  void log(String msg) {    if (!mute) {      print(msg);    }  }}main() {  var p1 = new Logger(&quot;1&quot;);  p1.log(&quot;2&quot;);  var p2 = new Logger(&apos;22&apos;);  p2.log(&apos;3&apos;);  var p3 = new Logger(&apos;1&apos;);// 相同对象直接访问缓存}</code></pre><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="Getters-and-setters"><a href="#Getters-and-setters" class="headerlink" title="Getters and setters"></a>Getters and setters</h6><blockquote><p>get()和set()方法是Dart 语言提供的专门用来读取和写入对象的属性的方法。每一个类的实例变量都有一个隐式的getter和可能的setter（如果字段为final或const，只有getter）</p></blockquote><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><blockquote><p>使用abstract关键字定义一个抽象类，抽象类不能实例化。抽象类通常用来定义接口。</p></blockquote><h5 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h5><blockquote><p>每一个类都隐式的定义一个接口，这个接口包含了这个类的所有实例成员和它实现的所有接口</p><p>一个类可以实现一个或多个（用,隔开）接口，通过implements关键字。</p></blockquote><pre><code>class Person {  final _name;  Person(this._name);  String greet(who) =&gt; &apos;hello,$who,i am $_name&apos;;}class Imposter implements Person {  final _name = &apos;&apos;;  String greet(who) =&gt; &apos;hi $who.do you know who i am.&apos;;}greetBob(Person p) =&gt; p.greet(&apos;bob&apos;);main(List&lt;String&gt; args) {  print(greetBob(new Person(&apos;lili&apos;)));  print(greetBob(new Imposter()));}</code></pre><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><blockquote><p>使用extends来创造子类，使用super来指向父类</p></blockquote><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><blockquote><p>枚举类型是一种特殊的类，通常用来表示一组固定数字的常量值。</p><p>每个枚举类型都有一个index的getter，返回以0开始的位置索引，每次加1。</p><p>在switch语句中使用枚举，必须在case语句中判断所有的枚举，否则会获得警告。</p></blockquote><p>枚举类型有以下限制：</p><ul><li>不能继承，mixin，或实现一个枚举。</li><li>不能显式的实例化一个枚举。</li></ul><hr><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><blockquote><p>使用&lt;…&gt; 的方式来定义泛型</p><p>虽然Dart 语言中类型是可选的，但是明确的指明使用的是泛型，会让代码更好理解</p></blockquote><pre><code>abstract class Cache&lt;T&gt; {   T getByKey(String key);   setByKey(String key, T value); }</code></pre><h5 id="用于集合类型"><a href="#用于集合类型" class="headerlink" title="用于集合类型"></a>用于集合类型</h5><blockquote><p>泛型用于List 和 Map 类型参数化</p></blockquote><pre><code>var names = &lt;String&gt;[&apos;Seth&apos;, &apos;Kathy&apos;, &apos;Lars&apos;];var pages = &lt;String, String&gt;{  &apos;index.html&apos;: &apos;Homepage&apos;,  &apos;robots.txt&apos;: &apos;Hints for web robots&apos;,  &apos;humans.txt&apos;: &apos;We are people, not machines&apos;};</code></pre><h5 id="泛型集合及它们所包含的类型"><a href="#泛型集合及它们所包含的类型" class="headerlink" title="泛型集合及它们所包含的类型"></a>泛型集合及它们所包含的类型</h5><blockquote><p>dart的泛型类型是具体的，在运行时包含它们的类型信息。</p></blockquote><hr><h3 id="库和可见性"><a href="#库和可见性" class="headerlink" title="库和可见性"></a>库和可见性</h3><blockquote><p>使用import 和 library 指令可以方便的创建一个模块或分享代码。一个Dart 库不仅能够提供相应的API，还可以包含一些以_开头的私有变量仅在库内部可见</p><p>如果导入的库拥有相互冲突的名字，使用as为其中一个或几个指定不一样的前缀。</p></blockquote><pre><code>import &apos;package:lib1/lib1.dart&apos;;import &apos;package:lib2/lib2.dart&apos; as lib2;// ...Element element1 = new Element();           // Uses Element from lib1.lib2.Element element2 = new lib2.Element(); // Uses Element from lib2.</code></pre><blockquote><p>如果只需要使用库的一部分内容，使用show或hide有选择的导入。</p></blockquote><pre><code>// 仅导入foo.import &apos;package:lib1/lib1.dart&apos; show foo;// 除了foo都导入import &apos;package:lib2/lib2.dart&apos; hide foo;</code></pre><blockquote><p>要延迟加载一个库，首先必须使用deferred as导入它。</p></blockquote><pre><code>import &apos;package:deferred/hello.dart&apos; deferred as hello;greet() async {  // 使用await关键字暂停执行，直到库加载  await hello.loadLibrary();  hello.printGreeting();}</code></pre><p>可以在代码中多次调用loadLibrary()方法。但是实际上它只会被执行一次。</p><p>使用延迟加载的注意事项：</p><ul><li>延迟加载的内容只有在加载后才存在。</li><li>Dart 隐式的将deferred as改为了deferred as namespace。loadLibrary()返回值是Future</li></ul><hr><h3 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h3><p>使用async函数和await表达式实现异步操作。</p><p>当需要使用一个从Future返回的值时，有两个选择：</p><ul><li>使用async和await。</li><li>使用Future API。</li></ul><p>当需要从一个Stream获取值时，有两个选择：</p><ul><li>使用async和异步的循环(await for)。</li><li><p>使用Stream API。<br>代码使用了async和await就是异步的，虽然看起来像同步代码。</p><pre><code>checkVersion() async {          //注意这里 async 在小括号后面，和 JavaScript 不一样  var version = await lookUpVersion();  if (version == expectedVersion) {    // Do something.  } else {    // Do something else.  }}</code></pre></li></ul><blockquote><p>给函数添加async关键字将使函数返回一个Future类型。</p></blockquote><pre><code>// 修改前是同步的String lookUpVersionSync() =&gt; &apos;1.0.0&apos;;// 修改后 是异步的 函数体不需要使用Future API// dart会在必要的时候创建Future对象Future&lt;String&gt; lookUpVersion() async =&gt; &apos;1.0.0&apos;;</code></pre><blockquote><p>在Stream中使用异步循环</p></blockquote><pre><code> // expression的值必须是Stram类型await for (variable declaration in expression) {  // Executes each time the stream emits a value.}</code></pre><p>异步循环的执行流程如下：</p><ul><li>等待 stream 发出数据。</li><li>执行循环体，并将变量的值设置为发出的数据。</li><li>重复1.，2.直到stream 对象被关闭</li></ul><p>注：这个过程类似于 JavaScript 的 Rxjs</p><hr><h3 id="可调用类"><a href="#可调用类" class="headerlink" title="可调用类"></a>可调用类</h3><blockquote><p>Dart 语言中为了能够让类像函数一样能够被调用，可以实现call()方法。</p></blockquote><pre><code>class WannabeFunction {  call(String a, String b, String c) =&gt; &apos;$a $b $c!&apos;;}main() {  var wf = new WannabeFunction();  var out = wf(&quot;Hi&quot;,&quot;there,&quot;,&quot;gang&quot;);  print(&apos;$out&apos;); // Hi there, gang!  print(wf.runtimeType); // WannabeFunction  print(out.runtimeType); // String  print(wf is Function); // true}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文是对 Dart 语言的官方文档做了简单的翻译和总结，有不当之处敬请指正。&lt;br&gt;如果有时间和精力建议通读&lt;a href=&quot;https://www.dartlang.org/guides/language/language-tour&quot; targe
      
    
    </summary>
    
    
      <category term="dart" scheme="http://littlechao.top/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>JS call &amp; bind &amp; apply（I）</title>
    <link href="http://littlechao.top/2017/11/21/learn-into-javaScript_call&amp;bind&amp;apply/"/>
    <id>http://littlechao.top/2017/11/21/learn-into-javaScript_call&amp;bind&amp;apply/</id>
    <published>2017-11-20T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>先给一个官方描述吧：</p><blockquote><p>call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。</p><p>可以让call()中的对象调用当前对象所拥有的function。你可以使用call()来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。</p></blockquote><h4 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h4><h5 id="使用call方法调用匿名函数"><a href="#使用call方法调用匿名函数" class="headerlink" title="使用call方法调用匿名函数"></a>使用call方法调用匿名函数</h5><p>在下例中的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。这个匿名函数的主要目的是给每个数组元素对象添加一个print方法，这个print方法可以打印出各元素在数组中的正确索引号<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123;<span class="attr">species</span>: <span class="string">'Lion'</span>, <span class="attr">name</span>: <span class="string">'King'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">species</span>: <span class="string">'Whale'</span>, <span class="attr">name</span>: <span class="string">'Fail'</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; animals.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'#'</span> + i  + <span class="string">' '</span> + <span class="keyword">this</span>.species + <span class="string">': '</span> + <span class="keyword">this</span>.name); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">this</span>.print();</span><br><span class="line">  &#125;).call(animals[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用call方法调用函数并且指定上下文的-this"><a href="#使用call方法调用函数并且指定上下文的-this" class="headerlink" title="使用call方法调用函数并且指定上下文的 this"></a>使用call方法调用函数并且指定上下文的 <code>this</code></h5><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><h4 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>在上面的第二个例子里，注意两点：</p><ul><li>call 改变了 this 的指向，指向到 foo</li><li>bar 函数执行了</li></ul><p>试想当调用 call 的时候，把 foo 对象改造成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个时候 this 就指向了 foo，是不是很简单呢？</p><p>所以我们模拟的步骤可以分为：</p><ul><li>将函数设为对象的属性</li><li>执行该函数</li><li>删除该函数<h5 id="模拟第一步"><a href="#模拟第一步" class="headerlink" title="模拟第一步"></a>模拟第一步</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;    <span class="comment">//this 指向调用 call1 的函数</span></span><br><span class="line">  context.fn();</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call2(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><h5 id="模拟第二步：指定参数"><a href="#模拟第二步：指定参数" class="headerlink" title="模拟第二步：指定参数"></a>模拟第二步：指定参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>); </span><br><span class="line">  <span class="comment">//获取arguments（传进来的所有参数），变成数组，并去掉第一个参数（context）</span></span><br><span class="line">  context.fn(...args);   </span><br><span class="line">  <span class="comment">// ...是es6的语法，意思是展开后面的对象或数组</span></span><br><span class="line">  <span class="comment">// 例如： ...[1,2,3,4,5] =&gt; 1,2,3,4,5</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是没有 es6 时的替代方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="模拟实现第三步"><a href="#模拟实现第三步" class="headerlink" title="模拟实现第三步"></a>模拟实现第三步</h5><p>模拟代码已经完成 80%，还有两个小点要注意：</p><p>1.this 参数可以传 null，当为 null 的时候，视为指向 window</p><p>2.函数是可以有返回值的！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>); </span><br><span class="line">  <span class="comment">//获取arguments（传进来的所有参数），变成数组，并去掉第一个参数（context）</span></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);   </span><br><span class="line">  <span class="comment">// ...是es6的语法，意思是展开后面的对象或数组</span></span><br><span class="line">  <span class="comment">// 例如： ...[1,2,3,4,5] =&gt; 1,2,3,4,5</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成！ｂ（￣▽￣）ｄ</p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><blockquote><p>和 call 一样，只是参数是以数组的形式给出</p><h5 id="模拟实现-1"><a href="#模拟实现-1" class="headerlink" title="模拟实现"></a>模拟实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">Object</span>(context) || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="string">'arr['</span> + i + <span class="string">']'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><blockquote><p>MDN 的解释：bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当新函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">   <span class="comment">// closest thing possible to the ECMAScript 5 internal IsCallable function</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), </span><br><span class="line">     fToBind = <span class="keyword">this</span>, </span><br><span class="line">     fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">     fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis</span><br><span class="line">                              ? <span class="keyword">this</span></span><br><span class="line">                              : oThis || <span class="built_in">window</span>,</span><br><span class="line">                            aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line"> fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line"> fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call apply bind 区别"></a>call apply bind 区别</h2><p>call和apply，bind都是用来改变函数中this的指向<br>不同的是call和apply不仅改变了函数中this的指向并且立即调用了函数而bind仅仅是替换了this没有调用</p><p>apply和call的区别在于当Parent有参数的时候call只能一个一个的赋值 apply可以以数组的方式传递<br>bind体验了js的预处理，预先处理数据 稍后之行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;call&quot;&gt;&lt;a href=&quot;#call&quot; class=&quot;headerlink&quot; title=&quot;call&quot;&gt;&lt;/a&gt;call&lt;/h2&gt;&lt;p&gt;先给一个官方描述吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;call() 方法调用一个函数, 其具有一个指定的this值和
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlechao.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>redux your app</title>
    <link href="http://littlechao.top/2017/10/08/redux/"/>
    <id>http://littlechao.top/2017/10/08/redux/</id>
    <published>2017-10-07T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redux简介"><a href="#redux简介" class="headerlink" title="redux简介"></a>redux简介</h3><p>简单来说，redux 就是帮我们统一管理了 react 组件的 state 状态。</p><p>为什么要使用 redux 统一管理 state 呢？没有 redux 我们依旧可以开发 APP，但是当 APP 的复杂度到达一定程度的时候，摆在我们面前的就是 难以维护 的代码（其中包含组件大量的异步回调，数据处理等等），但是使用 redux 也会增加我们整个项目的复杂度，这就需要我们在两者之间进行权衡了，对于这一部分，redux 开发者给我们下面几个参考点：</p><blockquote><p>以下几种情况不需要使用 redux：</p></blockquote><ul><li><p>整体 UI 很简单，没有太多交互。</p></li><li><p>不需要与服务器进行大量交互，也没有使用 WebSocket。</p></li><li><p>视图层只从单一来源获取数据。</p></li></ul><blockquote><p>以下几种情况可考虑使用 redux：</p></blockquote><ul><li><p>用户的交互复杂。</p></li><li><p>根据层级用户划分功能。</p></li><li><p>多个用户之间协作。</p></li><li><p>与服务器大量交互，或使用了 WebSocket。</p></li><li><p>视图层需要从多个来源获取数据。</p></li></ul><p>总结以上内容：redux 适用于 多交互，多数据源，复杂程度高的工程中。</p><p>也就是说，当我们的组件出现 某个状态需要共享，需要改变另一个组件状态 等传值比较不容易的情况。就可以考虑 redux ，当然还有其他 redux 的替代产品供我们使用。。</p><h3 id="重要内容"><a href="#重要内容" class="headerlink" title="重要内容"></a>重要内容</h3><p><img src="http://upload-images.jianshu.io/upload_images/2041009-06f5967c685f961b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>为了避免混乱，我们不应该直接修改 redux 的状态，需要有特定的办法来修改状态。<br>首先我们需要 <strong>action</strong> 来触发一个行为，告知 redux 我们需要修改状态，<br>然后应由专门生产新状态的 <strong>reducer</strong> 来产生新的状态</p></blockquote><h5 id="action"><a href="#action" class="headerlink" title="action"></a>action</h5><blockquote><p>action 是一个对象，包含这个行为的 <strong>类型</strong> 和必要的参数(可选)。action也可写成一个返回对象的函数(ActionCreator)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAction</span>(<span class="params">key1, key2, ...keyN</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">              type: <span class="string">"TEST_ACTION"</span>,</span><br><span class="line">              key1: key1,</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">              keyN: keyN</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h5 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h5><blockquote><p>reducer 是一个纯函数，满足以下条件：</p><ul><li>相同输入必须有相同输出</li><li>不能修改传入的参数</li><li>不能包含 random、Date 等非纯函数</li></ul></blockquote><p><strong><em>另外，reducer 每次返回的必须是一个全新的状态</em></strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  article: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">article</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Actions.ADD_ARTICLE_TAG: &#123;</span><br><span class="line">      <span class="keyword">let</span> article = <span class="built_in">Object</span>.assign(state.article);</span><br><span class="line">      <span class="keyword">if</span>(article.tags)&#123;</span><br><span class="line">        article.tags.push(action.tag);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        article.tags = [action.tag];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">article</span>: article &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="在-react-项目中使用-redux"><a href="#在-react-项目中使用-redux" class="headerlink" title="在 react 项目中使用 redux"></a>在 react 项目中使用 redux</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux</span><br><span class="line">npm install --save react-redux</span><br><span class="line">npm install --save-dev redux-devtools</span><br></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><h6 id="在-index-js-文件："><a href="#在-index-js-文件：" class="headerlink" title="在 index.js 文件："></a>在 index.js 文件：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore, applyMiddleware&#125; from &apos;redux&apos;;</span><br><span class="line">import &#123;Provider&#125; from &apos;react-redux&apos;;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;;</span><br><span class="line">import reducers from &apos;./src/reducers/index&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);</span><br><span class="line">const store = createStoreWithMiddleware(reducers);</span><br><span class="line"></span><br><span class="line">const router = (</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;   // 在根组件注入store</span><br><span class="line">    &lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">      &lt;Route path=&quot;/&quot;&gt;</span><br><span class="line">        &lt;IndexRoute component=&#123;Login&#125; /&gt;</span><br><span class="line">        &lt;Route path=&quot;/articles&quot; component=&#123;Articles&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/articledetail&quot; component=&#123;ArticleDetail&#125;/&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ReactDOM.render(router, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure><p>以上： 我们先引入redux和一些函数，再引入写好的 reducer ，<code>createStoreWithMiddleware</code> 函数创建了<br>一个顶级的管理所有状态的储存器，统一管理状态。然后将生成的 store 通过 <code>Provider</code> 组件注入，<br>这样为 <code>Provider</code> 的子组件提供了状态的获取途径。</p><h6 id="reducers"><a href="#reducers" class="headerlink" title="reducers"></a>reducers</h6><p>index文件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; admin &#125; <span class="keyword">from</span> <span class="string">'./admin'</span>;  <span class="comment">//我自己的 reduce 文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; article &#125; <span class="keyword">from</span> <span class="string">"./article"</span>;  <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = combineReducers( &#123;</span><br><span class="line">  admin: admin,</span><br><span class="line">  article: article</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>reduce 文件(示例):<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">"../actions/config"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  logged: <span class="literal">false</span>,</span><br><span class="line">  token: <span class="string">''</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">admin</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Actions.USER_LOGIN: &#123;</span><br><span class="line">      <span class="keyword">let</span> token = action.token;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">logged</span>: <span class="literal">true</span>, <span class="attr">token</span>: token &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Actions.USER_LOGOUT: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">logged</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h6><p>index:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; admin &#125; <span class="keyword">from</span> <span class="string">"./admin"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; article &#125; <span class="keyword">from</span> <span class="string">"./article"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...admin,</span><br><span class="line">  ...article</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>admin action:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">"./config"</span>;   <span class="comment">//储存常量字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: Actions.USER_LOGIN,</span><br><span class="line">    token: token</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logOut</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: Actions.USER_LOGOUT,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> admin = &#123;</span><br><span class="line">  login,</span><br><span class="line">  logOut,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>config：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//user</span></span><br><span class="line">  USER_LOGIN: <span class="string">"USER_LOGIN"</span>,</span><br><span class="line">  USER_LOGOUT:<span class="string">"USER_LOGOUT"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//article</span></span><br><span class="line">  ADD_ARTICLE_TAG: <span class="string">"ADD_ARTICLE_TAG"</span>,</span><br><span class="line">  REMOVE_ARTICLE_TAG: <span class="string">"REMOVE_ARTICLE_TAG"</span>,</span><br><span class="line">  SAVE_CONTENT: <span class="string">"SAVE_CONTENT"</span>,</span><br><span class="line">  EDIT_ARTICLE: <span class="string">"EDIT_ARTICLE"</span>,</span><br><span class="line">  CLEAR: <span class="string">"CLEAR"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//http</span></span><br><span class="line">  GET_PERSONAL_PAGE_INFO: <span class="string">"GET_PERSONAL_PAGE_INFO"</span>,</span><br><span class="line">  GET_USER_INFO: <span class="string">"GET_USER_INFO"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="使用redux"><a href="#使用redux" class="headerlink" title="使用redux"></a>使用redux</h5><blockquote><p>以上步骤已经配置好了。接下来在组件中使用redux</p><p>首先要用到的是高阶函数 <code>connect</code></p></blockquote><p>引入 <code>connect</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br></pre></td></tr></table></figure></p><p>连接：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    logged: store.admin.logged,  <span class="comment">// 这里写你当前组件要用到的redux里的状态</span></span><br><span class="line">    token: store.admin.token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(select)(componentName);  <span class="comment">//componentName 是你的组件名称</span></span><br><span class="line"><span class="comment">//如果不需要redux的数据，可以这样写：</span></span><br><span class="line"><span class="comment">//export default connect()(componentName);</span></span><br></pre></td></tr></table></figure></p><p>这一步把当前组件和 redux 连在一起，把 <code>logged</code>、<code>token</code>传到当前组件的 props 里。<br>需要注意的是：还会隐藏的将 <code>dispatch</code> 方法一起注入到 props </p><p>使用：<br>使用属性的时候，只需要：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.propName</span><br></pre></td></tr></table></figure></p><p>如果要修改状态，不能直接赋值，应该使用在 actions 里的行为来触发 reducer 的纯函数来修改状态：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  login</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../actions/index'</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">this</span>.props.dispatch(login());</span><br></pre></td></tr></table></figure></p><p>这里的 dispatch 意为 分发、派遣、调度，发起一个行为（action），由reducer接收并处理</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>本文只是对redux的一个入门了解，要想学的更深入还是拜读官方文档，或者去看看源码。<br>另外，redux 有一个最佳实践写法，是由阿里前辈推出的 <a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">dva</a> 框架，包含了更多的理解与应用，<br>让redux 强化了处理异步操作的能力。推荐去看看。</p><h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>本文是对自己写博客以及管理后台的时候遇到的问题的总结，有很多问题说的不太对，也没有仔细深究，<br>如果有不对的地方，还请指出。示例代码不详细的话，可以戳<a href="https://github.com/ShiChao1996/BlogAdmin" target="_blank" rel="noopener">这里</a>获取项目源码.</p><h6 id="欢迎来访，手动笔芯"><a href="#欢迎来访，手动笔芯" class="headerlink" title="欢迎来访，手动笔芯~"></a>欢迎来访，手动笔芯~</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redux简介&quot;&gt;&lt;a href=&quot;#redux简介&quot; class=&quot;headerlink&quot; title=&quot;redux简介&quot;&gt;&lt;/a&gt;redux简介&lt;/h3&gt;&lt;p&gt;简单来说，redux 就是帮我们统一管理了 react 组件的 state 状态。&lt;/p&gt;
&lt;p&gt;为
      
    
    </summary>
    
    
      <category term="redux" scheme="http://littlechao.top/tags/redux/"/>
    
      <category term="react" scheme="http://littlechao.top/tags/react/"/>
    
  </entry>
  
</feed>
