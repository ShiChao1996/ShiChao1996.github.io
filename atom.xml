<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://littlechao.top/"/>
  <updated>2018-06-04T14:09:25.638Z</updated>
  <id>http://littlechao.top/</id>
  
  <author>
    <name>Lovae</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IP 地址</title>
    <link href="http://littlechao.top/2018/06/04/ip_addr/"/>
    <id>http://littlechao.top/2018/06/04/ip_addr/</id>
    <published>2018-06-03T16:00:00.000Z</published>
    <updated>2018-06-04T14:09:25.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IP-地址结构"><a href="#IP-地址结构" class="headerlink" title="IP 地址结构"></a>IP 地址结构</h2><blockquote><p>Internet 中使用的网络层地址，又叫 IP 地址。每一个连接到 Internet 的设备至少有一个 IP 地址。IP 地址标志了流量的来源和去向。</p></blockquote><h3 id="IP-地址的表示"><a href="#IP-地址的表示" class="headerlink" title="IP 地址的表示"></a>IP 地址的表示</h3><h4 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h4><p>IPv4 地址本质上是 32 位二进制整数，通常用<strong>点分十进制</strong>表示:</p><table><thead><tr><th style="text-align:left">点分十进制</th><th style="text-align:left">二进制</th></tr></thead><tbody><tr><td style="text-align:left">0.0.0.0</td><td style="text-align:left">00000000 00000000 00000000 00000000</td></tr><tr><td style="text-align:left">1.2.3.4</td><td style="text-align:left">00000001 00000010 00000011 00000100</td></tr></tbody></table><h4 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h4><p>ipv6 地址长度为 128 位，被分为 8 个块表示，每个块包含 4 个十六进制数，块之间用 <code>:</code> 分隔。另外有一些规则:</p><ul><li>一个块中的前到 0 可以省略</li><li>全块的 0 可以用 <code>::</code> 代替。如：0:0:0:0:0:0:0:1 可以写成 ::1。另外 <code>::</code> 只能使用一次，并且只能在 0 最多的地方用，如果有两个一样多连续 0 的地方，前者可以使用 <code>::</code></li><li>在 ipv6 中嵌入 ipv4 地址可以使用混合符号形式。::ffff:10.0.0.1 可以表示 ipv4 地址 10.0.0.1。其中 ipv4地址紧邻 ffff，这被称为 ipv4 映射的 ipv6 地址</li><li>ipv6 地址低 32 位通常采用点分十进制，这被称为 <em>兼容 ipv4 的 ipv6 地址</em></li></ul><p>当 ipv6 地址和端口号一起使用时，<code>:</code> 可能造成歧义，所以用 <code>[]</code> 括起来：<code>http://[::3333:22]:443/</code></p><h3 id="基本的-IP-地址结构"><a href="#基本的-IP-地址结构" class="headerlink" title="基本的 IP 地址结构"></a>基本的 IP 地址结构</h3><h4 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h4><p>IP 地址中，被用于识别连接 Internet 或某些专用的内联网的计算机网络接口的地址，叫做单播地址，还有涉及多个接口或者有特殊用途的地址，包括广播、组播、多播地址。</p><h5 id="分类寻址"><a href="#分类寻址" class="headerlink" title="分类寻址"></a>分类寻址</h5><p>单播 IP 地址都有一个网络部分和一个主机部分，分别被用来识别网络和网络中的主机。IP 地址呗分为如下五大类：</p><p><img src="/images/ip/ip_class.png" alt=""></p><p>更形象一点如图：</p><p><img src="/images/ip/ip_class_pie_chart.png" alt=""></p><p>但是要注意的是，每个网络里的主机号，全 0 和全 1 的不能被分配给某个主机。全 1 的作为这个子网的广播地址使用。</p><h5 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h5><p>A 类地址的主机数量为 2^24 - 2，B 类地址的主机数量为 2^16 - 2，C 类地址为 2^8 - 2。实际上很难分配到一个大小合适的网络，于是在分类基础上加了子网的概念。</p><p><img src="/images/ip/sub_net.png" alt=""></p><p>如图，把一个 B 类地址的主机号 ‘借’ 出 8 位作为子网号的例子，这样把一个网络划分出来若干子网，以此来得到一个合适大小的网络。</p><h5 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h5><p>为了能够从 IP 地址中知道主机号中哪些是子网号，哪些是主机号，使用了一个 32 位二进制的子网掩码。它的每一位和 IP 地址一一对应，子网掩码某一位为 1 代表对应 IP 地址那一位不是主机号。</p><p><img src="/images/ip/subnet_mask.png" alt=""></p><p>写的时候为了简单，把 IP 地址和子网掩码 1 的位数写在一起，如：<code>128.3.4.5/23</code>。</p><p>要注意，只有划分子网内部路由器和主机知道子网结构，在需要子网寻址之前，互联网其他部分仍把它作为站点相关的地址来看。来看一个例子：</p><p><img src="/images/ip/subnet_example.png" alt=""></p><h5 id="可变长度子网掩码"><a href="#可变长度子网掩码" class="headerlink" title="可变长度子网掩码"></a>可变长度子网掩码</h5><p>Variable Length Subnet Mask, VLSM。在同一站点的不同部分，可以将不同长度的子网掩码应用于相同网络号。增加了配置的复杂性但是也提高了子网结构的灵活性。如图，三个不同掩码被用于 128.32.0.0/16 ，每个子网可以有不同数量的主机：</p><p><img src="/images/ip/vlsm_example.png" alt=""></p><h3 id="CIDR-和聚合"><a href="#CIDR-和聚合" class="headerlink" title="CIDR 和聚合"></a>CIDR 和聚合</h3><p>划分子网缓解了增长带来的痛苦，但是随着互联网规模增长，路由表的条目数越来越多，路由性能受到影响。</p><h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><p>为了缓解 v4 地址的压力，分类寻址采用了类似于 VLSM 的方案，<strong>无类别域间路由（Classless Inter-Domain Router, CIDR）</strong>。使用 CIDR，任何没有预定义的地址都可以作为同一个类的一部分，就是说，B 类地址和 C 类地址可以在同一个类。</p><p>注意，和普通子网掩码不同的是，CIDR 的掩码不仅限于一个站点，而是全球路由可见的。核心 Internet 路由器必须能够解释和处理 CIDR 掩码。 IP 地址加上一个 0~32 的数字，称为前缀，代表一个子网。</p><table><thead><tr><th style="text-align:left">前缀</th><th style="text-align:left">地址范围</th></tr></thead><tbody><tr><td style="text-align:left">0.0.0.0/0</td><td style="text-align:left">0.0.0.0 ~ 255.255.255.255</td></tr><tr><td style="text-align:left">128.0.0.0/1</td><td style="text-align:left">128.0.0.0 ~ 255.255.255.255</td></tr><tr><td style="text-align:left">128.0.0.0/24</td><td style="text-align:left">128.0.0.0 ~ 128.0.0.255</td></tr></tbody></table><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>前缀并没有解决路由表性能问题，但是可以把多条路由聚合成一条，以此减轻路由器压力。把网络拓扑排成一棵树，按照分层结构的思想来分配地址，可以在保证最短路由的情况下减少路由器路由条目。</p><p>下图是一个随意排布的、路由与位置无关的结构（a, 左图）和拓扑敏感的、位置与路由相关的结构（b, 右图），每个圆点代表路由器：</p><p><img src="/images/ip/cidr_gather.png" alt=""></p><p>两者最大的区别在于，a 中顶层路由节点为了能够路由到下面 8 个节点，需要储存 9 条（加上 other Parts 那一条）路由信息；而 b 中顶层节点只需要存储 3 条（同上）。</p><p>关键在于，b 把多条路由信息聚合成一条。聚合是把多个相邻的 IP 前缀合并成一个短前缀。</p><p><img src="/images/ip/ip_gather.png" alt=""></p><p>注意，只有连续的、数值相邻的地址才能被聚合，如果中间有一条地址不在此列，那么不能聚合。</p><h3 id="特殊用途地址"><a href="#特殊用途地址" class="headerlink" title="特殊用途地址"></a>特殊用途地址</h3><h4 id="IPv4-和-IPv6-转换"><a href="#IPv4-和-IPv6-转换" class="headerlink" title="IPv4 和 IPv6 转换"></a>IPv4 和 IPv6 转换</h4><p>IPv4 和 IPv6 转换时，采用特殊地址，称为<strong>嵌入 IPv4 的 IPv6 地址</strong>，如下，IPv6 前缀必须是以下之一：</p><p><img src="/images/ip/v4_to_v6.png" alt=""></p><p>其中，63~71 对应的 U 必须为 0。</p><h4 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h4><p>。。。</p><p>我不会</p><p>。。。</p><p>没看懂</p><p>。。。</p><p><img src="/images/ip/hehe.gif" alt="我不会"></p><h3 id="地址分配"><a href="#地址分配" class="headerlink" title="地址分配"></a>地址分配</h3><p>IP 地址被分配为较大的块，由一些权威组织负责。这些权威机构给一些小型机构或者大型 ISP (Internet Service Provider) 分配 IP 地址。用户通常以地址前缀形式使用 ISP 地址空间，这些地址范围由 ISP 管理，被称为<strong>供应商聚合地址（PA）</strong>，可以和 ISP 的其他地址前缀聚合。但同时，这些地址是不可移植的。</p><p>另一种可选的地址空间类型称为<strong>供应商独立（PI）的地址空间</strong>，这些地址可以直接分配给用户，并且任何 ISP 都可以使用，但是通常和 ISP 的地址数值不相邻，所以不能聚合。</p><p>下面看一下一个站点分配了单播地址后的一些可能的场景</p><h4 id="单供应商-无网络-单个地址"><a href="#单供应商-无网络-单个地址" class="headerlink" title="单供应商/无网络/单个地址"></a>单供应商/无网络/单个地址</h4><p>这种情况最简单，ISP 分配了一个 IP 地址，然后通过网线连接到一台主机，这里没有形成网络。但这太主机还有其他的 IP 地址，包括本地环回的 127.0.0.1  或者 ::1</p><p>####单供应商/单个网络/单个地址 </p><p>这种场景大多是家庭局域网（LAN）或无线局域网（WLAN），由一台路由器连接 Internet。虽然每个连接到路由器的设备都被分配到一个 IP 地址，但是都是私有的，由 NAT 做转换，对于 ISP 来看，仍然只有一个地址。</p><h4 id="单供应商-多个网络-多个地址"><a href="#单供应商-多个网络-多个地址" class="headerlink" title="单供应商/多个网络/多个地址"></a>单供应商/多个网络/多个地址</h4><p>对应组织或者小型公司来说，一个 IP 地址，特别是当它只是临时分配的不固定的地址时，是不满足需求的。</p><p><img src="/images/ip/middle_net.png" alt=""></p><p>图中 DMZ 表示<em>非军事区</em>，在主防火墙之外，拥有公网地址，可以被互联网连接。</p><p>####多供应商/多个网络/多个地址</p><p>对于一些大型企业，通常使用多个 ISP 以便在失效时提供冗余连接。通常来说，只有一个 ISP 的组织拥有该 ISP 关联的 PA 地址。多个 ISP 的组织，可能有多个不能互相聚合的 PA 地址，或者 PA 地址 + PI 地址。这里讨论一下 <code>PA + PI</code> 的场景。</p><p><img src="/images/ip/multi_isp.png" alt=""></p><p>这里 C、D 相当于两个站点边界路由器，分别拥有一个 PA 地址和一个 PI 地址。</p><p>如果站点使用 PA 地址空间，那么 ISP P1 可以聚合该地址，而 P2 不能。本质上 P1 和 P2 都可以到达 12.46.129.1，但从互联网其他部分过来的流量偏向于经过 P2，因为 P2 的路由路径更长，路由器采用<em>最长匹配前缀</em>来计算路由。</p><p>如果站点采用 PI 地址空间，则相对公平，因为 P1 和 P2 都无法聚合路由。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IP-地址结构&quot;&gt;&lt;a href=&quot;#IP-地址结构&quot; class=&quot;headerlink&quot; title=&quot;IP 地址结构&quot;&gt;&lt;/a&gt;IP 地址结构&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Internet 中使用的网络层地址，又叫 IP 地址。每一个连接到 In
      
    
    </summary>
    
      <category term="IP" scheme="http://littlechao.top/categories/IP/"/>
    
    
      <category term="IP" scheme="http://littlechao.top/tags/IP/"/>
    
  </entry>
  
  <entry>
    <title>Go http server (III)</title>
    <link href="http://littlechao.top/2018/06/02/go_http_server_3/"/>
    <id>http://littlechao.top/2018/06/02/go_http_server_3/</id>
    <published>2018-06-01T16:00:00.000Z</published>
    <updated>2018-06-02T07:30:10.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GO-http-server-III-组建简易-HTTP-Server-框架"><a href="#GO-http-server-III-组建简易-HTTP-Server-框架" class="headerlink" title="GO http server (III) 组建简易 HTTP Server 框架"></a>GO http server (III) 组建简易 HTTP Server 框架</h2><blockquote><p>上篇提到 DefaultServerMux 作为默认的 HTTP Server 框架太过简单，缺少很多功能。这篇我们利用官方库和一些三方库来定制一个简易合用的 HTTP Server 框架。完整代码见<a href="https://github.com/TechcatsLab/apix" target="_blank" rel="noopener">这里</a></p></blockquote><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>首先要有 router 模块，这里我使用第三方 gorilla 框架的最小化路由模块 mux，它的作用和 DefaultServerMux 差不多，只不过支持了 RESTful API。</p><p>在添加路由和对应 handler 时，很可能我们写的处理函数有 bug，导致没有往 response 里写入内容就返回，这会造成客户端阻塞等待，所以当出现错误提前返回时，需要一个默认的错误处理函数，给客户端返回默认错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"github.com/gorilla/mux"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Router <span class="keyword">struct</span> &#123;</span><br><span class="line">   router     *mux.Router</span><br><span class="line">   ctxPool    sync.Pool</span><br><span class="line">   errHandler <span class="function"><span class="keyword">func</span><span class="params">(w http.responseWriter, r *http.request)</span> </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>很多时候，执行路由对应 handler 时我们并不想直接操作 http.responseWriter 和 *http.request，并且希望有一些简单的封装，提供更多的功能。再者，这两个对象并不能很好的携带中间件处理过程中产生的一些参数。所以我们会定义一个 Context （下一节）来封装它们。每一个请求都应该有一个 Context，为了方便的管理，使用 sync.Pool 做一个 context 池。</p><p>创建新的 Router：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewRouter returns a router.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRouter</span><span class="params">()</span> *<span class="title">Router</span></span> &#123;</span><br><span class="line">   r := &amp;Router&#123;</span><br><span class="line">      router:     mux.NewRouter(),</span><br><span class="line">      errHandler: <span class="function"><span class="keyword">func</span><span class="params">(_ *Context)</span></span> &#123;&#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   r.ctxPool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">      <span class="keyword">return</span> NewContext(<span class="literal">nil</span>, <span class="literal">nil</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   r.router.NotFoundHandler = http.NotFoundHandler()</span><br><span class="line">   r.router.MethodNotAllowedHandler = MethodNotAllowedHandler()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>router 注册路由，由于使用 gorilla.mux，调用其 HandleFunc ，返回 router 本身，在调用 Method 即可指定请求方法。不过我们还可以在自己的 handler 执行之前，提供一些钩子，这里我们可以添加一些 filter 函数，以便功能扩展。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FilterFunc <span class="function"><span class="keyword">func</span><span class="params">(*Context)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(rt *Router)</span> <span class="title">Get</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc, filters ...FilterFunc)</span></span> &#123;</span><br><span class="line">   rt.router.HandleFunc(pattern, rt.wrapHandlerFunc(handler, filters...)).Methods(<span class="string">"GET"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Post adds a route path access via POST method.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *Router)</span> <span class="title">Post</span><span class="params">(pattern <span class="keyword">string</span>, handler HandlerFunc, filters ...FilterFunc)</span></span> &#123;</span><br><span class="line">   rt.router.HandleFunc(pattern, rt.wrapHandlerFunc(handler, filters...)).Methods(<span class="string">"POST"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wraps a HandlerFunc to a http.HandlerFunc.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *Router)</span> <span class="title">wrapHandlerFunc</span><span class="params">(f HandlerFunc, filters ...FilterFunc)</span> <span class="title">http</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">      c := rt.ctxPool.Get().(*Context)</span><br><span class="line">      <span class="keyword">defer</span> rt.ctxPool.Put(c)</span><br><span class="line">      c.Reset(w, r)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">len</span>(filters) &gt; <span class="number">0</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> _, filter := <span class="keyword">range</span> filters &#123;</span><br><span class="line">            <span class="keyword">if</span> passed := filter(c); !passed &#123;</span><br><span class="line">               c.LastError = errFilterNotPassed</span><br><span class="line">               <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> err := f(c); err != <span class="literal">nil</span> &#123;</span><br><span class="line">         c.LastError = err</span><br><span class="line">         rt.errHandler(c)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>前面提到可以用一个 Context 包装 http.responseWriter 和 *http.request，并且提供一些额外的功能。额外的功能如 validator，用来对请求做参数验证。这个 validator 我们可以直接用一个第三方库，也可以做成 Interface 以便升级。</p><p>另外我们可能需要 Context 能够携带额外的信息，所以可以加一个 map 用来存储。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">struct</span> &#123;</span><br><span class="line">   responseWriter http.ResponseWriter</span><br><span class="line">   request        *http.Request</span><br><span class="line">   Validator      *validator.Validate</span><br><span class="line">   store          <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要忘了在 Router 里面我们是用一个线程安全的池来管理 context ，也就是每次用完 context 需要还回去来避免临时分配带来的开销。所以别忘了还回去之前需要把 context 重置成原来的样子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Reset</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   c.responseWriter = w</span><br><span class="line">   c.request = r</span><br><span class="line">   c.store = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>有了 router 和 context，我们还需要封装一个 server。首先定义一个 EntryPoiont 结构体，当然名字随意。非常确认的是我们需要用到 http 包的 Server，还可以加上可能用到的 net.Listener。另外，我们需要方便的添加一些即插即用的工具，所以需要中间件，这里我使用第三方库 negroni 。然后我们可能需要一个通知关闭所有连接的机制，用一个 channel 可以做到。所以 EntryPoint 大致如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Entrypoint <span class="keyword">struct</span> &#123;</span><br><span class="line">   server        *http.Server</span><br><span class="line">   listener      net.Listener</span><br><span class="line">   middlewares   []negroni.Handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="negroni"><a href="#negroni" class="headerlink" title="negroni"></a>negroni</h4><p>其实 negroni 的核心代码也很简单，就只是把多个 middleware 串起来使其能够串行调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Negroni <span class="keyword">struct</span> &#123;</span><br><span class="line">   middleware middleware</span><br><span class="line">   handlers   []Handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> middleware <span class="keyword">struct</span> &#123;</span><br><span class="line">handler Handler</span><br><span class="line">next    *middleware</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键就是 Handler 接口，所有第三方实现的中间件要和 negroni 一起用的话，都要实现它，并且每个中间件执行完自己的功能后，要去调用 next 触发下一个中间件的执行。</p><p>添加中间件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Negroni)</span> <span class="title">Use</span><span class="params">(handler Handler)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">"handler cannot be nil"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   n.handlers = <span class="built_in">append</span>(n.handlers, handler)</span><br><span class="line">   n.middleware = build(n.handlers)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">build</span><span class="params">(handlers []Handler)</span> <span class="title">middleware</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> next middleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(handlers) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> voidMiddleware()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span>(handlers) &gt; <span class="number">1</span> &#123;</span><br><span class="line">next = build(handlers[<span class="number">1</span>:])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">next = voidMiddleware()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> middleware&#123;handlers[<span class="number">0</span>], &amp;next&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加中间件的时候，递归地调用 build ，把所有 middlewares 串起来。必然的，negroni 实现了 http.Handler 接口，这使得 Negroni 可以当做 http.Handler 传给 Server.Serve()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Negroni)</span> <span class="title">ServeHTTP</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">   n.middleware.ServeHTTP(NewResponseWriter(rw), r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m middleware)</span> <span class="title">ServeHTTP</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">m.handler.ServeHTTP(rw, r, m.next.ServeHTTP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整合-router"><a href="#整合-router" class="headerlink" title="整合 router"></a>整合 router</h4><p>当所有中间件执行完了以后，应该把 context 传给 router 去执行对应的路由，所以把 router 作为最后一个中间件传到 negroni 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ep *Entrypoint)</span> <span class="title">buildRouter</span><span class="params">(router http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">n := negroni.New()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, mw := <span class="keyword">range</span> ep.middlewares &#123;</span><br><span class="line">n.Use(mw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n.Use(negroni.Wrap(http.HandlerFunc(router.ServeHTTP)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然在启动 Server.Serve() 之前，还要把 ep.buildRouter 返回的对象赋给 ep.Server.Handler，使这个对象代替 DefaultServerMux。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ep *Entrypoint)</span> <span class="title">prepare</span><span class="params">(router http.Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> (</span><br><span class="line">      err       error</span><br><span class="line">      listener  net.Listener</span><br><span class="line">   ）</span><br><span class="line"></span><br><span class="line">   listener, err = net.Listen(<span class="string">"tcp"</span>, ep.configuration.Address)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ep.listener = listener</span><br><span class="line">   ep.server = &amp;http.Server&#123;</span><br><span class="line">      Addr:      ep.configuration.Address,</span><br><span class="line">      Handler:   ep.buildRouter(router),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就可以调用 start 跑起服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ep *Entrypoint)</span> <span class="title">Start</span><span class="params">(router http.Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> router == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> errNoRouter</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> err := ep.prepare(router); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">go</span> ep.startServer()</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"Serving on:"</span>, ep.configuration.Address)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中间件封装"><a href="#中间件封装" class="headerlink" title="中间件封装"></a>中间件封装</h3><p>有的时候有一些现成的中间件，但是不能直接放到 negroni 里面用，就需要我们给它加一层封装。</p><p>例如，我们要做 jwt 验证，使用第三方的 <em>jwtmiddleware.JWTMiddleware，但是有的路径我们不需要 token，需要跳过 jwt 中间件。不方便改别人的代码，可以这样封装来代替原来的 </em>jwtmiddleware.JWTMiddleware：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Skipper <span class="function"><span class="keyword">func</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">JWTMiddleware</span> <span class="title">is</span> <span class="title">a</span> <span class="title">wrapper</span> <span class="title">of</span> <span class="title">go</span>-<span class="title">jwt</span>-<span class="title">middleware</span>, <span class="title">but</span> <span class="title">added</span> <span class="title">a</span> <span class="title">skipper</span> <span class="title">func</span> <span class="title">on</span> <span class="title">it</span>.</span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">JWTMiddleware</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">   *jwtmiddleware.JWTMiddleware</span><br><span class="line">   skipper Skipper</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <em>jwtmiddleware.JWTMiddleware 作为一个匿名变量，这样可以在自定义的 JWTMiddleware 上直接调用 </em>jwtmiddleware.JWTMiddleware 的函数。然后用 handler 函数覆盖原有的 HandlerWithNext 函数，这样就能通过调用时传入的 skipper 函数判断是否需要跳过 jwt：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jm *JWTMiddleware)</span> <span class="title">handler</span><span class="params">(w http.ResponseWriter, r *http.Request, next http.HandlerFunc)</span></span> &#123;</span><br><span class="line">   path := r.URL.Path</span><br><span class="line">   <span class="keyword">if</span> skip := jm.skipper(path); skip &#123;</span><br><span class="line">      next(w, r)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   jm.HandlerWithNext(w, r, next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后用 negroni 包装一下，使它能够直接被 negroni 使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NegroniJwtHandler</span><span class="params">(key <span class="keyword">string</span>, skipper Skipper, signMethod *jwt.SigningMethodHMAC, errHandler <span class="keyword">func</span>(w http.ResponseWriter, r *http.Request, err <span class="keyword">string</span>)</span>) <span class="title">negroni</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> signMethod == <span class="literal">nil</span> &#123;</span><br><span class="line">      signMethod = jwt.SigningMethodHS256</span><br><span class="line">   &#125;</span><br><span class="line">   jm := jwtmiddleware.New(jwtmiddleware.Options&#123;</span><br><span class="line">      ValidationKeyGetter: <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line">         <span class="keyword">return</span> []<span class="keyword">byte</span>(key), <span class="literal">nil</span></span><br><span class="line">      &#125;,</span><br><span class="line">      SigningMethod: signMethod,</span><br><span class="line">      ErrorHandler:  errHandler,</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> skipper == <span class="literal">nil</span> &#123;</span><br><span class="line">      skipper = defaulSkiper</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   JM := JWTMiddleware&#123;</span><br><span class="line">      jm,</span><br><span class="line">      skipper,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> negroni.HandlerFunc(JM.handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前为止我们实现了一个简易通用的 HTTP server 框架，虽然功能还不是很完善，不过好在可扩展性比较高，我们可以在此基础上任意扩展，可以添加上缓存、数据库、监控等等模块。</p><p>如果有兴趣的话，可以去看看 echo 的实现，其实也是大同小异。</p><p>最后，再放一遍项目<a href="https://github.com/TechCatsLab/apix" target="_blank" rel="noopener">地址</a>，还有一些别的库，欢迎 star 和 pr 啦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GO-http-server-III-组建简易-HTTP-Server-框架&quot;&gt;&lt;a href=&quot;#GO-http-server-III-组建简易-HTTP-Server-框架&quot; class=&quot;headerlink&quot; title=&quot;GO http server (
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go http server (II)</title>
    <link href="http://littlechao.top/2018/06/01/go_http_server_2/"/>
    <id>http://littlechao.top/2018/06/01/go_http_server_2/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2018-06-02T07:30:40.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GO-http-server-II-Server-Handler"><a href="#GO-http-server-II-Server-Handler" class="headerlink" title="GO http server (II) Server.Handler"></a>GO http server (II) Server.Handler</h2><blockquote><p> 上一篇里讨论了 go 官方库里提供的 http 服务框架，使用者需要关心的是 Server 的 handler 域。当 Server 调用 Serve 函数时 Server.Handler 为 nil，则默认使用 http.DefaultServeMux 作为 handler。</p></blockquote><h3 id="DefaultServeMux"><a href="#DefaultServeMux" class="headerlink" title="DefaultServeMux"></a>DefaultServeMux</h3><p>来看一下它的定义和描述：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServeMux is an HTTP request multiplexer.</span></span><br><span class="line"><span class="comment">// It matches the URL of each incoming request against a list of registered</span></span><br><span class="line"><span class="comment">// patterns and calls the handler for the pattern that</span></span><br><span class="line"><span class="comment">// most closely matches the URL.</span></span><br></pre></td></tr></table></figure><p>简单的说，它就是一个路由分发器。</p><h5 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">mu    sync.RWMutex</span><br><span class="line">m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">  <span class="comment">//路由规则，一个string对应一个mux实例对象，map的key就是注册的路由表达式(string类型的)</span></span><br><span class="line">hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123; <span class="comment">// 代表着一个 路由-处理函数 组合</span></span><br><span class="line">explicit <span class="keyword">bool</span> <span class="comment">//表示 patern 是否已经被明确注册过了</span></span><br><span class="line">h        Handler</span><br><span class="line">pattern  <span class="keyword">string</span> <span class="comment">//路由表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前提到过，Server.Handler 需要有路由功能，并且可以执行路由对应的处理函数。当注册路由时，调用<code>mux.Handle</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">mux.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: invalid pattern "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mux.m[pattern].explicit &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">&#125;</span><br><span class="line">mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">mux.hosts = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下是很有用的功能:当pattern == “/tree/”时,</span></span><br><span class="line">  <span class="comment">// 会插入一条永久的重定向到“/tree”,注意最后的斜杠。</span></span><br><span class="line">  <span class="comment">// 当然前提是在这之前没有“/tree”这条路由</span></span><br><span class="line">n := <span class="built_in">len</span>(pattern)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; pattern[n<span class="number">-1</span>] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]].explicit &#123;</span><br><span class="line"><span class="comment">//如果包含host，</span></span><br><span class="line">path := pattern</span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line"><span class="comment">// In pattern, at least the last character is a '/', so</span></span><br><span class="line"><span class="comment">// strings.Index can't be -1.</span></span><br><span class="line">path = pattern[strings.Index(pattern, <span class="string">"/"</span>):]</span><br><span class="line">&#125;</span><br><span class="line">url := &amp;url.URL&#123;Path: path&#125;</span><br><span class="line">mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码挺多，其实主要就做了一件事，向<code>DefaultServeMux</code>的<code>map[string]muxEntry</code>中增加对应的路由规则和<code>handler</code>。注意这里每条路由并没有包含我们常说的 GET、POST 等等区别，主要有两个原因：一是为了简洁，很多开发者偏好不同的处理方法，官方库只提供最基本的功能；二是不直接和请求方法绑定起来便于写 RESTful API。</p><p>但是这里还要注意路径结尾的<code>/</code>,这时候该路径为一个子树，如果能完全匹配到其子路由，那么也能匹配到这个子树，不过路由越长，优先级越大；如果不能完全匹配到其子路由，会匹配到这个子树的路由。比如有一个根路由<code>/</code>、<code>/example/</code>和 <code>/example/1</code>，那么访问<code>/example/2</code>时，会匹配到<code>/example/</code>，访问<code>/nothing</code>会匹配到<code>/</code>。</p><h5 id="处理路由请求"><a href="#处理路由请求" class="headerlink" title="处理路由请求"></a>处理路由请求</h5><p>注册好路由，并且没有使用别的 handler 时，DefaultServerMux 的 ServeHTTP 就会在接收到 request 时被调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">   handler := sh.srv.Handler</span><br><span class="line">   <span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">      handler = DefaultServeMux </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">      handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServeHTTP 主要从之前注册好的路由表中获取对应的 handler：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   h, _ := mux.Handler(r) <span class="comment">// 匹配和 request 最接近的路由，拿到对应的 handler</span></span><br><span class="line">   h.ServeHTTP(w, r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handler</span><span class="params">(r *Request)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   host := stripHostPort(r.Host)</span><br><span class="line">   path := cleanPath(r.URL.Path)</span><br><span class="line">   <span class="keyword">if</span> path != r.URL.Path &#123;</span><br><span class="line">      _, pattern = mux.handler(host, path)</span><br><span class="line">      url := *r.URL</span><br><span class="line">      url.Path = path</span><br><span class="line">      <span class="keyword">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class="line">      <span class="comment">//注意这里的重定向 handler</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> mux.handler(host, r.URL.Path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">handler</span><span class="params">(host, path <span class="keyword">string</span>)</span> <span class="params">(h Handler, pattern <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">mux.mu.RLock()</span><br><span class="line"><span class="keyword">defer</span> mux.mu.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Host-specific pattern takes precedence over generic ones</span></span><br><span class="line"><span class="keyword">if</span> mux.hosts &#123;</span><br><span class="line">h, pattern = mux.match(host + path)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">h, pattern = mux.match(path) <span class="comment">// match 做的是字符串匹配的工作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">h, pattern = NotFoundHandler(), <span class="string">""</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在没有找到匹配的路由时，返回 NotFoundHandler， 默认只是写入 404 not found，但通常我们会自定义它，然后返回一个专门的好看的 404 页面。</p><p>如果需要重定向，则会通过返回的 redirectHandler 调用 Redirect：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Redirect</span><span class="params">(w ResponseWriter, r *Request, url <span class="keyword">string</span>, code <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> u, err := parseURL(url); err == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// If url was relative, make absolute by</span></span><br><span class="line">      <span class="comment">// combining with request path.</span></span><br><span class="line">      <span class="comment">// The browser would probably do this for us,</span></span><br><span class="line">      <span class="comment">// but doing it ourselves is more reliable.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// NOTE(rsc): RFC 2616 says that the Location</span></span><br><span class="line">      <span class="comment">// line must be an absolute URI, like</span></span><br><span class="line">      <span class="comment">// "http://www.google.com/redirect/",</span></span><br><span class="line">      <span class="comment">// not a path like "/redirect/".</span></span><br><span class="line">      <span class="comment">// Unfortunately, we don't know what to</span></span><br><span class="line">      <span class="comment">// put in the host name section to get the</span></span><br><span class="line">      <span class="comment">// client to connect to us again, so we can't</span></span><br><span class="line">      <span class="comment">// know the right absolute URI to send back.</span></span><br><span class="line">      <span class="comment">// Because of this problem, no one pays attention</span></span><br><span class="line">      <span class="comment">// to the RFC; they all send back just a new path.</span></span><br><span class="line">      <span class="comment">// So do we.</span></span><br><span class="line">      <span class="keyword">if</span> u.Scheme == <span class="string">""</span> &amp;&amp; u.Host == <span class="string">""</span> &#123;</span><br><span class="line">         oldpath := r.URL.Path</span><br><span class="line">         <span class="keyword">if</span> oldpath == <span class="string">""</span> &#123; <span class="comment">// should not happen, but avoid a crash if it does</span></span><br><span class="line">            oldpath = <span class="string">"/"</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// no leading http://server</span></span><br><span class="line">         <span class="keyword">if</span> url == <span class="string">""</span> || url[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">            <span class="comment">// make relative path absolute</span></span><br><span class="line">            olddir, _ := path.Split(oldpath)</span><br><span class="line">            url = olddir + url</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">var</span> query <span class="keyword">string</span></span><br><span class="line">         <span class="keyword">if</span> i := strings.Index(url, <span class="string">"?"</span>); i != <span class="number">-1</span> &#123;</span><br><span class="line">            url, query = url[:i], url[i:]</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// clean up but preserve trailing slash</span></span><br><span class="line">         trailing := strings.HasSuffix(url, <span class="string">"/"</span>)</span><br><span class="line">         url = path.Clean(url)</span><br><span class="line">         <span class="keyword">if</span> trailing &amp;&amp; !strings.HasSuffix(url, <span class="string">"/"</span>) &#123;</span><br><span class="line">            url += <span class="string">"/"</span></span><br><span class="line">         &#125;</span><br><span class="line">         url += query</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   w.Header().Set(<span class="string">"Location"</span>, hexEscapeNonASCII(url))</span><br><span class="line">   w.WriteHeader(code)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// RFC 2616 recommends that a short note "SHOULD" be included in the</span></span><br><span class="line">   <span class="comment">// response because older user agents may not understand 301/307.</span></span><br><span class="line">   <span class="comment">// Shouldn't send the response for POST or HEAD; that leaves GET.</span></span><br><span class="line">   <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">      note := <span class="string">"&lt;a href=\""</span> + htmlEscape(url) + <span class="string">"\"&gt;"</span> + statusText[code] + <span class="string">"&lt;/a&gt;.\n"</span></span><br><span class="line">      fmt.Fprintln(w, note)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，DefaultServerMux 只有一个最基本的路由功能，是一个最简单的 HTTP 服务框架。可是这通常不能满足我们的需求，于是我们可以根据我们自己的需要自定义一个简单通用的 HTTP Server 框架。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GO-http-server-II-Server-Handler&quot;&gt;&lt;a href=&quot;#GO-http-server-II-Server-Handler&quot; class=&quot;headerlink&quot; title=&quot;GO http server (II) Server.H
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go http server (I)</title>
    <link href="http://littlechao.top/2018/05/29/go_http_server_1/"/>
    <id>http://littlechao.top/2018/05/29/go_http_server_1/</id>
    <published>2018-05-28T16:00:00.000Z</published>
    <updated>2018-06-02T07:30:40.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go-http-server-I-源码阅读"><a href="#Go-http-server-I-源码阅读" class="headerlink" title="Go http server (I) 源码阅读"></a>Go http server (I) 源码阅读</h2><blockquote><p>这个系列会写三到四篇文章，第一篇是 go sdk 里 net/http/server.go 的阅读笔记，之后会写一下如何利用 server.go 的接口自定义一个简易通用的 HTTP server 框架。</p></blockquote><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>先从一个简单的例子开始吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启web服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">// 注意这里第二个参数为 nil</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"ListenAndServer:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Hello Guest!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，此时浏览器访问<code>localhost:9090</code>就会看到输出 “Hello Guest!”，其实访问<code>localhost:9090/</code>+任意字符串，都能得到结果。这段代码先用<code>http.HandleFunc</code>注册了一个处理函数，然后调用<code>http.ListenAndServe</code>监听端口，当有请求到来时，会根据访问路径找到并执行对应的处理函数。</p><p>我们通常还能看到另一种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启web服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.Handle(<span class="string">"/"</span>, &amp;handler&#123;&#125;)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"ListenAndServer:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">sayHello(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码效果一样。区别就是<code>http.HandleFunc</code>和<code>http.Handle</code>需要的第二个参数，前者要一个<code>func (w http.ResponseWriter, r *http.Request)</code>函数，后者要一个实现了该函数的结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123; DefaultServeMux.Handle(pattern, handler) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，两个函数都会调用<code>mux.handle</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span></span><br></pre></td></tr></table></figure><p>第二个参数是Handler，是一个接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回到上面的<code>HandleFunc</code>,注意这个：<code>HandlerFunc(handler)</code>,这里很容易让人误以为HandlerFunc是一个函数并且包装了传入的handler，再返回一个<code>Handler</code>类型。而实际上这里是<strong>类型转换</strong>，来看HandlerFunc的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ServeHTTP</span> <span class="title">calls</span> <span class="title">f</span><span class="params">(w, r)</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>HandlerFunc</code>的类型是一个函数，但它是一种类型，因为是以<code>type</code>来定义而不是<code>func</code>，并且实现了<code>ServeHTTP(w ResponseWriter, r *Request)</code>，在这个函数里，它又调用了自身。这个细节是十分重要的，因为这一步关乎到当路由规则匹配时，相应的响应方法是否会被调用的问题！这里的类型转换用法使一个函数自身实现了一个接口，就不用每次都要先写一个本身无用结构体，再用结构体实现接口。请仔细体会这种技巧！</p><p>。。。有点扯偏了，这里记住 Handler 这个接口是 go 语言 HTTP 服务最最最重要的接口，官方库和第三方库都按照这个接口来扩展。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>来看一下 Server 这个结构体吧, 这里我只列出了几个核心的域：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">Addr      <span class="keyword">string</span>      <span class="comment">// TCP address to listen on, ":http" if empty</span></span><br><span class="line">Handler   Handler     <span class="comment">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class="line">TLSConfig *tls.Config <span class="comment">// optional TLS config, used by ServeTLS and ListenAndServeTLS</span></span><br><span class="line"></span><br><span class="line">listeners  <span class="keyword">map</span>[net.Listener]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">onShutdown []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4><p>这里主要关注 Handler，这个 Handler 就是刚刚的那个接口，可以在创建 Server 时传入，也可以在调用 Server.ListenAndServe 时传入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListenAndServe</span><span class="params">(addr <span class="keyword">string</span>, handler Handler)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class="line"><span class="keyword">return</span> server.ListenAndServe()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个 handler 是在建立连接后收到客户端请求时用到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123; <span class="comment">// conn 指当前连接</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">w, err := c.readRequest(ctx)</span><br><span class="line">...</span><br><span class="line">serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> serverHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">srv *Server</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">handler := sh.srv.Handler</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">handler = DefaultServeMux</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> req.RequestURI == <span class="string">"*"</span> &amp;&amp; req.Method == <span class="string">"OPTIONS"</span> &#123;</span><br><span class="line">handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 serverHandler 的 ServeHTTP 函数可以看到，当 server.handler==nil 时，使用内部全局变量，也就是前面提到过的 DefaultServeMux。也就是说，我们在收到请求时通过这个 handler 来执行自己的逻辑代码，所以这个 handler 必须包含路由功能，并且能够执行路由对应的处理函数。同时我们用的第三方 HTTP server 框架(echo、beego…)也是通过自定义 handler 来实现功能扩展。这也是 Handler 这个接口是最最重要的接口的原因。</p><p>关于 DefaultServeMux 和 自定义的 handler，会在之后详细讨论。接下来回到 Server 本身。</p><h4 id="Server-Serve"><a href="#Server-Serve" class="headerlink" title="Server.Serve"></a>Server.Serve</h4><p>在主函数中可以调用 http.ListenAndServe 或者 http.Serve 来开始 HTTP 服务， 原理都一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">ListenAndServe</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">addr := srv.Addr</span><br><span class="line"><span class="keyword">if</span> addr == <span class="string">""</span> &#123;</span><br><span class="line">addr = <span class="string">":http"</span></span><br><span class="line">&#125;</span><br><span class="line">ln, err := net.Listen(<span class="string">"tcp"</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看下 srv.Serve 的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> l.Close()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> tempDelay time.Duration <span class="comment">// how long to sleep on accept failure</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := srv.setupHTTP2_Serve(); err != <span class="literal">nil</span> &#123;<span class="comment">// 如果设置了 http2，就使用 http2 服务，</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">baseCtx := context.Background() <span class="comment">// base is always background, per Issue 16220</span></span><br><span class="line">ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">rw, e := l.Accept() <span class="comment">// 这里会等待新的连接的建立，会阻塞在这里。</span></span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-srv.getDoneChan():</span><br><span class="line"><span class="keyword">return</span> ErrServerClosed</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line"><span class="keyword">if</span> tempDelay == <span class="number">0</span> &#123;</span><br><span class="line">tempDelay = <span class="number">5</span> * time.Millisecond</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tempDelay *= <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> max := <span class="number">1</span> * time.Second; tempDelay &gt; max &#123;</span><br><span class="line">tempDelay = max</span><br><span class="line">&#125;</span><br><span class="line">srv.logf(<span class="string">"http: Accept error: %v; retrying in %v"</span>, e, tempDelay)</span><br><span class="line">time.Sleep(tempDelay)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">tempDelay = <span class="number">0</span></span><br><span class="line">c := srv.newConn(rw)</span><br><span class="line">c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line"><span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要详细解释一下的就是 Accept 返回的 error 了。有以下几种可能：</p><ul><li>Accept 的时候 Server 由于某种原因停止了</li><li>收到系统信号产生中断，当然如果 返回的是 EINTR 表示可以重新调用</li><li>之前断掉的连接在短时间被重用了，此时该连接处于 <strong>TIME_WAIT</strong> 状态，新连接暂时不可用。可参考<a href="https://blog.littlechao.top/2018/04/05/tcp_faq/" target="_blank" rel="noopener">这里</a></li></ul><p>对于暂时性的错误，可以稍等一会儿，所以会出现 sleep。如果成功拿到 conn，先标记连接状态，然后创建新 goroutine 开始对连接服务。</p><h4 id="conn-serve"><a href="#conn-serve" class="headerlink" title="conn.serve"></a>conn.serve</h4><blockquote><p>这里由于 HTTPS 和 HTTP2 本身比较复杂，主要讨论 HTTP1.1 的实现。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">serve</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">c.remoteAddr = c.rwc.RemoteAddr().String()</span><br><span class="line">ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;</span><br><span class="line"><span class="keyword">const</span> size = <span class="number">64</span> &lt;&lt; <span class="number">10</span></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">buf = buf[:runtime.Stack(buf, <span class="literal">false</span>)]</span><br><span class="line">c.server.logf(<span class="string">"http: panic serving %v: %v\n%s"</span>, c.remoteAddr, err, buf)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !c.hijacked() &#123;</span><br><span class="line">c.<span class="built_in">close</span>()</span><br><span class="line">c.setState(c.rwc, StateClosed)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> tlsConn, ok := c.rwc.(*tls.Conn); ok &#123;</span><br><span class="line"><span class="comment">// 处理 https</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP/1.x from here on.</span></span><br><span class="line"></span><br><span class="line">ctx, cancelCtx := context.WithCancel(ctx)</span><br><span class="line">c.cancelCtx = cancelCtx</span><br><span class="line"><span class="keyword">defer</span> cancelCtx()</span><br><span class="line"></span><br><span class="line">c.r = &amp;connReader&#123;conn: c&#125;</span><br><span class="line">c.bufr = newBufioReader(c.r)</span><br><span class="line">c.bufw = newBufioWriterSize(checkConnErrorWriter&#123;c&#125;, <span class="number">4</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123; <span class="comment">// 同一个连接有多个请求，循环处理</span></span><br><span class="line">w, err := c.readRequest(ctx) <span class="comment">// 读取请求，会阻塞</span></span><br><span class="line"><span class="keyword">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class="line"><span class="comment">// If we read any bytes off the wire, we're active.</span></span><br><span class="line">c.setState(c.rwc, StateActive)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// handle error</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Expect 100 Continue support</span></span><br><span class="line">req := w.req</span><br><span class="line"><span class="keyword">if</span> req.expectsContinue() &#123;</span><br><span class="line"><span class="keyword">if</span> req.ProtoAtLeast(<span class="number">1</span>, <span class="number">1</span>) &amp;&amp; req.ContentLength != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Wrap the Body reader with one that replies on the connection</span></span><br><span class="line">req.Body = &amp;expectContinueReader&#123;readCloser: req.Body, resp: w&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> req.Header.get(<span class="string">"Expect"</span>) != <span class="string">""</span> &#123;</span><br><span class="line">w.sendExpectationFailed()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.curReq.Store(w)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> requestBodyRemains(req.Body) &#123; <span class="comment">// 支持管线化，处理当前请求时可能还在接收请求</span></span><br><span class="line">registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> w.conn.bufr.Buffered() &gt; <span class="number">0</span> &#123;</span><br><span class="line">w.conn.r.closeNotifyFromPipelinedRequest()</span><br><span class="line">&#125;</span><br><span class="line">w.conn.r.startBackgroundRead()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req) <span class="comment">// 这里就是之前提到的，自定义处理的入口</span></span><br><span class="line">w.cancelCtx()</span><br><span class="line"><span class="keyword">if</span> c.hijacked() &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.finishRequest() <span class="comment">// 把数据 flush 到网络层，此次请求在应用层结束</span></span><br><span class="line"><span class="keyword">if</span> !w.shouldReuseConnection() &#123;</span><br><span class="line"><span class="keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class="line">c.closeWriteAndWait() <span class="comment">// 发送 TCP FIN ，关闭连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> d := c.server.idleTimeout(); d != <span class="number">0</span> &#123; <span class="comment">// 设置空闲超时，超时后关闭连接</span></span><br><span class="line">c.rwc.SetReadDeadline(time.Now().Add(d))</span><br><span class="line"><span class="keyword">if</span> _, err := c.bufr.Peek(<span class="number">4</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.rwc.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码比较复杂，包含了比较完整的 HTTP、HTTPs、HTTP2 协议的实现，建议了解了协议的内容再来看具体实现。代码协议的细节部分代码就不详细谈了，我们需要理解的是 创建 listener，从 Accept 拿到连接，等待并读取到 request，用 handler 处理 request 并把结果或错误信息写到 response 的过程。</p><p>需要注意的是，我们所讨论的是 go 语言官方库的 HTTP 的实现，这里的发送和接收数据都是指的发给下层传输层和从传输层接收，也就是调用 socket 接口，一定要分清楚各个层次。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Go-http-server-I-源码阅读&quot;&gt;&lt;a href=&quot;#Go-http-server-I-源码阅读&quot; class=&quot;headerlink&quot; title=&quot;Go http server (I) 源码阅读&quot;&gt;&lt;/a&gt;Go http server (I) 源码
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netstack TCP(IV) 收发数据(下)</title>
    <link href="http://littlechao.top/2018/05/17/netstack_tcp_receive/"/>
    <id>http://littlechao.top/2018/05/17/netstack_tcp_receive/</id>
    <published>2018-05-16T16:00:00.000Z</published>
    <updated>2018-05-17T12:49:44.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netstack-TCP-IV-收发数据-下"><a href="#Netstack-TCP-IV-收发数据-下" class="headerlink" title="Netstack TCP(IV) 收发数据(下)"></a>Netstack TCP(IV) 收发数据(下)</h2><blockquote><p>接上文，现在看一下 receiver 是如何接收数据的。</p></blockquote><p>endpoint 上关于接收数据的字段如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rcvListMu  sync.Mutex</span><br><span class="line">rcvList    segmentList</span><br><span class="line">rcvClosed  <span class="keyword">bool</span></span><br><span class="line">rcvBufSize <span class="keyword">int</span></span><br><span class="line">rcvBufUsed <span class="keyword">int</span></span><br><span class="line">segmentQueue segmentQueue</span><br></pre></td></tr></table></figure><p>存储结构有 segmentList 和 segmentQueue 。而在 receiver 上主要是 <code>pendingRcvdSegments segmentHeap</code>，一个堆。记住这三个结构，接下来围绕它们展开。这三个结构之间的关系最后总结。</p><p>前面讨论发送数据时是从应用层和传输层之间接口 Write 开始的，而接收数据我们从网络层到传输层的接口 HandlePacket 开始讨论，这样符合数据流方向。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">HandlePacket</span><span class="params">(r *stack.Route, id stack.TransportEndpointID, vv *buffer.VectorisedView)</span></span> &#123;</span><br><span class="line">s := newSegment(r, id, vv)</span><br><span class="line"><span class="keyword">if</span> !s.parse() &#123;</span><br><span class="line">atomic.AddUint64(&amp;e.stack.MutableStats().MalformedRcvdPackets, <span class="number">1</span>)</span><br><span class="line">s.decRef()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把收到的包直接放到 endpoint 的 segmentQueue 里面，但是顺序是没有保障的。</span></span><br><span class="line"><span class="keyword">if</span> e.segmentQueue.enqueue(s) &#123;</span><br><span class="line">e.newSegmentWaker.Assert() </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// The queue is full, so we drop the segment.</span></span><br><span class="line">atomic.AddUint64(&amp;e.stack.MutableStats().DroppedPackets, <span class="number">1</span>)</span><br><span class="line">s.decRef()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上一篇的 mainLoop 函数里，已经注册过 newSegmentWaker 和它的回调 handleSegments 函数，然后在循环中等待 waker。这里收到包，添加到队列里，然后通知 mainLoop 有新的包到来，触发 handleSegments ，先来看下大概执行过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">handleSegments</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">checkRequeue := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxSegmentsPerWake; i++ &#123;</span><br><span class="line">        <span class="comment">// maxSegmentsPerWake 是一个常量，值为 100，其实是随意设置的一个值，因为每次 newSegmentWaker 被触发时可能有很多包要被处理</span></span><br><span class="line">s := e.segmentQueue.dequeue() <span class="comment">// 从队列拿到无序的数据包</span></span><br><span class="line"><span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">checkRequeue = <span class="literal">false</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagRst) &#123;</span><br><span class="line"><span class="keyword">if</span> e.rcv.acceptable(s.sequenceNumber, <span class="number">0</span>) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s.flagIsSet(flagAck) &#123;</span><br><span class="line">...</span><br><span class="line">e.rcv.handleRcvdSegment(s) <span class="comment">// </span></span><br><span class="line">e.snd.handleRcvdSegment(s) <span class="comment">// 分别调用 sender 和 receiver 处理同样的包</span></span><br><span class="line">&#125;</span><br><span class="line">s.decRef()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> checkRequeue &amp;&amp; !e.segmentQueue.empty() &#123;</span><br><span class="line">e.newSegmentWaker.Assert() <span class="comment">// 当 100 次过后还有未处理的包，再次触发 newSegmentWaker</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send an ACK for all processed packets if needed.</span></span><br><span class="line"><span class="keyword">if</span> e.rcv.rcvNxt != e.snd.maxSentAck &#123;</span><br><span class="line">e.snd.sendAck()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要分为两个分支，分别交给 endpoint 的 receiver 和 sender 来处理。这里需要注意，每个 endpoint 只有一个 sender 和 一个 receiver，所以 sender 除了正常向外发送包，还需要在收到包时负责发送 ACK 或 SACK 。所以收到一个数据包时，receiver 和 sender 都要处理，这个过程大致如图</p><p><img src="../images/tcp_handleSegment.png" alt=""></p><p>两个主要过程如下：</p><h4 id="rcv-handleRcvdSegment"><a href="#rcv-handleRcvdSegment" class="headerlink" title="rcv.handleRcvdSegment"></a>rcv.handleRcvdSegment</h4><p>这个函数主要作用是接收乱序的包，放到 receiver 的 pendingRcvdSegments 这个最小堆里，在合适的时候把连续、完整的几个包放到 endpoint 的 rcvList，应用层读取连接的数据就是通过这个 rcvList。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *receiver)</span> <span class="title">handleRcvdSegment</span><span class="params">(s *segment)</span></span> &#123;</span><br><span class="line">   </span><br><span class="line">   segLen := seqnum.Size(s.data.Size())</span><br><span class="line">   segSeq := s.sequenceNumber</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !r.acceptable(segSeq, segLen) &#123;<span class="comment">// 判断包的合法性，是否在接收窗口范围</span></span><br><span class="line">      r.ep.snd.sendAck() <span class="comment">// 发送冗余 ACK</span></span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> !r.consumeSegment(s, segSeq, segLen) &#123;<span class="comment">// consumeSegment 判断当前收到的包是否可以造成接收窗口右移，如果是，说明 pendingRcvdSegments 这个堆里的数据包是连续的，然后把连续的包存到 endpoint 的 rcvList 队列里；如果不是，说明收到失序报文段，返回 FALSE</span></span><br><span class="line">      <span class="keyword">if</span> segLen &gt; <span class="number">0</span> || s.flagIsSet(flagFin) &#123;</span><br><span class="line">         <span class="comment">// We only store the segment if it's within our buffer</span></span><br><span class="line">         <span class="comment">// size limit.</span></span><br><span class="line">         <span class="keyword">if</span> r.pendingBufUsed &lt; r.pendingBufSize &#123;</span><br><span class="line">            r.pendingBufUsed += s.logicalLen()</span><br><span class="line">            s.incRef()</span><br><span class="line">            heap.Push(&amp;r.pendingRcvdSegments, s)</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         UpdateSACKBlocks(&amp;r.ep.sack, segSeq, segSeq.Add(segLen), r.rcvNxt)</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Immediately send an ack so that the peer knows it may</span></span><br><span class="line">         <span class="comment">// have to retransmit.</span></span><br><span class="line">         r.ep.snd.sendAck()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 继续检查 pendingRcvdSegments 里是否有更多连续的数据，如果有，取出来放到 rcvList 里</span></span><br><span class="line">   <span class="keyword">for</span> !r.closed &amp;&amp; r.pendingRcvdSegments.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">      s := r.pendingRcvdSegments[<span class="number">0</span>]</span><br><span class="line">      segLen := seqnum.Size(s.data.Size())</span><br><span class="line">      segSeq := s.sequenceNumber</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Skip segment altogether if it has already been acknowledged.</span></span><br><span class="line">      <span class="keyword">if</span> !segSeq.Add(segLen<span class="number">-1</span>).LessThan(r.rcvNxt) &amp;&amp;</span><br><span class="line">         !r.consumeSegment(s, segSeq, segLen) &#123;</span><br><span class="line">         <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      heap.Pop(&amp;r.pendingRcvdSegments)</span><br><span class="line">      r.pendingBufUsed -= s.logicalLen()</span><br><span class="line">      s.decRef()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="snd-handleRcvdSegment"><a href="#snd-handleRcvdSegment" class="headerlink" title="snd.handleRcvdSegment"></a>snd.handleRcvdSegment</h4><p>这里主要是在收到新的数据包后返回 ACK 或 SACK，并且更新当前状态，比如在外数据值、接收窗口、RTT、RTO…</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sender)</span> <span class="title">handleRcvdSegment</span><span class="params">(seg *segment)</span></span> &#123;</span><br><span class="line"><span class="comment">// Check if we can extract an RTT measurement from this ack.</span></span><br><span class="line"><span class="keyword">if</span> s.rttMeasureSeqNum.LessThan(seg.ackNumber) &#123;</span><br><span class="line">s.updateRTO(time.Now().Sub(s.rttMeasureTime))</span><br><span class="line">s.rttMeasureSeqNum = s.sndNxt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update Timestamp if required. See RFC7323, section-4.3.</span></span><br><span class="line">s.ep.updateRecentTimestamp(seg.parsedOptions.TSVal, s.maxSentAck, seg.sequenceNumber)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Count the duplicates and do the fast retransmit if needed.</span></span><br><span class="line">rtx := s.checkDuplicateAck(seg)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stash away the current window size.</span></span><br><span class="line">s.sndWnd = seg.window</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ignore ack if it doesn't acknowledge any new data.</span></span><br><span class="line">ack := seg.ackNumber</span><br><span class="line"><span class="keyword">if</span> (ack - <span class="number">1</span>).InRange(s.sndUna, s.sndNxt) &#123;</span><br><span class="line"><span class="comment">// When an ack is received we must reset the timer. We stop it</span></span><br><span class="line"><span class="comment">// here and it will be restarted later if needed.</span></span><br><span class="line">s.resendTimer.disable()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove all acknowledged data from the write list.</span></span><br><span class="line">acked := s.sndUna.Size(ack)</span><br><span class="line">s.sndUna = ack</span><br><span class="line"></span><br><span class="line">ackLeft := acked</span><br><span class="line">originalOutstanding := s.outstanding</span><br><span class="line"><span class="keyword">for</span> ackLeft &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// We use logicalLen here because we can have FIN</span></span><br><span class="line"><span class="comment">// segments (which are always at the end of list) that</span></span><br><span class="line"><span class="comment">// have no data, but do consume a sequence number.</span></span><br><span class="line">seg := s.writeList.Front()</span><br><span class="line">datalen := seg.logicalLen()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> datalen &gt; ackLeft &#123;</span><br><span class="line">seg.data.TrimFront(<span class="keyword">int</span>(ackLeft))</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.writeNext == seg &#123;</span><br><span class="line">s.writeNext = seg.Next()</span><br><span class="line">&#125;</span><br><span class="line">s.writeList.Remove(seg)</span><br><span class="line">s.outstanding--</span><br><span class="line">seg.decRef()</span><br><span class="line">ackLeft -= datalen</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update the send buffer usage and notify potential waiters.</span></span><br><span class="line">s.ep.updateSndBufferUsage(<span class="keyword">int</span>(acked))</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we are not in fast recovery then update the congestion</span></span><br><span class="line"><span class="comment">// window based on the number of acknowledged packets.</span></span><br><span class="line"><span class="keyword">if</span> !s.fr.active &#123;</span><br><span class="line">s.updateCwnd(originalOutstanding - s.outstanding)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// It is possible for s.outstanding to drop below zero if we get</span></span><br><span class="line"><span class="comment">// a retransmit timeout, reset outstanding to zero but later</span></span><br><span class="line"><span class="comment">// get an ack that cover previously sent data.</span></span><br><span class="line"><span class="keyword">if</span> s.outstanding &lt; <span class="number">0</span> &#123;</span><br><span class="line">s.outstanding = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now that we've popped all acknowledged data from the retransmit</span></span><br><span class="line"><span class="comment">// queue, retransmit if needed.</span></span><br><span class="line"><span class="keyword">if</span> rtx &#123;</span><br><span class="line">s.resendSegment()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Send more data now that some of the pending data has been ack'd, or</span></span><br><span class="line"><span class="comment">// that the window opened up, or the congestion window was inflated due</span></span><br><span class="line"><span class="comment">// to a duplicate ack during fast recovery. This will also re-enable</span></span><br><span class="line"><span class="comment">// the retransmit timer if needed.</span></span><br><span class="line">s.sendData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三个存储结构"><a href="#三个存储结构" class="headerlink" title="三个存储结构"></a>三个存储结构</h4><p>开始提到的三个字段，关系如下，结合图，再回过头看整个处理过程，其实很清楚了，每个结构的分工还是很明确的。</p><p><img src="../images/tcp_rcv_packets.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netstack-TCP-IV-收发数据-下&quot;&gt;&lt;a href=&quot;#Netstack-TCP-IV-收发数据-下&quot; class=&quot;headerlink&quot; title=&quot;Netstack TCP(IV) 收发数据(下)&quot;&gt;&lt;/a&gt;Netstack TCP(IV) 收
      
    
    </summary>
    
      <category term="netstack_tcp" scheme="http://littlechao.top/categories/netstack-tcp/"/>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="http://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>netstack TCP(III) 收发数据(上)</title>
    <link href="http://littlechao.top/2018/05/15/netstack_tcp_send/"/>
    <id>http://littlechao.top/2018/05/15/netstack_tcp_send/</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-05-17T12:49:44.355Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netstack-TCP-III-收发数据-上"><a href="#Netstack-TCP-III-收发数据-上" class="headerlink" title="Netstack TCP(III) 收发数据(上)"></a>Netstack TCP(III) 收发数据(上)</h2><blockquote><p>上一篇我们讨论了 TCP 连接建立的过程，这篇接着讨论连接建立以后的故事。</p></blockquote><p>如果是被动建立连接，这个连接会经过 deliverAccept 函数被放到 Accept 队列，然后由应用程序去调用 Accept 来获取一个连接，Go SDK 1.9.2 的 net/http/server.go 中是这样调用的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(srv *Server)</span> <span class="title">Serve</span><span class="params">(l net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> l.Close()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">rw, e := l.Accept()</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() &#123;</span><br><span class="line">...</span><br><span class="line">time.Sleep(tempDelay)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br><span class="line">tempDelay = <span class="number">0</span></span><br><span class="line">c := srv.newConn(rw)</span><br><span class="line">c.setState(c.rwc, StateNew) <span class="comment">// before Serve can return</span></span><br><span class="line"><span class="keyword">go</span> c.serve(ctx)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，循环去调用 Accept 去获取一个可读写的连接，但是可能会有一个暂时性的错误，所以让它 <code>sleep</code> 了一小会儿。当然，这里的 Accept 是对系统调用的封装， 和 netstack 的 Accept 不是同一个，但是基本原理是一样的。来看下 netstack 的 Accept：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">Accept</span><span class="params">()</span> <span class="params">(tcpip.Endpoint, *waiter.Queue, *tcpip.Error)</span></span> &#123;</span><br><span class="line">e.mu.RLock()</span><br><span class="line"><span class="keyword">defer</span> e.mu.RUnlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Endpoint must be in listen state before it can accept connections.</span></span><br><span class="line"><span class="keyword">if</span> e.state != stateListen &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, tcpip.ErrInvalidEndpointState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the new accepted endpoint.</span></span><br><span class="line"><span class="keyword">var</span> n *endpoint</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> n = &lt;-e.acceptedChan:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, tcpip.ErrWouldBlock <span class="comment">// 注意这里，当没有新的连接时，没有一直阻塞，而是返回一个 ‘暂时不可用’ 的错误。这也是上一段代码里 sleep 一小会儿的原因。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the protocol goroutine.</span></span><br><span class="line">wq := &amp;waiter.Queue&#123;&#125;</span><br><span class="line">n.startAcceptedLoop(wq)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n, wq, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到新的连接后进入 <code>startAcceptedLoop，</code> <code>startAcceptedLoop</code>只是对 <code>protocolMainLoop</code>的简单封装。</p><p>而如果是主动建立连接，三次握手后，直接进入 <code>protocolMainLoop</code>循环。</p><h4 id="protocolMainLoop"><a href="#protocolMainLoop" class="headerlink" title="protocolMainLoop"></a>protocolMainLoop</h4><p><img src="../images/tcp_main_loop.png" alt=""></p><p>如图，虚线框里的就是 protocolMainLoop 的主要内容。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protocolMainLoop</span><span class="params">()</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// One time set-up.</span></span><br><span class="line">    s := sleep.Sleeper&#123;&#125;</span><br><span class="line"></span><br><span class="line">    funcs := []<span class="keyword">struct</span> &#123;</span><br><span class="line">            w *sleep.Waker</span><br><span class="line">            f <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">        &#125;</span>&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.sndWaker,</span><br><span class="line">                f: e.handleWrite,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.sndCloseWaker,</span><br><span class="line">                f: e.handleClose,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.newSegmentWaker,</span><br><span class="line">                f: e.handleSegments,</span><br><span class="line">            &#125;,</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        s.AddWaker(funcs[i].w, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called repeatedly.</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v, _ := s.Fetch(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> !funcs[v].f() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，主要是注册一些回调，添加到 sleeper 的 waker 里，然后进入循环，Fetch 拿到触发了的事件，然后执行这些事件对应的回调。这是大体框架，接下来详细了解一些比较重要的事件及其回调。</p><p>####sender</p><p>先来关注一个连接作为发送方需要的功能，sender 是比较复杂的，它需要关注 TCP 窗口大小、流量控制、超时重传、拥塞控制、保活探测等一系列机制，同时由于一个 endpoint 只有一个 sender 和 receiver，收到数据后返回 ACK 或者 SACK 的工作也需要 sender 来控制。</p><p>在 endpoint 上和发送有关的域有如下几个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sndBufMu      sync.Mutex</span><br><span class="line">sndBufSize    <span class="keyword">int</span></span><br><span class="line">sndBufUsed    <span class="keyword">int</span></span><br><span class="line">sndClosed     <span class="keyword">bool</span></span><br><span class="line">sndBufInQueue seqnum.Size</span><br><span class="line">sndQueue      segmentList <span class="comment">// 用来保存还未发出的数据</span></span><br><span class="line">sndWaker      sleep.Waker</span><br><span class="line">sndCloseWaker sleep.Waker</span><br></pre></td></tr></table></figure><p>在 sender 上也有一个<code>writeList   segmentList</code> 域，这里 segmentList 是一个有头有尾的链表结构。这两个 segmentList 分别有什么作用和区别呢？我们通过 Write 函数来看下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是 socket 的标准接口之一，调用的时候通常放在一个循环里，确保数据被写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">Write</span><span class="params">(p tcpip.Payload, opts tcpip.WriteOptions)</span> <span class="params">(<span class="keyword">uintptr</span>, *tcpip.Error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// Check against the limit.</span></span><br><span class="line">avail := e.sndBufSize - e.sndBufUsed <span class="comment">// 检查发送窗口大小</span></span><br><span class="line"><span class="keyword">if</span> avail &lt;= <span class="number">0</span> &#123; <span class="comment">// 可用窗口 &lt;= 0,暂时不可发送，返回一个‘暂时性’的错误，表示多试几次即可</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, tcpip.ErrWouldBlock</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v, perr := p.Get(avail)</span><br><span class="line">l := <span class="built_in">len</span>(v)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> err *tcpip.Error</span><br><span class="line"><span class="keyword">if</span> p.Size() &gt; avail &#123;</span><br><span class="line">err = tcpip.ErrWouldBlock</span><br><span class="line">&#125;</span><br><span class="line">l := <span class="built_in">len</span>(v)</span><br><span class="line">s := newSegmentFromView(&amp;e.route, e.id, v) <span class="comment">// 把整块的数据根据当前窗口大小切出一个包，也就是说数据在此之前是‘流式’的</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">e.sndQueue.PushBack(s) <span class="comment">// 注意这里先把数据包存在了 endpoint 的链表里。</span></span><br><span class="line">...</span><br><span class="line">e.handleWrite()</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">uintptr</span>(l), err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，这里的 sendQueue 是可以被多个 goroutine 访问的，所以操作它要加锁（以上代码里为了简要删掉了）。在调用 e.handleWrite() 里，把 e.sendQueue 整个链表追加到了 endpoint.snd.writeList 尾部，由sender 接管，在这里由于调用 handlewrite 已经加了锁，所以 sender 的writeList 只能被一个 goroutine 操作，不需要再加锁。e.handleWrite 做了另一件事就是调用了 sendData 函数。涉及了 TCP 发送方的诸多细节和算法，如超时重传、慢启动、拥塞避免、快速恢复、Reno、newReno、窗口探测等等，读这段代码前需要对 TCP 协议有详细的了解，否则可以先跳过这段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sender)</span> <span class="title">sendData</span><span class="params">()</span></span> &#123;</span><br><span class="line">limit := s.maxPayloadSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce the congestion window to min(IW, cwnd) per RFC 5681, page 10.</span></span><br><span class="line"><span class="comment">// "A TCP SHOULD set cwnd to no more than RW before beginning</span></span><br><span class="line"><span class="comment">// transmission if the TCP has not sent data in the interval exceeding</span></span><br><span class="line"><span class="comment">// the retrasmission timeout."</span></span><br><span class="line"><span class="keyword">if</span> !s.fr.active &amp;&amp; time.Now().Sub(s.lastSendTime) &gt; s.rto &#123;</span><br><span class="line"><span class="keyword">if</span> s.sndCwnd &gt; InitialCwnd &#123;</span><br><span class="line">s.sndCwnd = InitialCwnd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> We currently don't merge multiple send buffers</span></span><br><span class="line"><span class="comment">// into one segment if they happen to fit. We should do that</span></span><br><span class="line"><span class="comment">// eventually.</span></span><br><span class="line"><span class="keyword">var</span> seg *segment</span><br><span class="line">end := s.sndUna.Add(s.sndWnd)</span><br><span class="line"><span class="keyword">for</span> seg = s.writeNext; seg != <span class="literal">nil</span> &amp;&amp; s.outstanding &lt; s.sndCwnd; seg = seg.Next() &#123;</span><br><span class="line"><span class="comment">// We abuse the flags field to determine if we have already</span></span><br><span class="line"><span class="comment">// assigned a sequence number to this segment.</span></span><br><span class="line"><span class="keyword">if</span> seg.flags == <span class="number">0</span> &#123;</span><br><span class="line">seg.sequenceNumber = s.sndNxt</span><br><span class="line">seg.flags = flagAck | flagPsh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> segEnd seqnum.Value</span><br><span class="line"><span class="keyword">if</span> seg.data.Size() == <span class="number">0</span> &#123;</span><br><span class="line">seg.flags = flagAck</span><br><span class="line"></span><br><span class="line">s.ep.rcvListMu.Lock()</span><br><span class="line">rcvBufUsed := s.ep.rcvBufUsed</span><br><span class="line">s.ep.rcvListMu.Unlock()</span><br><span class="line"></span><br><span class="line">s.ep.mu.Lock()</span><br><span class="line"><span class="comment">// We're sending a FIN by default</span></span><br><span class="line">fl := flagFin</span><br><span class="line"><span class="keyword">if</span> (s.ep.shutdownFlags&amp;tcpip.ShutdownRead) != <span class="number">0</span> &amp;&amp; rcvBufUsed &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// If there is unread data we must send a RST.</span></span><br><span class="line"><span class="comment">// For more information see RFC 2525 section 2.17.</span></span><br><span class="line">fl = flagRst</span><br><span class="line">&#125;</span><br><span class="line">s.ep.mu.Unlock()</span><br><span class="line">seg.flags |= <span class="keyword">uint8</span>(fl)</span><br><span class="line"></span><br><span class="line">segEnd = seg.sequenceNumber.Add(<span class="number">1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// We're sending a non-FIN segment.</span></span><br><span class="line"><span class="keyword">if</span> !seg.sequenceNumber.LessThan(end) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">available := <span class="keyword">int</span>(seg.sequenceNumber.Size(end))</span><br><span class="line"><span class="keyword">if</span> available &gt; limit &#123;</span><br><span class="line">available = limit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> seg.data.Size() &gt; available &#123;</span><br><span class="line"><span class="comment">// Split this segment up.</span></span><br><span class="line">nSeg := seg.clone()</span><br><span class="line">nSeg.data.TrimFront(available)</span><br><span class="line">nSeg.sequenceNumber.UpdateForward(seqnum.Size(available))</span><br><span class="line">s.writeList.InsertAfter(seg, nSeg)</span><br><span class="line">seg.data.CapLength(available)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.outstanding++</span><br><span class="line">segEnd = seg.sequenceNumber.Add(seqnum.Size(seg.data.Size()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s.sendSegment(&amp;seg.data, seg.flags, seg.sequenceNumber)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update sndNxt if we actually sent new data (as opposed to</span></span><br><span class="line"><span class="comment">// retransmitting some previously sent data).</span></span><br><span class="line"><span class="keyword">if</span> s.sndNxt.LessThan(segEnd) &#123;</span><br><span class="line">s.sndNxt = segEnd</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember the next segment we'll write.</span></span><br><span class="line">s.writeNext = seg</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable the timer if we have pending data and it's not enabled yet.</span></span><br><span class="line"><span class="keyword">if</span> !s.resendTimer.enabled() &amp;&amp; s.sndUna != s.sndNxt &#123;</span><br><span class="line">s.resendTimer.enable(s.rto)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后实际发送是调用 sender.sendSegment —&gt; endpoint.sendRaw —&gt; sendTCP —&gt; route.ref.ep.WritePacket，route 是这条连接对应的路由，WritePacket 把这个数据包传到对应的网络层endpoint，TCP  sender 的工作到此结束了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *sender)</span> <span class="title">sendSegment</span><span class="params">(data *buffer.VectorisedView, flags <span class="keyword">byte</span>, seq seqnum.Value)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">rcvNxt, rcvWnd := s.ep.rcv.getSendParams()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> s.ep.sendRaw(data.First(), flags, seq, rcvNxt, rcvWnd)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">sendRaw</span><span class="params">(data buffer.View, flags <span class="keyword">byte</span>, seq, ack seqnum.Value, rcvWnd seqnum.Size)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">err := sendTCP(&amp;e.route, e.id, data, flags, seq, ack, rcvWnd)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendTCP</span><span class="params">(r *stack.Route, id stack.TransportEndpointID, data buffer.View, flags <span class="keyword">byte</span>, seq, ack seqnum.Value, rcvWnd seqnum.Size)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="comment">// 添加 TCP 首部</span></span><br><span class="line">hdr := buffer.NewPrependable(header.TCPMinimumSize + <span class="keyword">int</span>(r.MaxHeaderLength()))</span><br><span class="line">tcp := header.TCP(hdr.Prepend(header.TCPMinimumSize))</span><br><span class="line">tcp.Encode(&amp;header.TCPFields&#123;</span><br><span class="line">SrcPort:    id.LocalPort,</span><br><span class="line">DstPort:    id.RemotePort,</span><br><span class="line">SeqNum:     <span class="keyword">uint32</span>(seq),</span><br><span class="line">AckNum:     <span class="keyword">uint32</span>(ack),</span><br><span class="line">DataOffset: header.TCPMinimumSize,</span><br><span class="line">Flags:      flags,</span><br><span class="line">WindowSize: <span class="keyword">uint16</span>(rcvWnd),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> r.WritePacket(&amp;hdr, data, ProtocolNumber)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Route)</span> <span class="title">WritePacket</span><span class="params">(hdr *buffer.Prependable, payload buffer.View, protocol tcpip.TransportProtocolNumber)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.ref.ep.WritePacket(r, hdr, payload, protocol)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netstack-TCP-III-收发数据-上&quot;&gt;&lt;a href=&quot;#Netstack-TCP-III-收发数据-上&quot; class=&quot;headerlink&quot; title=&quot;Netstack TCP(III) 收发数据(上)&quot;&gt;&lt;/a&gt;Netstack TCP(II
      
    
    </summary>
    
      <category term="netstack_tcp" scheme="http://littlechao.top/categories/netstack-tcp/"/>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="http://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>Netstack(II) 链路层</title>
    <link href="http://littlechao.top/2018/05/07/netstack_linklayer/"/>
    <id>http://littlechao.top/2018/05/07/netstack_linklayer/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2018-05-07T15:39:40.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netstack-II-链路层"><a href="#Netstack-II-链路层" class="headerlink" title="Netstack(II) 链路层"></a>Netstack(II) 链路层</h2><blockquote><p>链路层没有特别指明 Protocol 的接口，不过其 endpoint 如下：</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkEndpoint 被以太网、环回、raw 等链路层协议实现，网络层协议用它来往外发送数据。</span></span><br><span class="line"><span class="keyword">type</span> LinkEndpoint <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// MTU is the maximum transmission unit for this endpoint. This is</span></span><br><span class="line"><span class="comment">// usually dictated by the backing physical network; when such a</span></span><br><span class="line"><span class="comment">// physical network doesn't exist, the limit is generally 64k, which</span></span><br><span class="line"><span class="comment">// includes the maximum size of an IP packet.</span></span><br><span class="line">MTU() <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Capabilities returns the set of capabilities supported by the</span></span><br><span class="line"><span class="comment">// endpoint.</span></span><br><span class="line">Capabilities() LinkEndpointCapabilities</span><br><span class="line"></span><br><span class="line"><span class="comment">// MaxHeaderLength returns the maximum size the data link (and</span></span><br><span class="line"><span class="comment">// lower level layers combined) headers can have. Higher levels use this</span></span><br><span class="line"><span class="comment">// information to reserve space in the front of the packets they're</span></span><br><span class="line"><span class="comment">// building.</span></span><br><span class="line">MaxHeaderLength() <span class="keyword">uint16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LinkAddress returns the link address (typically a MAC) of the</span></span><br><span class="line"><span class="comment">// link endpoint.</span></span><br><span class="line">LinkAddress() tcpip.LinkAddress</span><br><span class="line"></span><br><span class="line"><span class="comment">// WritePacket writes a packet with the given protocol through the given</span></span><br><span class="line"><span class="comment">// route.</span></span><br><span class="line">WritePacket(r *Route, hdr *buffer.Prependable, payload buffer.View, protocol tcpip.NetworkProtocolNumber) *tcpip.Error</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach attaches the data link layer endpoint to the network-layer</span></span><br><span class="line"><span class="comment">// dispatcher of the stack.</span></span><br><span class="line">Attach(dispatcher NetworkDispatcher)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常用一个 endpointID 和它联系起来:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkEndpointID <span class="keyword">uint64</span></span><br></pre></td></tr></table></figure><h3 id="fdbased-endpoint"><a href="#fdbased-endpoint" class="headerlink" title="fdbased endpoint"></a>fdbased endpoint</h3><p>LinkEndpoint 的实现有多种，这里我们主要看一下基于文件描述符的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> endpoint <span class="keyword">struct</span> &#123;</span><br><span class="line">fd <span class="keyword">int</span></span><br><span class="line">mtu <span class="keyword">uint32</span></span><br><span class="line">hdrSize <span class="keyword">int</span> </span><br><span class="line">    <span class="comment">// 指链路层首部长度，这里特别讨论一下，可能有两个值，0 或 14。14 好理解，6 字节 dst MAC 地址，6字节 src MAC 地址，2 字节类型。为什么可能是 0 呢，如果是 localhost 的数据，是不需要 dst 和 src Mac地址的。</span></span><br><span class="line">addr tcpip.LinkAddress</span><br><span class="line">caps stack.LinkEndpointCapabilities</span><br><span class="line"></span><br><span class="line"><span class="comment">// closed is a function to be called when the FD's peer (if any) closes</span></span><br><span class="line"><span class="comment">// its end of the communication pipe.</span></span><br><span class="line">closed <span class="function"><span class="keyword">func</span><span class="params">(*tcpip.Error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">vv</span>     *<span class="title">buffer</span>.<span class="title">VectorisedView</span></span></span><br><span class="line"><span class="function"><span class="title">iovecs</span> []<span class="title">syscall</span>.<span class="title">Iovec</span></span></span><br><span class="line"><span class="function"><span class="title">views</span>  []<span class="title">buffer</span>.<span class="title">View</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>这里 主要了解 View 和 VectorisedView：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> View []<span class="keyword">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> VectorisedView <span class="keyword">struct</span> &#123;</span><br><span class="line">views []View</span><br><span class="line">size  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还有一个 Prependable：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Prependable <span class="keyword">struct</span> &#123;</span><br><span class="line">buf View</span><br><span class="line">usedIdx <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这三个结构是整个系统里用的最多的底层结构，用来表示要传输的包。特别是 Prependable，它是可以扩展的，并且是在数据的开始处扩展，想想各层网络协议的首部，是在上一层数据的最前面添加这一层的首部。</p><h4 id="iovec"><a href="#iovec" class="headerlink" title="iovec"></a>iovec</h4><blockquote><p>这里重点提一下 <strong>向量IO</strong> 的概念。这是一种在单词系统调用中操作多个缓冲区的 I/O 方法，可以将单个数据流的内容写到多个缓冲区，或者把单个数据流读到多个缓冲区中。</p><ul><li>效率：单个向量I/O 操作能代替多个线性I/O 操作</li><li>性能：除了系统调用次数的降低，由于内部优化，向量I /O 比线性I/O 提供更好的性能。</li><li>原子性：不同于多个线性I/O 操作，一个进程可以执行单个向量I/O操作而且避免了与其它进程交叉操作的风险。</li></ul><p>实际上，内核里的所有I/O 都是向量I/O，read()和 write()是只有一个向量的向量I/O，且向量中只有一个段。</p></blockquote><p>代码里这个 iovecs 字段就是用于向量 IO，内存分配如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BufConfig = []<span class="keyword">int</span>&#123;<span class="number">128</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">8192</span>, <span class="number">16384</span>, <span class="number">32768</span>&#125; </span><br><span class="line"><span class="comment">// 总共接近 64KB，其实有点困惑，真的需要这么多内存吗？因为 MTU 也就 1500B</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">allocateViews</span><span class="params">(bufConfig []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> e.views &#123;</span><br><span class="line"><span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">b := buffer.NewView(bufConfig[i])</span><br><span class="line">e.views[i] = b</span><br><span class="line">e.iovecs[i] = syscall.Iovec&#123;</span><br><span class="line">Base: &amp;b[<span class="number">0</span>],</span><br><span class="line">Len:  <span class="keyword">uint64</span>(<span class="built_in">len</span>(b)),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p>先看发送，就是系统调用往对应的 fd 里写入内容，需要注意的是这是<em>非阻塞</em>写入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WritePacket writes outbound packets to the file descriptor. If it is not</span></span><br><span class="line"><span class="comment">// currently writable, the packet is dropped.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">WritePacket</span><span class="params">(r *stack.Route, hdr *buffer.Prependable, payload buffer.View, protocol tcpip.NetworkProtocolNumber)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> e.hdrSize &gt; <span class="number">0</span> &#123; <span class="comment">// 不是 localhost，需要加上首部</span></span><br><span class="line">eth := header.Ethernet(hdr.Prepend(header.EthernetMinimumSize))</span><br><span class="line">eth.Encode(&amp;header.EthernetFields&#123;</span><br><span class="line">DstAddr: r.RemoteLinkAddress,</span><br><span class="line">SrcAddr: e.addr,</span><br><span class="line">Type:    protocol,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(payload) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> rawfile.NonBlockingWrite(e.fd, hdr.UsedBytes())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rawfile.NonBlockingWrite2(e.fd, hdr.UsedBytes(), payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NonBlockingWrite</span><span class="params">(fd <span class="keyword">int</span>, buf []<span class="keyword">byte</span>)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ptr unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(buf) &gt; <span class="number">0</span> &#123;</span><br><span class="line">ptr = unsafe.Pointer(&amp;buf[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, _, e := syscall.RawSyscall(syscall.SYS_WRITE, <span class="keyword">uintptr</span>(fd), <span class="keyword">uintptr</span>(ptr), <span class="keyword">uintptr</span>(<span class="built_in">len</span>(buf)))</span><br><span class="line"><span class="keyword">if</span> e != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> TranslateErrno(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 '向量 IO' 写入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NonBlockingWrite2</span><span class="params">(fd <span class="keyword">int</span>, b1, b2 []<span class="keyword">byte</span>)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">iovec := [...]syscall.Iovec&#123; <span class="comment">// </span></span><br><span class="line">&#123;</span><br><span class="line">Base: &amp;b1[<span class="number">0</span>],</span><br><span class="line">Len:  <span class="keyword">uint64</span>(<span class="built_in">len</span>(b1)),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Base: &amp;b2[<span class="number">0</span>],</span><br><span class="line">Len:  <span class="keyword">uint64</span>(<span class="built_in">len</span>(b2)),</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, _, e := syscall.RawSyscall(syscall.SYS_WRITEV, <span class="keyword">uintptr</span>(fd), <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;iovec[<span class="number">0</span>])), <span class="keyword">uintptr</span>(<span class="built_in">len</span>(iovec)))</span><br><span class="line"><span class="keyword">if</span> e != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> TranslateErrno(e)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><p>链路层 endpoint 在运行起来后会进入一个接收循环：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">dispatchLoop</span><span class="params">(d stack.NetworkDispatcher)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">v := buffer.NewView(header.MaxIPPacketSize)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">cont, err := e.dispatch(d, v) <span class="comment">// note: if no data to deliver, it blocks.</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">dispatch</span><span class="params">(d stack.NetworkDispatcher, largeV buffer.View)</span> <span class="params">(<span class="keyword">bool</span>, *tcpip.Error)</span></span> &#123;</span><br><span class="line">e.allocateViews(BufConfig) <span class="comment">// 分配内存</span></span><br><span class="line"></span><br><span class="line">n, err := rawfile.BlockingReadv(e.fd, e.iovecs) <span class="comment">// 注意这里会阻塞</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">used := e.capViews(n, BufConfig)</span><br><span class="line">e.vv.SetViews(e.views[:used])</span><br><span class="line">e.vv.SetSize(n)</span><br><span class="line">e.vv.TrimFront(e.hdrSize) <span class="comment">// note: trim eth header, leave the IP protocol</span></span><br><span class="line"></span><br><span class="line">d.DeliverNetworkPacket(e, addr, p, e.vv)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare e.views for another packet: release used views.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; used; i++ &#123;</span><br><span class="line">e.views[i] = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 dispatch 先分配内存，然后读取，而且很明显只读取一个帧数据，由于 MTU 限制，通常大小为 1518B，所以不明白为什么会分配大约 64KB 的内存。</p><p>特别看一下 blockReadv 的实现，这个函数将底层的非阻塞读封装成了阻塞读。先回顾一下非阻塞 IO 模型：</p><p><img src="/images/netstack/nonblock.svg" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BlockingReadv</span><span class="params">(fd <span class="keyword">int</span>, iovecs []syscall.Iovec)</span> <span class="params">(<span class="keyword">int</span>, *tcpip.Error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, _, e := syscall.RawSyscall(syscall.SYS_READV, <span class="keyword">uintptr</span>(fd), <span class="keyword">uintptr</span>(unsafe.Pointer(&amp;iovecs[<span class="number">0</span>])), <span class="keyword">uintptr</span>(<span class="built_in">len</span>(iovecs)))</span><br><span class="line"><span class="comment">// 注意这里可能阻塞，也可能不阻塞。首先这是一个 NonBlocking IO，如上图。数据没有准备好时，立即返回，数据准备好时，阻塞拷贝到 user 空间。</span></span><br><span class="line"><span class="keyword">if</span> e == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">int</span>(n), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">event := <span class="keyword">struct</span> &#123;</span><br><span class="line">fd      <span class="keyword">int32</span></span><br><span class="line">events  <span class="keyword">int16</span></span><br><span class="line">revents <span class="keyword">int16</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">fd:     <span class="keyword">int32</span>(fd),</span><br><span class="line">events: <span class="number">1</span>, <span class="comment">// POLLIN</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_, e = blockingPoll(unsafe.Pointer(&amp;event), <span class="number">1</span>, <span class="number">-1</span>) </span><br><span class="line">        <span class="comment">// 这里会阻塞直到有事件触发。第二个参数是 event 个数，第三个参数是指等待的时间，时间到了，不论有没有事件到来，都要返回，-1 代表无限等待。关于 poll 可以参考这里:</span></span><br><span class="line">        <span class="comment">// http://www.cnblogs.com/Anker/archive/2013/08/15/3261006.html</span></span><br><span class="line"><span class="keyword">if</span> e != <span class="number">0</span> &amp;&amp; e != syscall.EINTR &#123; <span class="comment">// err=EINTR 代表需要重新发起调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, TranslateErrno(e)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取到一个数据帧后，调用<code>d.DeliverNetworkPacket(e, addr, p, e.vv)</code>把数据分发到 network 层。这里涉及到 NetworkDispatcher 接口，在代码里由 NIC 实现，这次就不讨论了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NetworkDispatcher <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// DeliverNetworkPacket finds the appropriate network protocol</span></span><br><span class="line"><span class="comment">// endpoint and hands the packet over for further processing.</span></span><br><span class="line">DeliverNetworkPacket(linkEP LinkEndpoint, remoteLinkAddr tcpip.LinkAddress, protocol tcpip.NetworkProtocolNumber, vv *buffer.VectorisedView)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel-、loopback、sniffer-endpoint"><a href="#channel-、loopback、sniffer-endpoint" class="headerlink" title="channel 、loopback、sniffer endpoint"></a>channel 、loopback、sniffer endpoint</h3><p>这里简单讨论一下其他的 endpoint 实现。</p><h5 id="channel-endpoint"><a href="#channel-endpoint" class="headerlink" title="channel endpoint"></a>channel endpoint</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PacketInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">Header  buffer.View</span><br><span class="line">Payload buffer.View</span><br><span class="line">Proto   tcpip.NetworkProtocolNumber</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Endpoint <span class="keyword">struct</span> &#123;</span><br><span class="line">dispatcher stack.NetworkDispatcher</span><br><span class="line">mtu        <span class="keyword">uint32</span></span><br><span class="line">linkAddr   tcpip.LinkAddress</span><br><span class="line"></span><br><span class="line"><span class="comment">// C is where outbound packets are queued.</span></span><br><span class="line">C <span class="keyword">chan</span> PacketInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>channel 主要是实现内部通信，所以写数据就是直接把帧放到 channel 形成队列：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WritePacket stores outbound packets into the channel.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Endpoint)</span> <span class="title">WritePacket</span><span class="params">(_ *stack.Route, hdr *buffer.Prependable, payload buffer.View, protocol tcpip.NetworkProtocolNumber)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line">p := PacketInfo&#123;</span><br><span class="line">Header: hdr.View(),</span><br><span class="line">Proto:  protocol,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> payload != <span class="literal">nil</span> &#123;</span><br><span class="line">p.Payload = <span class="built_in">make</span>(buffer.View, <span class="built_in">len</span>(payload))</span><br><span class="line"><span class="built_in">copy</span>(p.Payload, payload)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> e.C &lt;- p:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="loopback-endpoint"><a href="#loopback-endpoint" class="headerlink" title="loopback endpoint"></a>loopback endpoint</h4><p>环回的 endpoint 就更简单了，不需要经过网卡，经过它发送的数据立即被looped back到IP层的输入队列中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">WritePacket</span><span class="params">(_ *stack.Route, hdr *buffer.Prependable, payload buffer.View, protocol tcpip.NetworkProtocolNumber)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(payload) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// We don't have a payload, so just use the buffer from the</span></span><br><span class="line"><span class="comment">// header as the full packet.</span></span><br><span class="line">v := hdr.View()</span><br><span class="line">vv := v.ToVectorisedView([<span class="number">1</span>]buffer.View&#123;&#125;)</span><br><span class="line">e.dispatcher.DeliverNetworkPacket(e, <span class="string">""</span>, protocol, &amp;vv)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">views := []buffer.View&#123;hdr.View(), payload&#125;</span><br><span class="line">vv := buffer.NewVectorisedView(<span class="built_in">len</span>(views[<span class="number">0</span>])+<span class="built_in">len</span>(views[<span class="number">1</span>]), views)</span><br><span class="line">e.dispatcher.DeliverNetworkPacket(e, <span class="string">""</span>, protocol, &amp;vv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外特别的是，由于不经过实际链路，所以没有通常意义的 MTU，它的 MTU 可以取到最大值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*endpoint)</span> <span class="title">MTU</span><span class="params">()</span> <span class="title">uint32</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">65536</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="sniffer-endpoint"><a href="#sniffer-endpoint" class="headerlink" title="sniffer endpoint"></a>sniffer endpoint</h4><p>sniffer 意思是探测器，这个 endpoint 只是对一个正常的 endpoint 的包装，实现 LinkEndpoint 接口的函数都是调用它所包装的 endpoint。它所实现的功能是记录所有经过它的包，可以用它实现抓包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> endpoint <span class="keyword">struct</span> &#123;</span><br><span class="line">dispatcher stack.NetworkDispatcher</span><br><span class="line">lower      stack.LinkEndpoint</span><br><span class="line">file       *os.File</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LogPacket</span><span class="params">(prefix <span class="keyword">string</span>, protocol tcpip.NetworkProtocolNumber, b, plb []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netstack-II-链路层&quot;&gt;&lt;a href=&quot;#Netstack-II-链路层&quot; class=&quot;headerlink&quot; title=&quot;Netstack(II) 链路层&quot;&gt;&lt;/a&gt;Netstack(II) 链路层&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;链路层
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="http://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>netstack TCP(II) 连接管理与三次握手</title>
    <link href="http://littlechao.top/2018/04/20/netstack_conn_handshake/"/>
    <id>http://littlechao.top/2018/04/20/netstack_conn_handshake/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-05-19T02:24:00.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Netsatck-TCP-II-连接的建立与三次握手"><a href="#Netsatck-TCP-II-连接的建立与三次握手" class="headerlink" title="Netsatck TCP(II) 连接的建立与三次握手"></a>Netsatck TCP(II) 连接的建立与三次握手</h2><h4 id="protocolListenLoop"><a href="#protocolListenLoop" class="headerlink" title="protocolListenLoop"></a>protocolListenLoop</h4><p>当新建一个 endpoint 并且将其 Bind 到一个端口后，这个endpoint 进入 protocolListenLoop，负责监听与连接建立。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">e.protocolListenLoop(seqnum.Size(e.receiveBufferAvailable()))&#123;<span class="comment">// 同时设置了 rcvBuf 的大小</span></span><br><span class="line">    ctx := newListenContext(e.stack, rcvWnd, v6only, e.netProto)<span class="comment">// 只是为了带一些参数</span></span><br><span class="line"></span><br><span class="line">s := sleep.Sleeper&#123;&#125;</span><br><span class="line">s.AddWaker(&amp;e.notificationWaker, wakerForNotification)</span><br><span class="line">s.AddWaker(&amp;e.newSegmentWaker, wakerForNewSegment)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> index, _ := s.Fetch(<span class="literal">true</span>); index &#123;</span><br><span class="line"><span class="keyword">case</span> wakerForNotification:</span><br><span class="line">n := e.fetchNotifications()</span><br><span class="line"><span class="keyword">if</span> n&amp;notifyClose != <span class="number">0</span> &#123;<span class="comment">// 表示收到退出通知</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> wakerForNewSegment:</span><br><span class="line"><span class="comment">// Process at most maxSegmentsPerWake segments.</span></span><br><span class="line">mayRequeue := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxSegmentsPerWake; i++ &#123; </span><br><span class="line">                <span class="comment">// maxSegmentsPerWake==100,因为收到一个通知可能对应受到了多个数据包，所以每次 wake</span></span><br><span class="line">                <span class="comment">// 都处理多次</span></span><br><span class="line">s := e.segmentQueue.dequeue()</span><br><span class="line">                <span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">e.handleListenSegment(ctx, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mayRequeue &amp;&amp; !e.segmentQueue.empty() &#123;</span><br><span class="line">e.newSegmentWaker.Assert()</span><br><span class="line"><span class="comment">// maxSegmentsPerWake 次循环仍然没有处理完所有的包，再次唤醒 waker，继续处理</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/netstack/tcp_listenLoop.png" alt=""></p><p>handleListenSegment  处理收到的数据包，优先判定是否有 SYN 标识。如果改数据包没有 SYN 而有 ACK 标识的话，那么根据三次握手，它属于第三步，验证其合法后，该数据包对应的连接已经建立，那么为该连接创建一个新的 endpoint，将其发给 Accept 队列。</p><p>只要包含 SYN标识，那么说明该连接处于三步握手的第一步。为什么不是第二步？因为这是 Listen 函数，当前处于连接的被动方。这里会有一个队列，称为 SYN_RCVD 队列或半连接队列。长度为 max(64,/proc/sys/net/ipv4/tcp_max_syn_backlog) ，在机器的tcp_max_syn_backlog值在/proc/sys/net/ipv4/tcp_max_syn_backlog下配置。</p><p><img src="/images/netstack/handshake.png" alt=""></p><p>当这个队列满了，不开启 syncookies 的时候，Server 会丢弃新来的 SYN 包，而 Client 端在多次重发 SYN 包得不到响应而返回（<code>connection time out</code>）错误。但是，当 Server 端开启了 syncookies=1，那么 SYN 半连接队列就没有逻辑上的最大值了，并且 /proc/sys/net/ipv4/tcp_max_syn_backlog 设置的值也会被忽略。在 netstack 中开启了 syncookies。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">handleListenSegment</span><span class="params">(ctx *listenContext, s *segment)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> s.flags &#123;</span><br><span class="line"><span class="keyword">case</span> flagSyn:</span><br><span class="line">opts := parseSynSegmentOptions(s)</span><br><span class="line"><span class="keyword">if</span> incSynRcvdCount() &#123; <span class="comment">// 半连接队列长度 +1，成功返回 true，队列已满返回 false</span></span><br><span class="line"><span class="keyword">go</span> e.handleSynSegment(ctx, s, &amp;opts)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里采用 SYNCookies 策略，SYN 半连接队列就没有逻辑上的最大值</span></span><br><span class="line">cookie := ctx.createCookie(s.id, s.sequenceNumber, encodeMSS(opts.MSS))</span><br><span class="line">...</span><br><span class="line">sendSynTCP(&amp;s.route, s.id, flagSyn|flagAck, cookie, s.sequenceNumber+<span class="number">1</span>, ctx.rcvWnd, synOpts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> flagAck:</span><br><span class="line"><span class="keyword">if</span> data, ok := ctx.isCookieValid(s.id, s.ackNumber<span class="number">-1</span>, s.sequenceNumber<span class="number">-1</span>); ok &amp;&amp; <span class="keyword">int</span>(data) &lt; <span class="built_in">len</span>(mssTable) &#123; <span class="comment">// 验证 ACK 的正确性</span></span><br><span class="line">...</span><br><span class="line">n, err := ctx.createConnectedEndpoint(s, s.ackNumber<span class="number">-1</span>, s.sequenceNumber<span class="number">-1</span>, rcvdSynOptions)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">e.deliverAccepted(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>e.handleSynSegment 做的事情就是创建 handshake 结构体，执行三步握手，然后将完成握手的新的 endpoint 传入 Accept 队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *endpoint)</span> <span class="title">handleSynSegment</span><span class="params">(ctx *listenContext, s *segment, opts *header.TCPSynOptions)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> decSynRcvdCount() <span class="comment">// 不论最后有没有成功建立连接，把半连接数量 -1</span></span><br><span class="line"></span><br><span class="line">n, err := ctx.createEndpointAndPerformHandshake(s, opts)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">e.deliverAccepted(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *listenContext)</span> <span class="title">createEndpointAndPerformHandshake</span><span class="params">(s *segment, opts *header.TCPSynOptions)</span> <span class="params">(*endpoint, *tcpip.Error)</span></span> &#123;</span><br><span class="line"><span class="comment">// Create new endpoint.</span></span><br><span class="line">    irs := s.sequenceNumber <span class="comment">// irs: initial remote sequenceNUmber</span></span><br><span class="line">cookie := l.createCookie(s.id, irs, encodeMSS(opts.MSS)) <span class="comment">// 同样需要使用 cookie 来实现验证</span></span><br><span class="line">ep, err := l.createConnectedEndpoint(s, cookie, irs, opts)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform the 3-way handshake.</span></span><br><span class="line">h, err := newHandshake(ep, l.rcvWnd)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> err := h.execute(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">ep.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> ep, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看下 handshake 的 excute 方法，也就是具体执行握手的方法。在看代码之前我们要做到心中有 B 树，哦不，是连接状态机：</p><p><img src="/images/netstack/tcp_state.png" alt=""></p><p>注意这个函数可以在被动的 Listen 函数里调用，也可以在主动的 Connect 里被调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">execute</span><span class="params">()</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="comment">// Initialize the resend timer.</span></span><br><span class="line">resendWaker := sleep.Waker&#123;&#125;</span><br><span class="line">timeOut := time.Duration(time.Second) <span class="comment">// 设置初始 RTO 为 1s</span></span><br><span class="line">rt := time.AfterFunc(timeOut, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">resendWaker.Assert() <span class="comment">// RTO 后触发超时重传</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> rt.Stop()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up the wakers.</span></span><br><span class="line">s := sleep.Sleeper&#123;&#125;</span><br><span class="line">s.AddWaker(&amp;resendWaker, wakerForResend)</span><br><span class="line">s.AddWaker(&amp;h.ep.notificationWaker, wakerForNotification)</span><br><span class="line">s.AddWaker(&amp;h.ep.newSegmentWaker, wakerForNewSegment)</span><br><span class="line"><span class="keyword">defer</span> s.Done()</span><br><span class="line"></span><br><span class="line">synOpts := header.TCPSynOptions&#123;</span><br><span class="line">WS:    h.rcvWndScale, <span class="comment">// 这里设置的是自己这一端的 wndScale</span></span><br><span class="line">TS:    <span class="literal">true</span>,</span><br><span class="line">TSVal: h.ep.timestamp(),</span><br><span class="line">TSEcr: h.ep.recentTS,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> h.state == handshakeSynRcvd &#123;</span><br><span class="line">synOpts.TS = h.ep.sendTSOk </span><br><span class="line">        <span class="comment">// handshakeSynRcvd 说明当前是由 Listen 调用的被动连接，由对方决定是否使用 TS 选项</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意以下的 ACK 序列号，如果是主动发起连接，该值为 0，相反，则值为 irs + 1</span></span><br><span class="line">sendSynTCP(&amp;h.ep.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> h.state != handshakeCompleted &#123;</span><br><span class="line"><span class="keyword">switch</span> index, _ := s.Fetch(<span class="literal">true</span>); index &#123;</span><br><span class="line"><span class="keyword">case</span> wakerForResend: <span class="comment">// SYN+ACK 超时重传的情况</span></span><br><span class="line">timeOut *= <span class="number">2</span> <span class="comment">// 指数退避行为</span></span><br><span class="line"><span class="keyword">if</span> timeOut &gt; <span class="number">60</span>*time.Second &#123; <span class="comment">// 最大超时时间</span></span><br><span class="line"><span class="keyword">return</span> tcpip.ErrTimeout</span><br><span class="line">&#125;</span><br><span class="line">rt.Reset(timeOut)</span><br><span class="line">sendSynTCP(&amp;h.ep.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> wakerForNotification: <span class="comment">// 收到关闭信号</span></span><br><span class="line">n := h.ep.fetchNotifications()</span><br><span class="line"><span class="keyword">if</span> n&amp;notifyClose != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrAborted</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> wakerForNewSegment: <span class="comment">// 等待并处理新的 SYN 数据包或握手第三步的 ACK</span></span><br><span class="line"><span class="keyword">if</span> err := h.processSegments(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，excute 首先发送一个 SYN + ACK 报文（注意这里对应主动和被动两种情况），然后进入循环直到建立连接。同理，h.processSegments 也对应两种情况。如果自己是主动连接，那么自己目前处于 SYN_SENT 状态，等待一个 SYN + ACK 报文并执行 synSentState：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">synSentState</span><span class="params">(s *segment)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="comment">// RFC 793, page 37, states that in the SYN-SENT state, a reset is</span></span><br><span class="line"><span class="comment">// acceptable if the ack field acknowledges the SYN.</span></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagRst) &#123;</span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &amp;&amp; s.ackNumber == h.iss+<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrConnectionRefused</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !h.checkAck(s) || !s.flagIsSet(flagSyn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rcvSynOpts := parseSynSegmentOptions(s)</span><br><span class="line">h.ep.maybeEnableTimestamp(&amp;rcvSynOpts) <span class="comment">// 设置是否允许时间戳选项</span></span><br><span class="line"></span><br><span class="line">h.ackNum = s.sequenceNumber + <span class="number">1</span></span><br><span class="line">h.flags |= flagAck</span><br><span class="line">h.mss = rcvSynOpts.MSS</span><br><span class="line">h.sndWndScale = rcvSynOpts.WS</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &#123; <span class="comment">// 发出 SYN 后收到了 SYN + ACK，再发送一个 ACK，连接就完成建立了</span></span><br><span class="line">h.state = handshakeCompleted</span><br><span class="line">h.ep.sendRaw(<span class="literal">nil</span>, flagAck, h.iss+<span class="number">1</span>, h.ackNum, h.rcvWnd&gt;&gt;h.effectiveRcvWndScale())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下这一端对应的是状态机那张图里的‘同时连接’的情况，此时作为主动方已经发出了一个 SYN，然后又收到了一个 SYN，此时只要发送一个 SYN + ACK，对于对方来说这个连接就已经建立了，对于自己来说，再收到一个 SYN + ACK 也算完成连接。</span></span><br><span class="line">h.state = handshakeSynRcvd</span><br><span class="line">synOpts := header.TCPSynOptions&#123;</span><br><span class="line">WS:    h.rcvWndScale,</span><br><span class="line">TS:    rcvSynOpts.TS,</span><br><span class="line">TSVal: h.ep.timestamp(),</span><br><span class="line">TSEcr: h.ep.recentTS,</span><br><span class="line">&#125;</span><br><span class="line">sendSynTCP(&amp;s.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是被动连接，那么自己目前处于 SYN_RCVD 状态，等待一个 ACK：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handshake)</span> <span class="title">synRcvdState</span><span class="params">(s *segment)</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagRst) &#123; <span class="comment">//</span></span><br><span class="line"><span class="keyword">if</span> s.sequenceNumber.InWindow(h.ackNum, h.rcvWnd) &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrConnectionRefused</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !h.checkAck(s) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagSyn) &amp;&amp; s.sequenceNumber != h.ackNum<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// 之前已经收到过了一个 SYN，然后又收到了一个 SYN，并且两次 seq 不同，那么认为对方抽风，发送 RST 关闭连接。</span></span><br><span class="line">ack := s.sequenceNumber.Add(s.logicalLen())</span><br><span class="line">seq := seqnum.Value(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &#123;</span><br><span class="line">seq = s.ackNumber</span><br><span class="line">&#125;</span><br><span class="line">h.ep.sendRaw(<span class="literal">nil</span>, flagRst|flagAck, seq, ack, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !h.active &#123;</span><br><span class="line"><span class="keyword">return</span> tcpip.ErrInvalidEndpointState</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := h.resetState(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">synOpts := header.TCPSynOptions&#123;</span><br><span class="line">WS:    h.rcvWndScale,</span><br><span class="line">TS:    h.ep.sendTSOk,</span><br><span class="line">TSVal: h.ep.timestamp(),</span><br><span class="line">TSEcr: h.ep.recentTS,</span><br><span class="line">&#125;</span><br><span class="line">sendSynTCP(&amp;s.route, h.ep.id, h.flags, h.iss, h.ackNum, h.rcvWnd, synOpts)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> s.flagIsSet(flagAck) &#123;</span><br><span class="line"><span class="comment">// 如果之前协商好了要带上 timeStamp 选项，但是握手第三步没有带上时间戳，那么丢弃这个 ACK 数据包</span></span><br><span class="line"><span class="keyword">if</span> h.ep.sendTSOk &amp;&amp; !s.parsedOptions.TS &#123;</span><br><span class="line">atomic.AddUint64(&amp;h.ep.stack.MutableStats().DroppedPackets, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新时间戳</span></span><br><span class="line">h.ep.updateRecentTimestamp(s.parsedOptions.TSVal, h.ackNum, s.sequenceNumber)</span><br><span class="line"></span><br><span class="line">h.state = handshakeCompleted </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Netsatck-TCP-II-连接的建立与三次握手&quot;&gt;&lt;a href=&quot;#Netsatck-TCP-II-连接的建立与三次握手&quot; class=&quot;headerlink&quot; title=&quot;Netsatck TCP(II) 连接的建立与三次握手&quot;&gt;&lt;/a&gt;Netsatc
      
    
    </summary>
    
      <category term="netstack_tcp" scheme="http://littlechao.top/categories/netstack-tcp/"/>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="http://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>netstack TCP(I) 总览</title>
    <link href="http://littlechao.top/2018/04/16/netstack_tcp_overview/"/>
    <id>http://littlechao.top/2018/04/16/netstack_tcp_overview/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-05-17T12:49:44.335Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>netstack 是 Google 开源的用 Go 语言实现的网络协议栈。在之前的几篇文章中我们简要的了解了 TCP 协议的基本内容，接下来我会通过读源码来加深对协议的理解，学习如何架构一个比较复杂的项目。当然只会对源码进行大致的分析以及梳理关键点，源码还需要详细的去阅读。这里附上我 fork 的 <a href="github.com/shichao1996/netstack">netstack项目</a>,我在原来的基础上加了一些自己的注释或一些问题，为了区别原有注释，注释中以 ‘note：’ 开头的是我自己的笔记。如果你是用的 Intellij 的编辑器，参照<a href="http://blog.littlechao.top/2018/04/18/intellij%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A/" target="_blank" rel="noopener">这篇</a>设置高亮。</p></blockquote><h4 id="主要结构及其关联"><a href="#主要结构及其关联" class="headerlink" title="主要结构及其关联"></a>主要结构及其关联</h4><p><img src="/images/netstack/tcp_struct_map.png" alt=""></p><p>TCP 实现里暴露出来的最主要的接口是 EndPoint，它对应 Socket 的概念，提供了应用层常用的 Listen、Accept、Bind、Connect 等等方法。endpoint 结构体实现了 EndPoint 接口，它是一个 TCP 连接一端的实体，主要包含 sender、receiver、handshake 这三个结构体，这三个结构体也实现了一个 TCP 端所需的主要功能。</p><p>还有另一个非常重要的自段：stack，它是整个网络协议栈的抽象，这里负责把网络层和传输层连接起来。</p><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p><img src="/images/netstack/tcp_process.png" alt=""></p><p>整个运行的核心在图中标红的两个循环里，其余的部分代码较少，实现也简单。endpoint 的 Listen 函数在 protocolListenLoop 中监听新的连接请求，主要处理三步握手的 SYN 报文和 ACK 报文，负责连接的被动建立。可以看到，这里会有一个<strong>处于 SYN_RCVD 状态的半连接的队列</strong>。建立好的连接通过一个长度为 <strong>backlog</strong> 的channel，把新建连接对应的 endpoint 放到 backlog 队列，然后执行 Accept 的逻辑。</p><p>需要注意的是，负责 Listen 的 endpoint 管理的是所有未完成的连接，而连接建立以后会获得一个新的 endpoint，专门负责那一个连接。</p><p>Accept 和 Connect 函数处理的都是已经建立好的连接，不同之处是 Connect 是主动发起连接，而 Accept 是被动的。</p><h5 id="sleep-包"><a href="#sleep-包" class="headerlink" title="sleep 包"></a>sleep 包</h5><p>进入 protocolMainLoop 之前，先注册了一些回调函数，然后进入循环，当对应事件发生时，通过 sleeper-waker 机制，调用提前注册的函数。sleep 实现了一个边缘触发的 epoll</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It is similar to edge-triggered epoll waits, where the user registers each object of interest once, and then can repeatedly wait on all of them.</span><br></pre></td></tr></table></figure><p>用法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">protocolMainLoop</span><span class="params">()</span> *<span class="title">tcpip</span>.<span class="title">Error</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// One time set-up.</span></span><br><span class="line">    s := sleep.Sleeper&#123;&#125;</span><br><span class="line"></span><br><span class="line">    funcs := []<span class="keyword">struct</span> &#123;</span><br><span class="line">            w *sleep.Waker</span><br><span class="line">            f <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">        &#125;</span>&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.sndWaker,</span><br><span class="line">                f: e.handleWrite,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.sndCloseWaker,</span><br><span class="line">                f: e.handleClose,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                w: &amp;e.newSegmentWaker,</span><br><span class="line">                f: e.handleSegments,</span><br><span class="line">            &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> funcs &#123;</span><br><span class="line">        s.AddWaker(funcs[i].w, i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Called repeatedly.</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        v, _ := s.Fetch(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">if</span> !funcs[v].f() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入循环以后，就是 endpoint 的 sender 和 receiver 的工作了，TCP 实现的总体结构就是这样了。接下来需要仔细看看连接如何建立，如何三次握手，以及连接建立后如何控制流量与拥塞控制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;netstack 是 Google 开源的用 Go 语言实现的网络协议栈。在之前的几篇文章中我们简要的了解了 TCP 协议的基本内容，接下来我会通过读源码来加深对协议的理解，学习如何架构一个比较复杂的项目。当然只会对源码进行大致的分析以及梳理关键点
      
    
    </summary>
    
      <category term="netstack_tcp" scheme="http://littlechao.top/categories/netstack-tcp/"/>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
      <category term="netstack" scheme="http://littlechao.top/tags/netstack/"/>
    
  </entry>
  
  <entry>
    <title>Intellij 自定义注释</title>
    <link href="http://littlechao.top/2018/04/15/intellij%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A/"/>
    <id>http://littlechao.top/2018/04/15/intellij 自定义注释/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.312Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有时候在读好的代码的时候想要自己加上一些注释，并且为了和原来的注释区分开，想让它高亮显示，应该怎么设置呢？</p></blockquote><h4 id="steps"><a href="#steps" class="headerlink" title="steps"></a>steps</h4><ul><li>打开 preference –&gt; editor –&gt; TODO </li><li>在 Patterns 里添加一行, 填写 \b<strong>name</strong>\b.*, 其中 name 就是你的自定义注释，选择颜色，然后就 OK 啦！</li><li>使用的时候按照 todo 那种注释写，不过把 todo 换成你自定义的就好啦</li></ul><p>如图：<br><img src="/images/intellij/example.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;有时候在读好的代码的时候想要自己加上一些注释，并且为了和原来的注释区分开，想让它高亮显示，应该怎么设置呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;steps&quot;&gt;&lt;a href=&quot;#steps&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="Intellij" scheme="http://littlechao.top/tags/Intellij/"/>
    
  </entry>
  
  <entry>
    <title>TCP 疑难杂症</title>
    <link href="http://littlechao.top/2018/04/05/tcp_faq/"/>
    <id>http://littlechao.top/2018/04/05/tcp_faq/</id>
    <published>2018-04-04T16:00:00.000Z</published>
    <updated>2018-05-29T14:20:24.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-的一些问题与解答"><a href="#TCP-的一些问题与解答" class="headerlink" title="TCP 的一些问题与解答"></a>TCP 的一些问题与解答</h2><h4 id="TCP-连接的初始化序列号能否固定"><a href="#TCP-连接的初始化序列号能否固定" class="headerlink" title="TCP 连接的初始化序列号能否固定"></a>TCP 连接的初始化序列号能否固定</h4><p>如果初始化序列号（缩写为ISN：Inital Sequence Number）可以固定，我们来看看会出现什么问题：</p><ul><li>假设ISN固定是1，Client和Server建立好一条TCP连接后，Client连续给Server发了10个包，这10个包不知怎么被链路上的路由器缓存了(路由器会毫无先兆地缓存或者丢弃任何的数据包)，这个时候碰巧Client挂掉了；</li><li>然后Client用同样的端口号重新连上Server，Client又连续给Server发了几个包，假设这个时候Client的序列号变成了5；</li><li>接着，之前被路由器缓存的10个数据包全部被路由到Server端了，Server给Client回复确认号10，这个时候，Client整个都不好了，这是什么情况？我的序列号才到5，你怎么给我的确认号是10了，整个都乱了。</li></ul><p>RFC793](<a href="https://tools.ietf.org/html/rfc793)中，建议ISN和一个假的时钟绑在一起，这个时钟会在每4微秒对" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc793)中，建议ISN和一个假的时钟绑在一起，这个时钟会在每4微秒对</a> ISN 做加一操作，直到超过2^32，又从0开始，这需要4小时才会产生 ISN 的回绕问题，这几乎可以保证每个新连接的ISN不会和旧的连接的 ISN 产生冲突。这种递增方式的 ISN，很容易让攻击者猜测到TCP连接的ISN，现在的实现大多是在一个基准值的基础上进行随机的。</p><h4 id="初始化连接的-SYN-超时问题"><a href="#初始化连接的-SYN-超时问题" class="headerlink" title="初始化连接的 SYN 超时问题"></a>初始化连接的 SYN 超时问题</h4><p>Client发送SYN包给Server后挂了，Server 回给 Client 的 SYN-ACK 一直没收到 Client 的 ACK 确认，这个时候这个连接既没建立起来，也不能算失败。这就需要一个超时时间让 Server 将这个连接断开，否则这个连接就会一直占用Server的SYN连接队列中的一个位置，大量这样的连接就会将Server的 SYN 连接队列耗尽，让正常的连接无法得到处理。</p><p>目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了.所以，总共需要 63s，TCP才会把断开这个连接。</p><p>由于，SYN 超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称 SYN flood 攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。</p><h4 id="TIME-WAIT-状态"><a href="#TIME-WAIT-状态" class="headerlink" title="TIME_WAIT 状态"></a>TIME_WAIT 状态</h4><p><code>TIME_WAIT</code>状态是TCP连接中<strong>主动关闭</strong>连接的一方会进入的状态，在发出最后一个 ACK 包之后，主动关闭方进入 <code>TIME_WAIT</code> 状态，从而确保 ACK 包到达对端，以及等待网络中之前迷路的数据包完全消失，防止端口被复用的时候收到迷路包从而出现收包错误。</p><p><code>TIME_WAIT</code> 状态会持续 2MSL（max segment lifetime）的时间，一般 1 分钟到 4 分钟。在这段时间内端口不能被重新分配使用。</p><p><img src="/images/tcp/four_shakes.png" alt=""></p><p>Linux 上使用 <code>sysctl -a | grep time | grep wait</code> 命令查看如下：</p><p><img src="/images/tcp/msl.png" alt=""></p><h5 id="TIME-WAIT会带来哪些问题呢？"><a href="#TIME-WAIT会带来哪些问题呢？" class="headerlink" title="TIME_WAIT会带来哪些问题呢？"></a>TIME_WAIT会带来哪些问题呢？</h5><ul><li>作为服务器，短时间内关闭了大量的 Client 连接，就会造成服务器上出现大量的TIME_WAIT连接，占据大量的tuple，严重消耗着服务器的资源；</li><li>作为客户端，短时间内大量的短连接，会大量消耗的Client机器的端口，毕竟端口只有65535个，端口被耗尽了，后续就无法在发起新的连接了。</li></ul><h5 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h5><p>服务端为了解决这个 TIME_WAIT 问题，可选的方式有3种：</p><ul><li>保证由客户端主动发起关闭</li><li>关闭的时候使用 RST 方式（set SO_LINGER）</li><li>对处于 TIME_WAIT 状态的 TPC 允许重用（set SO_REUSEADDR），设置TCP参数 net.ipv4.tcp_tw_reuse = 1 和 net.ipv4.tcp_tw_recycle = 1。注意：使用tcp_tw_reuse和tcp_tw_recycle解决TIME_WAIT过多问题是非常危险的，参考<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="noopener">RFC</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-的一些问题与解答&quot;&gt;&lt;a href=&quot;#TCP-的一些问题与解答&quot; class=&quot;headerlink&quot; title=&quot;TCP 的一些问题与解答&quot;&gt;&lt;/a&gt;TCP 的一些问题与解答&lt;/h2&gt;&lt;h4 id=&quot;TCP-连接的初始化序列号能否固定&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 保活机制</title>
    <link href="http://littlechao.top/2018/04/03/tcp_keepalive/"/>
    <id>http://littlechao.top/2018/04/03/tcp_keepalive/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-05-06T15:45:31.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-保活机制"><a href="#TCP-保活机制" class="headerlink" title="TCP 保活机制"></a>TCP 保活机制</h2><blockquote><p>TCP 协议没有轮询机制，对于一个没有传输数据的连接来说，连接也可以一直保持。理论上，中间路由器可以崩溃和重启，数据线也可以断开再重连，只要两端没有重启或更改 IP ，依然可以保持连接状态。</p></blockquote><p>有的情况下，服务端需要知道客户端是否已经离开以便回收空间；有的情况下，连接很久不需要数据交换，但是我们希望保持一定的数据流。于是设计了<strong>保活机制</strong>。</p><p>保活机制是一种在不影响数据流内容的情况下探测对方的方式。有一个<strong>保活计时器</strong>实现，定时器超时，就发送一个<strong>保活探测包</strong>，另一端收到后会返回相应的 ACK。</p><p>保活功能默认情况下是关闭的。如果在一段时间（保活时间，keepalive time）连接处于非活动状态，开启了保活功能的一端向另一端发送一个探测报文，如果在一定时间（保活时间间隔，keepalive interval）没有收到响应，那么将继续每隔保活时间间隔发送一个探测报文，直到次数达到一个阈值（保活探测数，keepalive probe）,如果仍然没有响应，就认为对方不可达，连接中断。</p><p>在不同的系统中，这些变量默认值如下：</p><table><thead><tr><th style="text-align:left">times\os</th><th>Linux</th><th>FreeBSD</th><th>OSX</th><th>Windows</th></tr></thead><tbody><tr><td style="text-align:left">keepalive time</td><td>2h</td><td>2h</td><td>2h</td><td>2h</td></tr><tr><td style="text-align:left">keepalive interval</td><td>75s</td><td>75s</td><td>75s</td><td>1s</td></tr><tr><td style="text-align:left">Keepalive probe</td><td>9</td><td>8</td><td>9</td><td>10</td></tr></tbody></table><p>保活报文段可以为空报文段，但通常包含一个字节的数据，它的序列号为对方发送的 ACK 的最大序号减 1（为了不影响已到达的报文段）。即使探测报文丢失也不会重传。</p><h4 id="对方的四种状态"><a href="#对方的四种状态" class="headerlink" title="对方的四种状态"></a>对方的四种状态</h4><ul><li>对方主机正常工作，并且可以到达。对方 TCP 响应正常。</li><li>对方主机已崩溃，包括已经关机或正在重启。对方不会响应探测报文，请求端持续发送 Keepalive probe 次的报文，然后关闭连接</li><li>对方主机崩溃并且已经重启。此时对方收到保活探测报文，会返回一个重置报文段，于是请求方关闭连接</li><li>对方主机正常工作，但是网络不可达。</li></ul><p>一般来说主机无法分辨第二种和第四种情况，这也是一种缺陷，比如当中间路由器崩溃时，连接一方发送保活探测，于是只好断开连接。除了第一种情况，请求端的应用层会收到来自 TCP 层的差错报告，比如连接超时、连接重置等等。</p><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h5 id="为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过-2-小时，连接也会关闭呢？"><a href="#为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过-2-小时，连接也会关闭呢？" class="headerlink" title="为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过 2 小时，连接也会关闭呢？"></a>为什么两端主机和中间路由器工作正常，并且链路可达，但是没有超过 2 小时，连接也会关闭呢？</h5><p><img src="/images/tcp/keepalive.png" alt=""></p><p>如图，两个主机之间 TCP 连接的保持同样会受到中间节点的影响，尤其是会受到防火墙（软件或硬件防火墙）的限制。防火墙的工作特性决定了要维护一个网络连接就需要耗费较多的资源，并且企业防火墙常常位于企业网络的出入口，长时间维护非活跃的 TCP 连接必将导致网络性能的下降。因此，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 TCP 连接断连。</p><p>解决方案：</p><ul><li>延长防火墙终止非活跃的 TCP 连接的时间。例如，针对上述案例，可以调节防火墙设置，将时间设置为大于服务器端设定的 2 小时。</li><li>缩短服务器端的 TCP 连接保活时间。缩短该时间的目的是为了在连接被防火墙终止之前发送保活探测报文，既可以探测客户端状态，又可以使连接变为活跃状态。</li></ul><h5 id="为什么说基于TCP的移动端IM仍然需要心跳保活？"><a href="#为什么说基于TCP的移动端IM仍然需要心跳保活？" class="headerlink" title="为什么说基于TCP的移动端IM仍然需要心跳保活？"></a>为什么说基于TCP的移动端IM仍然需要心跳保活？</h5><p>Keep Alive 机制开启后，TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。一般时间为 7200 s（2h），失败后重试 10 次，每次超时时间 75 s。显然默认值无法满足我们的需求，而修改过设置后就可以满足了吗？答案仍旧是否定的。</p><p>考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的<em>连接活着但业务提供方已死的状态</em>，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态，一直向当前服务器发送些必然会失败的请求。</p><p>KeepAlive 并不适用于检测双方存活的场景，这种场景还得依赖于应用层的心跳。应用层心跳有着更大的灵活性，可以控制检测时机，间隔和处理流程，甚至可以在心跳包上附带额外信息。从这个角度而言，应用层的心跳的确是最佳实践。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-保活机制&quot;&gt;&lt;a href=&quot;#TCP-保活机制&quot; class=&quot;headerlink&quot; title=&quot;TCP 保活机制&quot;&gt;&lt;/a&gt;TCP 保活机制&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;TCP 协议没有轮询机制，对于一个没有传输数据的连接来说，连接也可
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 拥塞控制</title>
    <link href="http://littlechao.top/2018/03/30/tcp_congestion_control/"/>
    <id>http://littlechao.top/2018/03/30/tcp_congestion_control/</id>
    <published>2018-03-29T16:00:00.000Z</published>
    <updated>2018-05-12T11:58:23.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><blockquote><p>在上一篇文章中，讲了通过滑动窗口实现发送方和接收方之间一对一的流量控制。这次我们来看一下 TCP 协议是如何对网络进行宏观调控，也就是 TCP 拥塞控制。</p></blockquote><h3 id="网络拥塞"><a href="#网络拥塞" class="headerlink" title="网络拥塞"></a>网络拥塞</h3><p>网络中的路由器因无法处理高速到达的流量而被迫丢弃数据信息的现象称为拥塞。这里可能是因为路由器缓存较小或者处理不及时，虽然和流量控制时接收方的情况相似，但是这里有本质区别。因为后者是一对一的，几乎只影响一条连接；后者则影响多个连接。</p><p>当网络中大量的发送方和接收方被要求承担超负荷的通信任务时，可以采用<strong>降低发送方发送速率</strong>或者<strong>丢弃部分数据</strong>（也可二者结合）来降低拥塞。</p><h4 id="TCP-拥塞检测"><a href="#TCP-拥塞检测" class="headerlink" title="TCP 拥塞检测"></a>TCP 拥塞检测</h4><p>通常来说，接收方没有一个精确的方法去知道中间路由器的状态。目前基本的方法有：</p><ul><li>依据丢包情况，如果有丢包发生，可以认为是网络拥堵引发的丢包，但是丢包本身就是不能精确判断的。并且有时候我们不能判断丢包是因为路由器拥塞造成的还是由传输错误造成的（在无线网络中，传输和接收错误是丢包主要原因）</li><li>通过时延测量，当感知到 RTT 明显增大时，可以认为是网络拥堵。但是 RTT 测量本身也没有精确的方法。</li><li>显式收到一个丢包的消息，也称<strong>显式拥塞通知</strong>（Explicit Congestion Notification, ECN）。路由器在发生拥堵的时候，向数据包的 IP 首部中设置两个 ENC 标志位，发送方收到后可知拥塞发生。接收方收到则将其放到 ACK 报文中返回给发送方，直到发送方发来的报文中 CWR（接下来会说到） 字段被置为了 1。但是这个方法主要的限制是，它还没有被很好的推广，网络中很多路由器还不支持它。</li></ul><h4 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h4><p>之前的文章提到，发送方为了适应接收方接受速度，设置了一个发送窗口来控制流量。同样的，当拥堵发生时，也需要控制发送速率，于是引入了一个窗口变量，来反映网络传输能力，称为<strong>拥塞窗口</strong>（Congestion window），记作 cwnd。很直观的，我们可以知道，发送端实际可用窗口 W 表示如下,其中 awnd 表示接收方窗口大小：</p><p>​                                    <strong>W = min(cwnd, awnd)</strong></p><p>也就是说，还没有收到 ACK 的数据量（也称在外数据量）不能多于 W 。通常 W 以字节或包为单位。很明显， W 的值是在随时变化的，并且我们希望 W 接近一个最佳窗口大小——带宽延时积（Bandwidth-Delay Product, BDP）,BDP 表示某一时刻的在外数据量，但是确定一个连接的 BDP 也是一个难点。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><h4 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h4><p>当连接建立之初，还无法获知可用的连接资源，也无法确定 cwnd 初始值（有例外，就是之前文章里提到的目的度量）。这时候不应该直接大量快速的向网络中发送数据，因为会造成更严重的网络拥堵。获得 cwnd 最佳值的唯一方法就是以越来越快的速度发包，直到有数据包丢失（或网络拥堵）。可以考虑<strong>慢启动</strong>发送。在讨论具体算法之前，需要先了解<strong>数据包守恒</strong>的概念。</p><p><img src="/images/tcp_congestion/packet_balance.png" alt=""></p><p>TCP 发送端的拥塞控制行为是由 ACK 的接收来驱动或“控制”的。并且链路的传输能力是固定的，当发送方接收到一个 ACK 时，就表示链路上多了一个“空位”，于是发送方可以再发送一个数据包。数据包守恒就是指链路中最大包的数量守恒。</p><h4 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h4><p><strong>当一个连接刚启动时，或者检测到重传超时导致的丢包时，需要执行慢启动</strong>； TCP 长时间处于空闲状态也可能触发慢启动。其目的是探寻到 cwnd 值已经帮助 TCP 建立 ACK 时钟。</p><p>TCP 发送一定数目的报文开始慢启动，该数目称为初始窗口（IInitial Window，IW）。为了简便，我们讨论 IW 为一个 SMSS （sender’s MSS）的情况。意味着初始 cwnd 大小为 1 SMSS。</p><p>假设没有丢包且每一个数据都有相应的 ACK。那么第一个 ACK 到达，说明可以再发送一个新的报文段（数据包守恒），每收到一个“好的” ACK，<strong>cwnd = cwnd + min(N, SMSS)</strong>，这里的 N 是指那个“好的” ACK 所确认的字节数。所谓“好的”是指 ACK 号使窗口更新了。</p><p>因为通常来说 N 的值等于 SMSS，使得 cwnd 在收到一个 ACK 后增大一倍。所以慢启动实际上是以指数增长，在 K 轮之后，cwnd = 2^K。如下图：</p><p><img src="/images/tcp_congestion/slow_start.png" alt=""></p><p>当接收方开启延时 ACK，则发送方 cwnd 增长曲线如图中蓝色曲线，虽然起步看起来慢，但仍是指数增长。当然这对于带宽延时积很大的网络来说，确实有所浪费，应该采用更好的办法。</p><p>当然不可能让窗口大小无限增长，否则会造成严重的网络拥堵直至网络瘫痪。在上述情况下，cwnd 将大幅减小（减至原值一半），也是慢启动和<strong>拥塞避免</strong>的转折点，与<strong>慢启动阈值</strong>（slow start threshold, ssthresh）有关。</p><h4 id="避免拥塞"><a href="#避免拥塞" class="headerlink" title="避免拥塞"></a>避免拥塞</h4><p>当 cwnd 达到 ssthresh 时，可能还有一些传输资源未被占用。但这时候需要谨慎的试探，不能再以较快速度增大 cwnd。采用避免拥塞算法，每接收到一个新的 ACK，cwnd 会做以下更新：</p><p>​                            <strong>cwnd = cwnd + SMSS * SMSS / cwnd</strong></p><p>假设 cwnd = k * SMSS，则可推导如下：</p><p>​                                <strong>cwnd = cwnd + SMSS / k</strong></p><p>发包来看像这样：</p><p><img src="/images/tcp_congestion/ss_ca.png" alt=""></p><p>通常认为拥塞避免阶段 cwnd 呈线性增长，称为累加增长。</p><h4 id="慢启动-和-拥塞避免-的选择"><a href="#慢启动-和-拥塞避免-的选择" class="headerlink" title="慢启动 和 拥塞避免 的选择"></a>慢启动 和 拥塞避免 的选择</h4><p>通常 TCP 连接总是会选择慢启动和拥塞避免中的一个，依据就是之前提到的慢启动阈值。当 cwnd &lt; ssthresh，采用慢启动算法， cwnd &gt; ssthresh 采用拥塞避免，相等时选择任意都行。所以关键就是 ssthresh 的值，该值并不是固定的，它的主要目的是，<strong>记录上一次最好的窗口估计值</strong>。</p><p>ssthresh 初始值可以任意设定（如 awnd 或更大），这通常会使 TCP 总是以慢启动开始。当出现重传，无论是超时重传还是快速重传，都会导致 ssthresh 值更新如下：</p><p>​                            <strong>ssthresh = max(在外数据值 / 2, 2 * SMSS)</strong></p><p>在外数据值其实就是当前窗口大小。这样通常会使 ssthresh 变小（但也可能使其变大），然后触发拥塞避免。</p><h4 id="Tahoe、Reno、快速恢复-、-标准-TCP"><a href="#Tahoe、Reno、快速恢复-、-标准-TCP" class="headerlink" title="Tahoe、Reno、快速恢复 、 标准 TCP"></a>Tahoe、Reno、快速恢复 、 标准 TCP</h4><blockquote><p>接下来讨论的几个算法是将慢启动和拥塞避免结合使用，并且实现一些优化。</p></blockquote><p>Tahoe 算法规定当重传时，都会进入慢启动，并且丢包时，将 cwnd 设为 1 SMSS。这显然性能不太好，已被弃用，不用深究。</p><p>Reno 算法是标准 TCP 的基础，它根据之前提到的“包守恒”实现了快速恢复，较好的利用了带宽。快速恢复是针对快速重传的情景实现的，来看一下它在标准 TCP 中的使用：</p><ul><li><p>TCP 连接之初采用慢启动，cwnd = 1 SMSS</p></li><li><p>每收到一个好的 ACK，cwnd 就会相应更新：</p><ul><li>cwnd += SMSS     (cwnd &lt; ssthresh )</li></ul></li></ul><ul><li>cwnd += SMSS * SMSS / cwnd       (cwnd &gt; ssthresh)</li></ul><ul><li><p>收到三次冗余 ACK时，执行以下行为：</p><ul><li><p>更新 ssthresh</p></li><li><p>启动快速重传算法，<strong>将 cwnd 设为 ssthresh + 3 * SMSS</strong>（依据包守恒，因为已经有三个包已经收到）</p></li><li><p>每收到一个冗余 ACK，再将 cwnd 增加 1 SMSS</p></li><li><p>当收到一个好的 ACK，说明已经恢复正常，则将 cwnd 重新置为 ssthresh</p><p>注：以上 2、3 步构成了快速恢复,如图：</p></li></ul></li></ul><p><img src="http://7fvbl4.com1.z0.glb.clouddn.com/mmtrix_TCP%E5%8D%8F%E8%AE%AE%E6%A0%886" alt=""></p><p>以下是 Reno 的状态转换图：</p><p><img src="/images/tcp_congestion/reno_fsm.png" alt=""></p><h4 id="NewReno"><a href="#NewReno" class="headerlink" title="NewReno"></a>NewReno</h4><p>Reno 算法在同一窗口下丢失多个包时，其中一个包快速重传成功，就会停止 cwnd 膨胀，造成其它丢失的包可能触发超时重传，然后 cwnd 降为 1 SMSS，吞吐量大大降低。NewReno 采用了一个“恢复点”，指的是收到的 ACK 号大于已发送包的序列号的最大值，达到这个恢复点，才会退出快速恢复。下图最右图中， ACK11 达到了恢复点。</p><p><img src="/images/tcp_congestion/reno_newReno.png" alt=""></p><h4 id="限制传输"><a href="#限制传输" class="headerlink" title="限制传输"></a>限制传输</h4><p>限制传输策略对 TCP 做了微小改进，主要是为了解决窗口较小时，出现丢包，但是没有足够的包去引发快速重传/快速恢复机制。为了尽快触发快速重传，每接收两个连续重复 ACK，就发送一个新的包，使网络中的数据量维持一定数量。这是 TCP 推荐策略。</p><h4 id="拥塞窗口校验"><a href="#拥塞窗口校验" class="headerlink" title="拥塞窗口校验"></a>拥塞窗口校验</h4><h5 id="发送端受限"><a href="#发送端受限" class="headerlink" title="发送端受限"></a>发送端受限</h5><blockquote><p>发送端可能出现发送受限， cwnd 的值就会变的不那么准确。</p></blockquote><ul><li>空闲阶段（idle period）：发送端暂时没有发送的需求，并且之前发送的数据都已经收到 ACK</li><li>应用受限（application-limited period）：发送方实际发送的数据小于 cwnd，并且可能仍有 ACK 未收到</li></ul><p>这里对应 TCP/IP 详解卷一里，书上对于“应用受限”说法不正确。书上说此时“无法发送”，但是查阅 rfc 原文如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;application-limited period&quot; for the time when the sender sends less than is allowed by the congestion or receiver windows.</span><br></pre></td></tr></table></figure><h5 id="CWV"><a href="#CWV" class="headerlink" title="CWV"></a>CWV</h5><p>拥塞窗口校验（Congestion Window Validation）机制规定，需要发送新数据时，距离上次发送操作超过一个 RTO，如果是：</p><ul><li>空闲阶段：<ul><li>ssthresh = max(ssthresh, 0.75 * cwnd)</li><li>每隔一个 RTT，cwnd 减半，但不小于 1 SMSS</li></ul></li><li>应用受限：<ul><li>实际使用的窗口大小记为 W_used</li><li>ssthresh = max(ssthresh, 0.75 * cwnd)</li><li>cwnd = (cwnd + W_used) / 2</li></ul></li></ul><p>在长时间发送暂停后，cwnd 低于 ssthresh，再次发送时会进入慢启动。Linux 默认开启 CWV。</p><h3 id="伪-RTO-处理-——-Eifel-算法"><a href="#伪-RTO-处理-——-Eifel-算法" class="headerlink" title="伪 RTO 处理 —— Eifel 算法"></a>伪 RTO 处理 —— Eifel 算法</h3><p>在之前的超时重传里，我们提到了 伪超时，再来回顾下(注意下图是相当简易的情形，没有考虑延时 ACK 以及 cwnd 增长，会意即可)：</p><p><img src="/images/tcp_congestion/fake_timeout_retrans.png" style="height:400px"></p><p>伪超时可能引起“回退 N 步”的行为，并且可能触发快速重传，浪费不少资源。</p><h5 id="Eifel-检测算法"><a href="#Eifel-检测算法" class="headerlink" title="Eifel 检测算法"></a>Eifel 检测算法</h5><p>该算法利用 TCP 的 TSOPT 选项，在发送生超时后，重传报文并记录 TSV，期待一个 ACK，若 ACK 的 TSER 小于重传报文的 TSV，则认为该 ACK 是对原始报文的确认而不是对重传报文的确认，即认定该重传是伪重传。</p><h5 id="Eifel-响应"><a href="#Eifel-响应" class="headerlink" title="Eifel 响应"></a>Eifel 响应</h5><p>前面提到过，发生超时，则 ssthresh 减半，cwnd 降为 1 SMSS。发生伪超时的话，在 RTO 之后到来的 ACK 会使 cwnd 快速变大，但仍会有不必要重传。</p><p>采用 Eifel 算法，在判定伪超时后，会撤销对 ssthresh 的修改。在每次超时对 ssthresh 修改之前，会用 pipe_prev 变量来保存当前的 ssthresh，以便撤销修改。</p><p>若出现伪重传，当 ACK 到达时，假设 ACK 确认的报文段长度为 A：</p><ul><li>cwnd = 在外数据值 + min(A，IW)</li><li>ssthresh = pipe_prev</li></ul><h3 id="窗口缩减行为"><a href="#窗口缩减行为" class="headerlink" title="窗口缩减行为"></a>窗口缩减行为</h3><p>前面讨论了当失序或者超时的时候 TCP 的行为，这些行为都是通过 ACK 的反馈来触发或者驱动的，换句话说，这些“拥塞”的情况是“猜出来的”。当明确知道发生拥堵了，TCP 会执行<strong>拥塞窗口缩减</strong>（congestion window reducing，CWR）。明确知道拥堵的情况主要有两种：</p><ul><li>收到携带了 ENC-Echo 的报文，由路由器给出的网络拥堵信息</li><li>本地拥堵，上层应用发送速率大于下层协议发送速率</li></ul><p>CWR 处理过程如下：</p><ul><li>ssthresh = cwnd / 2</li><li>cwnd = min(cwnd, 在外数据值 + 1)</li><li>每收到 2 个 ACK，将 cwnd 减 1</li></ul><p>直到 cwnd 达到新的 ssthresh 值或者由于其他原因（如丢包）打断 CWR。</p><h3 id="拥塞控制状态机"><a href="#拥塞控制状态机" class="headerlink" title="拥塞控制状态机"></a>拥塞控制状态机</h3><blockquote><p>这部分内容 TCP/IP 详解卷没有，是从<a href="https://pdfs.semanticscholar.org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf" target="_blank" rel="noopener">这篇论文</a>里总结的，希望能够帮助理解拥塞控制状态。</p></blockquote><p>到此，我们总结一下 TCP 拥塞控制的几个重要状态：</p><ul><li>Open —— 未出现超时或者失序，按照慢启动或者避免拥塞正常处理 ACK</li><li>Lost —— 出现超时重传</li><li>DisOrder —— 失序</li><li>Recover —— 快速重传引发的快速恢复</li><li>CWR —— 明确拥塞时的窗口缩减状态，可打断</li></ul><p><img src="/images/tcp_congestion/congestion_fsm.png" alt=""></p><h3 id="缓冲区膨胀"><a href="#缓冲区膨胀" class="headerlink" title="缓冲区膨胀"></a>缓冲区膨胀</h3><p>这个问题还是很有趣的，所以拿出来讲一下。先说结论，网络设备的缓冲区并不是越大越好，也不是越小越好，而是需要根据链路速率和RTT进行计算，得到一个经验值。</p><h5 id="缓存区过小"><a href="#缓存区过小" class="headerlink" title="缓存区过小"></a>缓存区过小</h5><p>缓冲区过小的问题很明显，如果缓冲区太小，很容易就被写满了，只要不能进行适当的排队，丢包率会高，导致传输效率差。</p><h5 id="缓存区过大"><a href="#缓存区过大" class="headerlink" title="缓存区过大"></a>缓存区过大</h5><p>假设如下场景：</p><p><img src="/images/tcp_congestion/big_cache.png" alt=""></p><p>上图中，我们假设中间的路由设备的buffer极大，理论来说无论来多少数据，都能buffer起来。中间的路由设备，接收速率是1M/s，而发送速率只有10k/s。</p><p>到某一时刻，发送方认为某一数据超时丢失（实际上没有丢失，而是在缓冲区没来得及处理），于是重发，导致缓存区有冗余数据。大量的冗余数据导致利用率变得极低。</p><p>而缓冲区为正常大小的时候，多的数据会被丢弃，过一会而缓冲区有新的位置，新的数据会到来，接收方收到数据是失序的，于是发送冗余 ACK，促进快速重传，反而使链路利用率得到保障。</p><h3 id="与拥塞控制相关的攻击"><a href="#与拥塞控制相关的攻击" class="headerlink" title="与拥塞控制相关的攻击"></a>与拥塞控制相关的攻击</h3><p>大多数攻击是强迫 TCP 发送速率比一般情况更快或更慢。</p><h5 id="ACK-分割攻击"><a href="#ACK-分割攻击" class="headerlink" title="ACK 分割攻击"></a>ACK 分割攻击</h5><p>原理是接收方将原来的确认范围划分成很多小块，把一个 ACK 变成多个 ACK，使得发送方不断增大 cwnd，使网络变的拥堵。可以通过计算每个 ACK 的确认量（而不是一个包）来判断是否是正确的 ACK。</p><h5 id="乐观响应攻击"><a href="#乐观响应攻击" class="headerlink" title="乐观响应攻击"></a>乐观响应攻击</h5><p>接收方对还没到达的数据进行提前确认，使得 RTT 变得比较小，同样使得发送方不断增大 cwnd。可以采用一个可累加的随机数，动态匹配 ACK。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://tools.ietf.org/html/rfc7661" target="_blank" rel="noopener">rfc</a></li></ul><ul><li><p><a href="https://pdfs.semanticscholar.org/0e9c/968d09ab2e53e24c4dca5b2d67c7f7140f8e.pdf" target="_blank" rel="noopener">Congestion Control in Linux TCP</a></p><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-拥塞控制&quot;&gt;&lt;a href=&quot;#TCP-拥塞控制&quot; class=&quot;headerlink&quot; title=&quot;TCP 拥塞控制&quot;&gt;&lt;/a&gt;TCP 拥塞控制&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在上一篇文章中，讲了通过滑动窗口实现发送方和接收方之间一对一的流量
      
    
    </summary>
    
      <category term="网络" scheme="http://littlechao.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 数据流与窗口管理</title>
    <link href="http://littlechao.top/2018/03/26/tcp_window_management/"/>
    <id>http://littlechao.top/2018/03/26/tcp_window_management/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-05-06T15:46:24.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-数据流与窗口管理"><a href="#TCP-数据流与窗口管理" class="headerlink" title="TCP 数据流与窗口管理"></a>TCP 数据流与窗口管理</h2><h3 id="交互式通信"><a href="#交互式通信" class="headerlink" title="交互式通信"></a>交互式通信</h3><p>ssh 是一个典型的交互式通信协议，它是加密了的，通常每次按键都会生成一个单独的包。另外，ssh 会在服务端对客户端输入的字符进行回显。因此，服务端收到数据包会先发送一个 ACK，然后发送一个回显报文，再由客户端发送对回显报文段的 ACK，如下左图。</p><p><img src="https://image.littlechao.top/20180317033327000018.jpg" alt=""></p><p>但通常第二段和第三段可以合并来减少传输次数，这种方法称为捎带延时确认，如上右图。我们可以再来看看 wireshark 抓的包:</p><p><img src="https://image.littlechao.top/20180317041434000021.jpg" alt=""></p><p>不难发现，这些包三个为一组，先是客户端(192.168.0.120)发送一个加密的包，然后收到服务端一个加密包，然后客户端回复一个 ACK。看一下服务端发过来的包：</p><p><img src="https://image.littlechao.top/20180317043335000022.jpg" alt=""></p><p>可以看到，标志位的 ACK 置为了 1，ACK 值为 145，PSH 位也置为了 1（表明收到后立刻返回给应用层），并且数据段不为空，说明包含了回显的部分。很明显这里采用了捎带延时确认。</p><h3 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h3><p>在很多情况下，TCP 累计确认可以允许延迟一小会儿发送 ACK，以便结合相同方向的数据一起传送。但是显然，TCP 不能延时任意时长，通常建议：TCP 实现延迟应小于 500 ms，实践中延时应小于 200 ms。该延时值是可以配置的可选值如下：禁用延时，始终延时，每隔一个包回复一个 ACK，自动确认时间；默认值为 3。</p><h3 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h3><p>通常在类似于 ssh 这样的应用里，每次传输的数据包非常小，称为微型报文，这些报文会造成相当高的传输代价。可以采用 Nagle 算法来解决这类问题。</p><p>Nagle 算法规定，当一个 TCP 连接有在传数据时，小的报文段（长度小于 SMSS）不会被发送，直到所有在传数据都收到 ACK。并且收到 ACK 后，会收集小数据并整合到一个报文段发送。</p><p>下图为 ssh 应用中没有开启 Nagle 算法（左图）和开启 Nagle 算法（右图）的差别。</p><p><img src="https://image.littlechao.top/20180317121248000003.jpg" height="400px"></p><p>可以看到，没有开启时，同一时刻有很多包在传输，并且有很多小包（tinygram），总体时间短，但是网络负担大。开启了 Nagle 算法时，同一时刻只有一个方向的传输，并且在合适的情况下，合并小包一起发送，时间较长，但传输次数少，网络负担小。</p><h4 id="延时-ACK-与-Nagle-结合"><a href="#延时-ACK-与-Nagle-结合" class="headerlink" title="延时 ACK 与 Nagle 结合"></a>延时 ACK 与 Nagle 结合</h4><p>无论是延迟 ACK 还是 Nagle 算法，其目的都是减少网络中传输的包，减轻网络负担。但是二者一起使用时，可能会出现问题。</p><p>考虑如下情况：客户端依次要发送一个全长报文段以及若干个小包，服务端收到第一个全长包，然后延迟发送 ACK（延时，或者期待第二个全长报文段到达），而客户端采用了 Nagle 算法，需要等到 ACK 到达才能继续发送。这样就会形成一个短暂的死锁，性能反而变差。所以在有些情况下，如 ssh ，可以禁用 Nagle 算法。</p><h3 id="流量控制与窗口管理"><a href="#流量控制与窗口管理" class="headerlink" title="流量控制与窗口管理"></a>流量控制与窗口管理</h3><p> 每个 TCP 报文段的首部里都包含了一个窗口大小字段，该字段占 16 位，最大表示 65536，也就是 64 KB，但 TCP 选项中的窗口缩放选项可以让它表示更大的窗口。</p><p>一般来说每个连接的接收端会有一个大小固定的缓存，用来暂存发送端发来的数据，然后由应用程序读取。当应用程序来不及处理缓存数据，而发送方又不停的发送数据，超出缓存大小，就会造成数据丢失和不必要的重传。窗口大小字段用于 TCP 的流量控制，用于表示接收端可用缓存大小。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h5 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h5><p>每个 TCP 连接的两端都维护了一个发送窗口，结构如下：</p><p><img src="http://www.tcpipguide.com/free/diagrams/tcpswwindows.png"></p><p>主要分四部分：已经发送并收到确认、已经发送但未收到确认、未发送但可以发送、未发送并且目前不能发送。第三部分称为<strong>可用窗口</strong>，第二部分和第三部分合称<strong>发送窗口</strong>。随着时间推移，窗口可以有几种运动：</p><ul><li>关闭：随着 ACK 到来，发送窗口左边界向右移，窗口减小。</li><li>打开：窗口右边界右移，即接收方可用缓存增大，发送方可用窗口也就增大。</li><li>收缩：右边界左移，主机不支持这种做法，但 TCP 必须能处理这种问题。</li></ul><h5 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h5><p>除了发送窗口，接收方还维护了一个接收窗口。</p><p><img src="http://www.tcpipguide.com/free/diagrams/tcpswpointersreceive.png" alt=""></p><p>接收窗口结构简单，包括已经接收且已经回复 ACK、允许对方发送但还未收到、目前不允许对方发送的部分。</p><h5 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h5><p>接收方收到一个数据包后，返回一个 ACK，根据自己的可用接收缓存大小设置 ACK 报文里的窗口大小。发送方收到这个窗口通告后，根据可用窗口大小调整自己的发送窗口，以达到调节发送速率的目的。</p><h4 id="零窗口与-TCP-持续计时器"><a href="#零窗口与-TCP-持续计时器" class="headerlink" title="零窗口与 TCP 持续计时器"></a>零窗口与 TCP 持续计时器</h4><p>当发送方不停发送，接收方又比较忙的时候，可能会导致可用窗口大小为 0。当出现零窗口时，发送方收到一个 ACK 报文，其中的窗口大小为零，那么就表示暂时不能发送数据。而当接收方应用程序开始处理收到的数据，使得接收缓存里又有了空间，但是我们知道，窗口通告是包含在 ACK 报文里的，没有收到新的数据，就没法发送窗口通告，这时就会造成死锁。</p><p>所以当出现零窗口时，发送方会采用一个<strong>持续计时器</strong>间歇地查询接收端是否有可用窗口，持续计时器会触发<strong>窗口探测</strong>（window probe）的传输。为了保证对方能够收到查询，我们必须要往数据段放一些数据，以保证超时重发，通常会放一个字节的数据 。接收方收到窗口探测后，会被强制返回一个 ACK，并且包含自己当前可用窗口大小（这个大小会有特殊情况）。注意这里采用指数退避来计算持续计时器的超时时间。</p><p>前面谈到，大量数据量较小的包会造成传输速度的下降，也会造成网络负担。当接收端可用缓存从 0 慢慢增大到一个较小的值，这时候收到一个窗口探测，为了避免发送较小的包，接收端可以仍然在 ACK 中回复一个零窗口。</p><p><img src="https://www.brianstorti.com/assets/images/tcp-flow-control/window-probe.png" alt=""></p><h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h4><p>当发送方发送的报文大小不固定时，可能会出现<strong>糊涂窗口综合征</strong>（Silly Window Syndrome，SWS）。当出现该问题时，交换的报文数据段大小较小，耗费的资源较多。</p><p>TCP 连接两端都可能导致 SWS：当接收端的通告窗口较小（或者是还没等到窗口变得够大），或者发送端发送的包较小（或者是没有等待其他小数据组合成大数据包）。为了避免 SWS，发送方要遵循一定规则。</p><p>对于接收方：</p><ul><li>不应通告小的窗口值。在窗口增至 min(MSS，接收端缓存的一半) 之前，不能通告比当前窗口（可能为 0）更大的值</li></ul><p>对于发送方，满足任意一个：</p><ul><li>全长报文段可以发送</li><li>数据段长度 &gt;= 最大窗口通告的一半</li><li>该连接禁用 Nagle 算法</li><li>没有未经确认的在传数据</li></ul><h4 id="大容量缓存与自动调优"><a href="#大容量缓存与自动调优" class="headerlink" title="大容量缓存与自动调优"></a>大容量缓存与自动调优</h4><p>在相似的环境下，较小的接收缓存的 TCP 应用吞吐性能会较低。很多 TCP 协议栈中上层应用不能指定接收缓存大小，由操作系统来指定一个固定的或者动态变化的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-数据流与窗口管理&quot;&gt;&lt;a href=&quot;#TCP-数据流与窗口管理&quot; class=&quot;headerlink&quot; title=&quot;TCP 数据流与窗口管理&quot;&gt;&lt;/a&gt;TCP 数据流与窗口管理&lt;/h2&gt;&lt;h3 id=&quot;交互式通信&quot;&gt;&lt;a href=&quot;#交互式通信&quot; c
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 超时重传</title>
    <link href="http://littlechao.top/2018/03/20/tcp_retransmission/"/>
    <id>http://littlechao.top/2018/03/20/tcp_retransmission/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-05-06T15:45:31.352Z</updated>
    
    <content type="html"><![CDATA[<p>##TCP超时重传</p><blockquote><p>TCP 提供可靠数据传输服务，为保证传输正确性，TCP 重传其认为已经丢失的包。TCP 有两套重传机制，一是基于定时器（超时），二是基于确认信息的构成（快速重传）。</p></blockquote><p>###基于计时器的重传</p><h4 id="简单的超时重传"><a href="#简单的超时重传" class="headerlink" title="简单的超时重传"></a>简单的超时重传</h4><p><img src="https://image.littlechao.top/20180315023638000003.jpg" alt=""></p><p>图中黑色那条就是因为定时器超时仍没有收到 ACK，所以引起了发送方超时重传。实际上 TCP 有两个阈值来决定如何重传同一个报文段：一是愿意重传的次数 R1、二是应该放弃当前连接的时机 R2。R1 和 R2 的值应分别至少为 3 次和 100 秒，如果超过任何一个但还没能重传成功，会放弃该连接。当然这两个值是可以设置的，在不同系统里默认值也不同。</p><p>那么如何设定一个合适的超时的值呢？假设 TCP 工作在静态环境中，这很容易，但真实网络环境不断变化，需要根据当前状态来设定合适的值。</p><h4 id="超时时间-RTO"><a href="#超时时间-RTO" class="headerlink" title="超时时间 RTO"></a>超时时间 RTO</h4><p>RTO（retransmission timeout）一般是根据RTT（round trip time）也就是往返时间来设置的。若 RTO 小于   RTT，则会造成很多不必要的重传；若 RTO 远大于 RTT，则会降低整体网络利用率，RTO 是保证 TCP 性能的关键。并且不同连接的RTT不相同，同一个连接不同时间的 RTT 也不相同，所以 RTO 的设置一直都是研究热点。</p><p>所以凭我们的直觉，RTO 应该比 RTT 稍大：</p><p>​                                    <strong>RTO=RTT+Δt</strong></p><p>那么，RTT 怎么算呢：</p><p>​                            <strong>SRTT=(1−α)×SRTT+α×RTTnew</strong></p><p>SRTT(smooth RTT)，RTTnew 是新测量的值。如上，为了防止 RTT 抖动太大，给了一个权值 <strong>a</strong> ，也叫平滑因子。a 的值建议在 10%~20%。举个例子，当前 RTTs=200ms，RTTs=200ms，最新一次测量的 RTT=800ms，RTT=800ms，那么更新后的 RTTs=200×0.875+800×0.125=275ms，RTTs=200×0.875+800×0.125=275ms.</p><p><strong>Δt</strong>如何得到呢？RFC 2988 规定：</p><p>​                                <strong>RTO=SRTT+4×RTTD</strong></p><p>因此，按照上面的定义，<strong>Δt=4×RTTD</strong>. 而 RTTD 计算公式如下：</p><p>​                            <strong>RTTD=(1−β)×RTTD+β×|SRTT−RTTnew|</strong></p><p>实际上，RTTD 就是一个均值偏差，它就相当于某个样本到其总体平均值的距离。这就好比你的成绩与你班级平均成绩差了多少。RFC 推荐 β=0.25。</p><h5 id="退避指数"><a href="#退避指数" class="headerlink" title="退避指数"></a>退避指数</h5><p>根据前面的公式，我们可以得到 RTO。一旦超过 RTO 还没收到 ACK，就会引起发送方重传。但如果重传后还是没有在 RTO 时间内收到 ACK，这时候会认为是网络拥堵，会引发 TCP 拥塞控制行为，使 RTO 翻倍。则第 n 次重传的 RTOn 值为：</p><p>​                                <strong>RTOn=2^(n−1)×RTO1</strong></p><p>下图是一个例子：</p><p><img src="http://img.blog.csdn.net/20170422182458581?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTEwMDc3Mjk5OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源：http://blog.csdn.net/q1007729991/article/details/70196099"></p><p>如上，在时间为0.22531时开始第一次重传，此后重传时间开始指数增大，（在尝试了8次后停下，说明其 R2 的值可能为8）。</p><h4 id="带时间戳的-RTT-测量"><a href="#带时间戳的-RTT-测量" class="headerlink" title="带时间戳的 RTT 测量"></a>带时间戳的 RTT 测量</h4><p>前面说了 RTO 的公式，它和 RTT 有关，那么每一次的 RTT 是如何得到的呢？在之前 TCP 连接管理的时候讲过，TCP有一个 TSOPT (timestamp option) 选项，它包含两个时间戳值。它允许发送者在报文中带上一个32比特的时间戳值（TSV），然后接收方 将收到的值原封不动的填入 ACK 报文段中 TSOPT 选项的第二部分，时间戳回显字段（TSER）。发送方收到 ACK 以后，将当前时间戳减去 TSOPT 选项的 TSER 就可得到精确的RTT值。</p><blockquote><p>但是这里有很微妙的细节：接收方在收到数据包后，并不是立即发送 ACK，通常会延时“一小会儿”，多等待几个数据包后返回一个累积 ACK。此时接收方将确认时间最近的报文段的 TSV 填入 TSER 发送给发送方。</p></blockquote><h5 id="重传二义性与-Karn-算法"><a href="#重传二义性与-Karn-算法" class="headerlink" title="重传二义性与 Karn 算法"></a>重传二义性与 Karn 算法</h5><p>还有另一个重要的细节，如果测量 RTT 的样本出现了超时重传，但是我们收到了 ACK 时无法分辨是对哪一次的确认，这时候 RTT 的值可能是不正确的。</p><p>因此，Karn 算法规定：<strong>此时不更新 RTTnew 的值</strong>。并且如果发生再次重传，则采用退避后的 RTO 的值，直到发送成功，退避指数重新设定为 1 。</p><h5 id="丢包和失序的情况"><a href="#丢包和失序的情况" class="headerlink" title="丢包和失序的情况"></a>丢包和失序的情况</h5><p>假设有三个数据包依次发送，1号和3号先到达，2号数据包由于网络因素最后到达。接收方收到3号时，会发送一个1号的冗余 ACK，然后2号到达，此时会发送一个3号的累积 ACK 表明这三个到达。在这个例子里，3号 ACK 并没有立即返回，发送方收到3号的 ACK 后，根据其 TSER 计算此时的 RTT，就会导致发送方过高的估计 RTT，降低重传积极性，使得 RTO 相应增大，当然这在失序时是有好处的，因为过分积极会导致大量的伪重传。</p><h4 id="伪超时与重传"><a href="#伪超时与重传" class="headerlink" title="伪超时与重传"></a>伪超时与重传</h4><p>如下图，在发送第四个 ACK 后出现延迟高峰，导致发送方在 RTO 时间内没有收到 5 ~ 8 的 ACK，于是发生重传，然后之前的 ACK 到达，于是又依次发送 6 ~ 8，就导致了不必要的重传。可以用 Eifel 算法来解决（略）。</p><p><img src="https://image.littlechao.top/20180315075511000005.jpg" style="height:400px"></p><h4 id="目的度量"><a href="#目的度量" class="headerlink" title="目的度量"></a>目的度量</h4><p>从前面可以看出，TCP 可以学习链路特征，如 RTT、SRTT 等，但一旦连接关闭，这些信息就会丢失。即使相同的接收方与发送方建立新的连接，也必须从头开始“学习”。较新的 TCP 实现维护了这些值，在 Linux 中可以通过如下命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route show cache [ip]</span><br></pre></td></tr></table></figure><p>###基于确认信息的重传</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>在大多数情况下，计时器超时并触发重传是不必要的，也不是期望的，因为 RTO 通常是大于 RTT（约2倍或更大），因此基于计时器的重传会导致网络利用率降低。</p><p>首先我们要知道，接收方收到失序报文段时，应立即生成确认信息（重复 ACK），以便发送方尽快、高效地填补空缺。而发送方在收到重复 ACK 时，无法判断是由于数据包丢失还是仅仅因为延迟，所以发送方等待一定数目的重复 ACK （重复 ACK 阈值，dupthresh），这时可以认为是数据包丢失，即便还未超时，也立即发送丢失的分组。</p><p>所以快速重传概括如下：TCP 发送方在观测到至少 dupthresh ( 通常是 3 ) 个重复 ACK，立即重传，而不必得到计时器超时。当然也可以同时发送新的数据。</p><p>示例如下：<img src="https://image.littlechao.top/20180315024222000004.jpg" alt=""></p><h4 id="包失序与包重复"><a href="#包失序与包重复" class="headerlink" title="包失序与包重复"></a>包失序与包重复</h4><h5 id="失序"><a href="#失序" class="headerlink" title="失序"></a>失序</h5><p>当然快速重传也会造成一些问题。在轻微失序的情况下(左图)，不会有什么影响。但在严重失序时(右图)，4号数据包延迟到达，接收方发送 4 个冗余 ACK ，让发送方认为 4 号分组丢失，造成伪快速重传。</p><p><img src="https://image.littlechao.top/20180315092324000007.jpg" alt=""></p><h5 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h5><p>尽管可能性较小，但 IP 协议也可能将单个包传输多次。假如 IP 协议将一个包传输了 4 次，然后发送方接收到 3 个冗余 ACK ，也会让发送方以为分组丢失，导致伪快速重传。</p><h4 id="带选择确认的重传"><a href="#带选择确认的重传" class="headerlink" title="带选择确认的重传"></a>带选择确认的重传</h4><p>在上一篇文章中提到过 TCP 的 SACK 选项，它通过若干个 SACK 块来帮助发送方知道接收方有哪些空缺，可以减少不必要的重传。</p><h5 id="接收端的-SACK-行为"><a href="#接收端的-SACK-行为" class="headerlink" title="接收端的 SACK 行为"></a>接收端的 SACK 行为</h5><p>接收端在 TCP 连接建立期间收到 SACK 选项即可生成 SACK。通常来说，当收到失序报文段，接收方就会生成 SACK。</p><p>第一个 SACK 块包含的应该是<strong>最近收到的</strong>报文段的序列号范围。由于 SACK 选项空间有限，应尽可能向发送方提供最新信息。其余的 SACK 按先后顺序依次排列，也就是说，该 ACK 报文段除了包含最新接收的序列号信息，还应重复之前的 SACK 信息。这是因为 ACK 报文段是没有重发机制的，可能会丢失，重复提高了其鲁棒性。</p><h5 id="发送端的-SACK-行为"><a href="#发送端的-SACK-行为" class="headerlink" title="发送端的 SACK 行为"></a>发送端的 SACK 行为</h5><p>发送方应该充分利用 SACK 信息来进行重传，称为<strong>选择性重传</strong>。发送方记录累积 ACK 信息和 SACK 信息，当接收到相应序列号范围内的 ACK 时，在其重传缓存中标记该报文段重传成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##TCP超时重传&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 提供可靠数据传输服务，为保证传输正确性，TCP 重传其认为已经丢失的包。TCP 有两套重传机制，一是基于定时器（超时），二是基于确认信息的构成（快速重传）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Node 异步 I/O</title>
    <link href="http://littlechao.top/2018/03/17/node_async_io/"/>
    <id>http://littlechao.top/2018/03/17/node_async_io/</id>
    <published>2018-03-16T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.340Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要讲 nodejs 中的异步 IO，关于同步、异步、阻塞、非阻塞 请移步<a href="https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/" target="_blank" rel="noopener">这里</a>。</p><h3 id="事件循环-和-消息队列"><a href="#事件循环-和-消息队列" class="headerlink" title="事件循环 和 消息队列"></a>事件循环 和 消息队列</h3><p>我们常说“JavaScript是单线程的”。</p><p>所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。</p><p>但是实际上还存在其他的线程。例如：处理AJAX请求的线程、定时器线程、读写文件的线程等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。</p><p><img src="/images/async/async_pic.png" alt=""></p><h4 id="node-执行过程"><a href="#node-执行过程" class="headerlink" title="node 执行过程"></a>node 执行过程</h4><p><img src="/images/async/node_event.png" alt=""></p><p>处理并执行完 js 代码，main函数继续往下调用libuv的事件循环入口uv_run()，node进程进入事件循环。 <code>uv_run()</code> 的 while 循环做的就是一件事，判断 <code>default_loop_struct</code> 是否有存活的 io 观察者 或 定时器。</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><blockquote><p>事件循环是指主线程重复从消息队列中取消息、执行的过程</p></blockquote><p>事件循环对应上图 3 号标注的部分。用代码表示大概是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = queue.get();</span><br><span class="line">    execute(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/async/event_loop.png" alt=""></p><p>如上图，每一次执行一次循环体的过程称为 Tick。</p><p><strong>事件循环的阶段：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │ 执行定时器(setTimeout/setInterval)注册的回调函数，也是进入事</span><br><span class="line">│  └──────────┬────────────┘ 件循环第一个阶段。</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │ I/O 事件相关联的回调或者报错会在这里执行</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │ 内部使用，不讨论</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │ 最重要的一个阶段，I/O 观察者观察到线程池</span><br><span class="line">│  │         poll          │&lt;─────┤  connections, │里有任务已经完成，就会在这里执行回调。</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │ 专门用来执行 setImmediate() 的回调</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │ 一个连接或 handle 突然被关闭，close 事件会被发送到这里执行回调</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p>如上图，共有六个阶段（官方称为 phase）。特别要说明的是 poll 阶段，在这个阶段，如果暂时没有事件到来，主线程便会阻塞在这里，等待事件发生。当然它不会一直等下去：</p><ul><li>它首先会判断后面的 Check Phase 以及 Close Phase 是否还有等待处理的回调. 如果有, 则不等待, 直接进入下一个 Phase. </li><li>如果没有其他回调等待执行, 它会给 epoll 这样的方法设置一个 timeout. 可以猜一下, 这个 timeout 设置为多少合适呢? 答案就是 Timer Phase 中最近要执行的回调启动时间到现在的差值, 假设这个差值是 delta. 因为 Poll Phase 后面没有等待执行的回调了. 所以这里最多等待 delta 时长, 如果期间有事件唤醒了消息循环, 那么就继续下一个 Phase 的工作; 如果期间什么都没发生, 那么到了 timeout 后, 消息循环依然要进入后面的Phase, 让下一个迭代的 Timer Phase 也能够得到执行.</li></ul><p>来看一下流程：</p><p><img src="/images/async/phases.png" alt=""></p><p>到这里你一定发现少了一些问题：process.nextTick() 和 Promise 都是异步的，它们对应以上哪个阶段呢？往下看 </p><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、运行主线程（函数调用栈）中的同步任务</span><br><span class="line">2、主线程（函数调用栈）执行到任务源时，通知相应的webAPIs进行相应的执行异步任务，将任务源指定的异步任务放入任务队列中</span><br><span class="line">3、主线程（函数调用栈）中的任务执行完毕后，然后执行所有的微任务，再执行宏任务，找到一个任务队列执行完毕，再执行所有的微任务</span><br><span class="line">4、不断执行第三步</span><br></pre></td></tr></table></figure><blockquote><p> 任务队列也叫消息队列。主要分两类任务：宏任务(macro-task)、微任务(micro-task)</p></blockquote><p>宏任务：setTimeout    setInterval    setImmediate    I/O</p><p>微任务：process.nextTick    Promise 的回调</p><p>在上面的图中，各个 phase 完成了宏任务对应的事件。微任务的执行时机在<strong>每一次进入下一个阶段之前</strong>，process.nextTick    优先级大于 Promise 的回调。</p><h4 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h4><h5 id="setTimeout-和-setImmediate-的比较"><a href="#setTimeout-和-setImmediate-的比较" class="headerlink" title="setTimeout 和 setImmediate 的比较"></a>setTimeout 和 setImmediate 的比较</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这段代码的结果实际上是不确定的。可是，为什么？按照流程图，应该是 timer 先于 check 阶段，所以应该是 setTimeout 先执行，可是为什么结果不是这样呢？首先我们要知道：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(fn) ==&gt; setTimeout(fn, <span class="number">0</span>) ==&gt; setTimeout(fn, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>上面三个效果是一样的！前两个好理解，给定的默认值是0。其实在 node 源码中，最低为 1 ms，官方文档如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When delay is larger than 2147483647 or less than 1, the delay will be set to 1.</span><br></pre></td></tr></table></figure><p>所以当进入 timer 阶段时，1ms 可能超时也可能没有，这个影响因素有很多。如果还没超时，则进入下一个 phase，依次往下，所以先输出 2 。如果已经超时，则先输出 1。</p><blockquote><p>但是！如果它们在 I/O 事件回调中，那么输出顺序是固定了的，如下</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'fs'</span>).readFile(<span class="string">'path.txt'</span>, () =&gt; &#123;</span><br><span class="line"> setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>))</span><br><span class="line"> setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="number">1</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 输出: 2 1</span></span><br></pre></td></tr></table></figure><p>如果不知道为什么，答案就在循环图中。</p><p>(完)</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">The Node.js Event Loop, Timers, and <code>process.nextTick()</code></a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇文章主要讲 nodejs 中的异步 IO，关于同步、异步、阻塞、非阻塞 请移步&lt;a href=&quot;https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlechao.top/tags/JavaScript/"/>
    
      <category term="node" scheme="http://littlechao.top/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>TCP 连接管理</title>
    <link href="http://littlechao.top/2018/03/17/TCPConn/"/>
    <id>http://littlechao.top/2018/03/17/TCPConn/</id>
    <published>2018-03-16T16:00:00.000Z</published>
    <updated>2018-05-06T15:46:39.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP-连接的建立和终止"><a href="#TCP-连接的建立和终止" class="headerlink" title="TCP 连接的建立和终止"></a>TCP 连接的建立和终止</h3><p>一个TCP连接由一个四元组构成：源IP、源端口、目的IP、目的端口。一个连接通常分为三个阶段：启动、数据传输（也称“连接已建立”）、关闭。以下是建立连接是三步握手和关闭时四步挥手的过程。</p><p><img src="https://notes.shichao.io/tcpv1/figure_13-1.png" alt=""></p><h6 id="握手："><a href="#握手：" class="headerlink" title="握手："></a>握手：</h6><ul><li>客户端先发一个SYN（synchronous）报文段，并指明客户端的初始序列号（Initial Sequence Number），图中值为ISN(c)。（注意这里可能出现超时或报文丢失的情况）</li><li>服务端收到后返回一个ACK（acknowledgement）,并指明ACK确认号的值为ISN(c) + 1来表明已经收到Seq值为ISN(c)的SYN报文段。服务端在同一个报文段还发送了一个SYN并指明自己的初始序列号ISN(s).</li><li>客户端收到ACK+SYN，发送ACK向服务端确认收到来自服务端的SYN，并指明Seq=ISN(s) + 1.</li></ul><blockquote><p>重要的细节：对于client来说，第三步似乎是多余的，但是对服务端来说，是一个防止SYN泛洪攻击的手段：服务端在建立连接后需要为该连接分配变量和内存，如果没有第三步，恶意客户端通过不停伪造IP和端口发起SYN（客户端没有太大内存消耗），导致服务端不停分配变量，最后内存消耗完崩溃。所以第三步可以让服务端辨别恶意客户端。</p></blockquote><p>######挥手：</p><ul><li>关闭发起者（TCP连接是双向的，任何一方都可以主动断开连接）向另一方发送一个FIN（final）段表示要开始关闭连接。此时的ACK值是确认最近一次发来的数据。</li><li>被动方接收FIN，发回一个ACK。</li><li>被动方向发起方发送一个FIN，同时再次确认之前的FIN，ACK和上次相同。</li><li>发起方收到FIN，发回ACK</li></ul><p>挥手断开这里同样有很多重要细节：</p><ul><li>前两步完成后，发起方到被动方的连接已经关闭，但TCP是双向的，此时由于被动方还没有发送FIN，所以被动方到发起方的连接还打开着，TCP连接目前处于<strong>半关闭</strong>状态，此时被动方仍然可以向发起方发送数据，发起方也可以正常接受数据。但是如果被动方既不再发送数据，也不发送最后的FIN，就会出现问题。所以发起方收到FIN的ACK时，设置了一个定时器，在规定时间内没有数据发过来，就自动断开连接。</li><li>另一个问题是，如果发起方发送了最后一个ACK用于确认被动方的FIN之后立刻关闭，但是此ACK超时未达或者丢失了，就会造成问题—被动方的FIN得不到确认。这时被动方会在超时后重新发送FIN，直到收到ACK为止。所以发起方发送完最后一个ACK后不能马上离开，而要等一段时间，用于确保对方收到ACK，这段时间叫<strong>静默时间</strong>，并且这个时间是强制的。静默时间大小一般为2*MSL（Max Segment Lifetime,报文段在被丢弃前允许的最长存活时间）所以它还有另一个重要的作用，就是让属于这个已经关闭连接的报文段过期，以免相同的客户端和服务端再次建立连接时受到之前已经关闭连接的影响。</li></ul><h3 id="TCP-FSM"><a href="#TCP-FSM" class="headerlink" title="TCP FSM"></a>TCP FSM</h3><p>以下是TCP三步握手和四步挥手的有限状态机。应该掌握。</p><p><img src="https://image.littlechao.top/20180313081609000002.jpg" alt=""></p><h3 id="TCP-选项"><a href="#TCP-选项" class="headerlink" title="TCP 选项"></a>TCP 选项</h3><p>TCP有若干选项，每个选项的头一个字节表示“种类”，指明了选项的类型。</p><h5 id="MSS-最大段大小选项"><a href="#MSS-最大段大小选项" class="headerlink" title="MSS 最大段大小选项"></a>MSS 最大段大小选项</h5><p>Max segment size。当一条TCP连接建立时，通信双方都要在SYN报文段的MSS选项说明自己允许的最大段大小。注意最大段大小不是双方协商的结果，而是表明自己不愿意接收任何大于该尺寸的报文段。</p><h5 id="SACK-选择确认段"><a href="#SACK-选择确认段" class="headerlink" title="SACK 选择确认段"></a>SACK 选择确认段</h5><p>Select ACK。在滑动窗口中，TCP采用累计ACK确认，不能正确的确认已经收到的但是是失序的报文段，接收方的数据队列就会出现空洞。SACK能够使发送方了解到空洞出现并进行更有效的重传工作。通过接收SYN报文段中的“允许确认选项”，TCP通信方会知道自身拥有了发布SACK的能力。SACK选项由n个SACK块构成，每个SACK块是一对32位的序列号（a，b），表明已经接受a到b的数据。</p><h5 id="WSOPT"><a href="#WSOPT" class="headerlink" title="WSOPT"></a>WSOPT</h5><p>Window scale option。窗口本来大小只有16位，若wsopt值为s，则窗口大小为16*2^s,最大值为1G</p><p>#####TSOPT</p><p>timestamp option。发送方发出的报文段带有发出时的时间戳，接收方收到后将该值写入ACK报文段发回给发送方。发送方据此可以精确地计算RTT（round trip time）。同时该选项还可用于防回绕：假如存在一个过期了的报文段恰好和下一次要接受的报文段序列号相同，这时候可以通过时间戳来判断，如果该报文时间戳小于最近一次收到的报文段，说明改报文段是过期了的。</p><h3 id="TCP服务器选项"><a href="#TCP服务器选项" class="headerlink" title="TCP服务器选项"></a>TCP服务器选项</h3><p>TCP服务端会为每一个客户端分配一个新的进程或线程，这样负责监听的服务器就能始终准备着处理下一个到来的连接请求。但是如果服务器正在创建一个新进程（线程）时有更多的连接到来，应该如何处理？</p><p>在被用于应用程序之前，新的连接可能会有两种状态：1、SYN_RCVD 状态         2、    ESTABLISHED 状态 但未被应用程序所接受。</p><p>TCP为这两种状态的连接准备了两个队列，可以通过限制它们的大小来管理连接。</p><ul><li>当一个SYN报文段到达，将会检查SYN_RCVD队列是否已满（Linux中默认为1000），未满则加入队列，否则拒绝连接。</li><li>ESTABLISHED状态的队列通常被称为<strong>未完成连接</strong>（backlog，虽然叫未完成，但是三次握手已经完成，只是还没被应用程序处理），backlog队列最大长度默认为128</li><li>如果backlog队列未满，则会根据SYN_RCVD队列应答SYN并完成握手，握手完成后，加入backlog队列，由负责监听的服务器依次分配线程。注意当客户端发送ACK后，会认为服务端已经做好接收数据的准备来，所以会立即发送数据，但此时连接可能还处于backlog队列，还未被应用程序处理，所以TCP还有一个专门的数据队列。</li><li>如果backlog已满，则会延迟应答SYN。正常的TCP机制里，客户端会等待SYN超时，但在Linux客户端中，既不超时也不重置。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP-连接的建立和终止&quot;&gt;&lt;a href=&quot;#TCP-连接的建立和终止&quot; class=&quot;headerlink&quot; title=&quot;TCP 连接的建立和终止&quot;&gt;&lt;/a&gt;TCP 连接的建立和终止&lt;/h3&gt;&lt;p&gt;一个TCP连接由一个四元组构成：源IP、源端口、目的IP、目
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://littlechao.top/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>node 模块机制</title>
    <link href="http://littlechao.top/2018/03/14/node_commonJS/"/>
    <id>http://littlechao.top/2018/03/14/node_commonJS/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.353Z</updated>
    
    <content type="html"><![CDATA[<h1 id="node-模块机制"><a href="#node-模块机制" class="headerlink" title="node 模块机制"></a>node 模块机制</h1><h3 id="模块引用"><a href="#模块引用" class="headerlink" title="模块引用"></a>模块引用</h3><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br></pre></td></tr></table></figure><p>在 CommonJS 规范中，require 接受一个模块标志，以此引入模块的 API。</p><p>模块提供了 exports 对象来导出方法或变量，另外还有一个 module 对象，该对象即模块本身，而在 nodejs 中，文件就是模块。在 module 对象上有一个 module.exports 属性，这是其导出的内容，变量 exports 指向的地址就是 module.exports。也就是说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports === exports</span><br></pre></td></tr></table></figure><p>这里注意，可以在 exports 上添加属性或方法来导出，但不可修改 exports 本身的值，因为改了以后，exports 不在指向 module.exports, 也就不会被导出。如果想要导出一个类，可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = &#123;&#125;</span><br><span class="line">A.prototype.foo = foo;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = A;</span><br></pre></td></tr></table></figure><h3 id="node-模块实现"><a href="#node-模块实现" class="headerlink" title="node 模块实现"></a>node 模块实现</h3><blockquote><p>node 会将加载过的模块放入缓存，下次引用直接从缓存加载。</p></blockquote><h4 id="路径分析-和-文件定位"><a href="#路径分析-和-文件定位" class="headerlink" title="路径分析 和 文件定位"></a>路径分析 和 文件定位</h4><ul><li>核心模块，如 fs 、path、http 等，直接引用模块名。node 启动时就已经加载到内存，加载速度最快</li><li>“.” 或”..”开头，相对路径查找，知道路径，查找快，但仍需动态加载，速度稍慢</li><li>“/“开头，从根目录查找，同上</li><li>自定义模块，根据 <code>module.paths</code> 变量递归向上查找 node_modules 目录</li></ul><h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><blockquote><p>require 查找模块时，需要 fs 模块同步阻塞的判断是否存在。</p></blockquote><p>require 时一般不需要指定文件后缀名，但也可以加上。如果没有后缀，node 会依次在对应路径查找 <code>.js</code>、<code>.json</code>、<code>.node</code>。如果是后两种，加上后缀名查找会稍快。</p><p>很可能最后找不到对应的<code>.js</code>、<code>.json</code>、<code>.node</code>文件，但找到的是一个目录。则会查看该目录<code>package.json</code>下main 项对应的值。示例如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"webpack.config.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>于是找到了 webpack.config.js 文件。如果没有 main 项或者不存在 package.json，则会依次查找 index.js , index.json, index.node。如果仍然没有，就按照 module.path 数组依次递归向上查找。最终找不到，则抛出异常。</p><h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>node 中模块定义如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span>(parent &amp;&amp; parent.children)&#123;</span><br><span class="line">    parent.children.push(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.filename = <span class="literal">null</span>;<span class="comment">//定义时还不能确定该值</span></span><br><span class="line">  <span class="keyword">this</span>.loaded = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">this</span>.children = [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位到具体文件后，对不同类型的文件操作不一样：</p><ul><li>.js 文件，通过 fs 模块同步读取后编译执行</li><li>.node 文件，这是 c/c++ 写的扩展文件</li><li>.json 文件，读取后通过 JSON.parse() 解析并返回结果</li></ul><p>每一个编译后的模块都被缓存起来。</p><h5 id="javaScript-模块的编译"><a href="#javaScript-模块的编译" class="headerlink" title="javaScript 模块的编译"></a>javaScript 模块的编译</h5><p>我们前面知道有 require 方法和 exports 对象，可是这些变量和方法在哪里声明的呢？实际上，node 对读取到的 js 文件做了包装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// module content</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>node 读取 js 文件后执行的就是这个包装函数，然后得到 module.exports 。</p><p>(待续)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;node-模块机制&quot;&gt;&lt;a href=&quot;#node-模块机制&quot; class=&quot;headerlink&quot; title=&quot;node 模块机制&quot;&gt;&lt;/a&gt;node 模块机制&lt;/h1&gt;&lt;h3 id=&quot;模块引用&quot;&gt;&lt;a href=&quot;#模块引用&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://littlechao.top/tags/JavaScript/"/>
    
      <category term="node" scheme="http://littlechao.top/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>golang unsafe 包</title>
    <link href="http://littlechao.top/2018/03/04/Go%20unsafe%20%E5%8C%85/"/>
    <id>http://littlechao.top/2018/03/04/Go unsafe 包/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-04-20T08:35:41.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="golang-unsafe-包"><a href="#golang-unsafe-包" class="headerlink" title="golang unsafe 包"></a>golang unsafe 包</h2><h4 id="ArbitraryType-和-Pointer"><a href="#ArbitraryType-和-Pointer" class="headerlink" title="ArbitraryType 和 Pointer"></a>ArbitraryType 和 Pointer</h4><p>Go 语言是强类型语言，并且出于安全的考虑，它不允许不同类型的指针互相转换，比如<code>*int</code>不能转为<code>*float64</code>。但是它提供了 unsafe 包来做转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ArbitraryType <span class="keyword">int</span></span><br><span class="line"><span class="keyword">type</span> Pointer *ArbitraryType</span><br></pre></td></tr></table></figure><p>从命名可以看出，ArbitraryType 代表了任意类型，其实，ArbitraryType不是一个真正的类型，它只是一个占位符。而 Pointer 是其指针，并且是一种特殊意义的指针，它可以包含任意类型的地址，有点类似于 C 语言里的<code>void*</code> 指针，全能型的。</p><p>ArbitraryType 上有三个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Alignof</span>（<span class="title">variable</span> <span class="title">ArbitraryType</span>）<span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Offsetof</span>（<span class="title">selector</span> <span class="title">ArbitraryType</span>）<span class="title">uintptr</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Sizeof</span>（<span class="title">variable</span> <span class="title">ArbitraryType</span>）<span class="title">uintptr</span></span></span><br></pre></td></tr></table></figure><p>与Golang中的大多数函数不同，上述三个函数的调用将始终在编译时求值，而不是运行时。 这意味着它们的返回结果可以分配给常量。（BTW，unsafe包中的函数中非唯一调用将在编译时求值。当传递给len和cap的参数是一个数组值时，内置函数和cap函数的调用也可以在编译时被求值。）</p><h4 id="uintptr"><a href="#uintptr" class="headerlink" title="uintptr"></a>uintptr</h4><p><code>uintptr</code> 不是 <code>unsafe</code> 包的一部分，但是它总是和 <code>unsafe</code> 一起用。<code>uintptr</code> 是底层内置类型，用于表示指针的值，区别在于<code>go</code> 语言中指针不可以参与计算，而 <code>uintptr</code> 可以。另外，指针和 uintptr 也是不可以直接转换的。</p><p>特别需要注意的是，GC 不会把 uintptr 当成指针，所以由 uintptr 变量表示的地址处的数据也可能被GC回收。</p><h3 id="用法及注意事项"><a href="#用法及注意事项" class="headerlink" title="用法及注意事项"></a>用法及注意事项</h3><h4 id="转换不同类型的指针"><a href="#转换不同类型的指针" class="headerlink" title="转换不同类型的指针"></a>转换不同类型的指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Float64bits(f float64) uint64 &#123;</span><br><span class="line">    return *(*uint64)(unsafe.Pointer(&amp;f))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="把指针转换成-uintptr"><a href="#把指针转换成-uintptr" class="headerlink" title="把指针转换成 uintptr"></a>把指针转换成 uintptr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Converting a Pointer to a uintptr creates an integer value with no pointer semantics</span><br><span class="line">//上面说过的，uintptr 没有指针的含义</span><br></pre></td></tr></table></figure><p>如下转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int64</span> = <span class="number">0</span></span><br><span class="line">pa := &amp;a</span><br><span class="line">up := <span class="keyword">uintptr</span>(unsafe.Pointer(pa))</span><br><span class="line">pa = &amp;<span class="keyword">int64</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>当 pa 地址改变，uintptr 是不会更新的。且当只有 up 包含了变量 a 的地址，但是 GC 不会把 up 当做指针，所以GC 会回收变量 a 。</p><h4 id="uintptr-转指针"><a href="#uintptr-转指针" class="headerlink" title="uintptr 转指针"></a>uintptr 转指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p := &amp;T&#123;&#125;</span><br><span class="line">p = unsafe.Pointer(<span class="keyword">uintptr</span>(p) + offset)</span><br></pre></td></tr></table></figure><p>这里的 offset 得当的话，可以取到 T 类型中没有导出的值，这也是一个巧妙的用法，但是不推荐。注意这里不能写成这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p := &amp;T&#123;&#125;<span class="comment">// 1</span></span><br><span class="line">up := <span class="keyword">uintptr</span>(p)<span class="comment">// 2</span></span><br><span class="line">p = unsafe.Pointer(up + offset)<span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>这样非常危险，因为有可能在 3 执行之前，up 这个临时变量被 GC ，最终操作的不知道是哪个内存了。因此不能将 uintptr(p) 保存在变量中。</p><p>另外，在 C语言 中我们可以将 offset 设成 T 的长度，然后直接对得到的地址进行操作。但是在 go 语言中是不合法的，可以读取，但不应该操作分配给 T 内存之外的部分，会引发 panic：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br></pre></td></tr></table></figure><h4 id="系统调用时转换指针"><a href="#系统调用时转换指针" class="headerlink" title="系统调用时转换指针"></a>系统调用时转换指针</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall.Syscall(SYS_READ, <span class="keyword">uintptr</span>(fd), <span class="keyword">uintptr</span>(unsafe.Pointer(p)), <span class="keyword">uintptr</span>(n))</span><br></pre></td></tr></table></figure><p>如上，当系统调用需要一个 uintptr 作为参数，也一定把 uintptr(..) 放在系统调用表达式的参数里，以防止被 GC。在系统调用过程中，不必担心 uintptr 失效，它所持有的对象不会被 GC 。</p><h4 id="reflect-Value-Pointer"><a href="#reflect-Value-Pointer" class="headerlink" title="reflect.Value.Pointer"></a>reflect.Value.Pointer</h4><p>在一些函数的返回值中，也可能出现 uintptr，比如 <code>reflect.Value.Pointer</code>和<code>reflect.Value.UnsafeAddr</code>,对其转换成指针的时候也要注意，不能有中间变量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p := (*<span class="keyword">int</span>)(unsafe.Pointer(reflect.ValueOf(<span class="built_in">new</span>(<span class="keyword">int</span>)).Pointer()))</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// As in the cases above, it is invalid to store the result before the conversion:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  INVALID: uintptr cannot be stored in variable</span></span><br><span class="line"><span class="comment">//  before conversion back to Pointer.</span></span><br><span class="line"><span class="comment">//u := reflect.ValueOf(new(int)).Pointer()</span></span><br><span class="line"><span class="comment">//p := (*int)(unsafe.Pointer(u))</span></span><br></pre></td></tr></table></figure><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><ul><li>unsafe包用于Go编译器，而不是Go运行时。</li><li>使用unsafe作为程序包名称只是让你在使用此包是更加小心。</li><li>使用unsafe.Pointer并不总是一个坏主意，有时我们必须使用它。</li><li>Golang的类型系统是为了安全和效率而设计的。 但是在Go类型系统中，安全性比效率更重要。 通常Go是高效的，但有时安全真的会导致Go程序效率低下。 unsafe包用于有经验的程序员通过安全地绕过Go类型系统的安全性来消除这些低效。</li><li>unsafe包可能被滥用并且是危险的</li><li>涉及到 uintptr 转指针时，一定注意不能有中间变量</li></ul><hr><h4 id="续-question"><a href="#续-question" class="headerlink" title="(续)question"></a>(续)question</h4><p>在关于操作不可知内存的时候，会有一些莫名其妙的现象，如下代码是 gocn 上一篇<a href="https://gocn.io/question/371" target="_blank" rel="noopener">文章</a>里的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">illegalUseB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">illegalUseB</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">p := unsafe.Pointer(&amp;a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">*(*<span class="keyword">int</span>)(p) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(i, <span class="string">":"</span>, *(*<span class="keyword">int</span>)(p))</span><br><span class="line"><span class="comment">// panic at the above line for the last iteration, when i==4.</span></span><br><span class="line"><span class="comment">// runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line">p = unsafe.Pointer(<span class="keyword">uintptr</span>(p) + <span class="number">8</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码，报错如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> : <span class="number">1</span></span><br><span class="line"><span class="number">1</span> : <span class="number">1</span></span><br><span class="line"><span class="number">2</span> : <span class="number">1</span></span><br><span class="line"><span class="number">3</span> : <span class="number">1</span></span><br><span class="line"><span class="built_in">panic</span>: runtime error: invalid memory address or <span class="literal">nil</span> pointer dereference</span><br><span class="line">[signal SIGSEGV: segmentation violation code=<span class="number">0x1</span> addr=<span class="number">0x1</span> pc=<span class="number">0x100ca32</span>]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是比较诡异的情况如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">illegalUseB</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">p := unsafe.Pointer(&amp;a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">fmt.Println(i, <span class="string">":"</span>, *(*<span class="keyword">int</span>)(p))</span><br><span class="line"><span class="comment">// panic at the above line for the last iteration, when i==4.</span></span><br><span class="line"><span class="comment">// runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line">p = unsafe.Pointer(<span class="keyword">uintptr</span>(p) + <span class="number">8</span>)</span><br><span class="line">        *(*<span class="keyword">int</span>)(p) = <span class="number">1</span><span class="comment">// 调整了位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">illegalUseB</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">a := [<span class="number">4</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">p := unsafe.Pointer(&amp;a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">*(*<span class="keyword">int</span>)(p) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fmt.Println(i, <span class="string">":"</span>, *(*<span class="keyword">int</span>)(p), (*<span class="keyword">int</span>)(p))<span class="comment">// 多输出了一个值</span></span><br><span class="line"><span class="comment">// panic at the above line for the last iteration, when i==4.</span></span><br><span class="line"><span class="comment">// runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line"></span><br><span class="line">p = unsafe.Pointer(<span class="keyword">uintptr</span>(p) + <span class="number">8</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种情况都不会报错。按理说都是操作了声明变量以外的内存，但是没有向之前一样报错，不知道是什么原因。我的 go SDK 版本是 1.9.1，如果你知道的话麻烦告诉我，谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;golang-unsafe-包&quot;&gt;&lt;a href=&quot;#golang-unsafe-包&quot; class=&quot;headerlink&quot; title=&quot;golang unsafe 包&quot;&gt;&lt;/a&gt;golang unsafe 包&lt;/h2&gt;&lt;h4 id=&quot;ArbitraryType
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go net/dial.go (II)</title>
    <link href="http://littlechao.top/2018/03/02/Go%20net:dial.go%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://littlechao.top/2018/03/02/Go net:dial.go 阅读笔记(二)/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-04-20T08:30:16.321Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.littlechao.top/#/index/article?_id=5a9823ceebc087002a3e7259" target="_blank" rel="noopener">上一篇文章</a> 我们大致分析了dial.go中的代码，起主要的功能就是为真正发起连接做一些准备，起到了应用层的作用（DNS解析等）。但是一个连接完整的连接还需要更深层次的网络协议来完成协作，所以我们接着上篇来分析，由于篇(懒)幅原因，只将<code>dialTcp</code>作为传输层的例子。。。话不多说，上代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialTCP</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, laddr, raddr *TCPAddr)</span> <span class="params">(*TCPConn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> testHookDialTCP != <span class="literal">nil</span> &#123; <span class="comment">//testHookDialTCP 是语言开发者为了测试留的钩子函数，不用管</span></span><br><span class="line"><span class="keyword">return</span> testHookDialTCP(ctx, net, laddr, raddr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> doDialTCP(ctx, net, laddr, raddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意现在所在文件是在<code>tcpsock_posix.go</code> 这部分是<strong>传输层</strong>的内容了。</p></blockquote><p>来看<code>doDialTCP</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doDialTCP</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, laddr, raddr *TCPAddr)</span> <span class="params">(*TCPConn, error)</span></span> &#123;</span><br><span class="line">fd, err := internetSocket(ctx, net, laddr, raddr, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">"dial"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; (laddr == <span class="literal">nil</span> || laddr.Port == <span class="number">0</span>) &amp;&amp; (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line">&#125;</span><br><span class="line">fd, err = internetSocket(ctx, net, laddr, raddr, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">"dial"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTCPConn(fd), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数里的ctx自然不言而喻了，是为了控制请求超时取消请求释放资源的；<code>laddr</code>是 local address ， <code>raddr</code>是指 remote address；返回值这里会得到 <code>TCPConn</code>。代码不长，就是调用了 <code>internetSocket</code>得到一个文件描述符，并用其新建一个conn返回。但这里我想多说几句，因为不难发现， <code>internetSocket</code>可能会被调用多次，为什么呢？</p><p>首先我们需要知道 Tcp 有一个极少使用的机制，叫<code>simultaneous connection</code>（同时连接）。正常的连接是：A主机 dial B主机，B主机 listen。 而同时连接则是： A 向 B dial 同时 B 向 A dial，那么 A 和 B 都不需要监听。</p><p>我们知道，当 传入 dial  函数的参数<code>laddr</code>==<code>raddr</code>时，内核会拒绝dial。但如果传入的<code>laddr</code>为nil，kernel 会自动选择一个本机端口，这时候有可能会使得新的<code>laddr</code>==<code>raddr</code>,这个时候，kernel不会拒绝dial，并且这个dial会成功，原因是就<code>simultaneous connection</code>，这可能是kernel的bug。所以会判断是否是 <code>selfConnect</code>或者<code>spuriousENOTAVAIL</code>(spurious error not avail)来判断上一次调用<code>internetSocket</code>返回的 err 类型，在特定的情况下重新尝试<code>internetSocket</code>.关于这个问题的讨论参见<a href="https://stackoverflow.com/questions/4949858/how-can-you-have-a-tcp-connection-back-to-the-same-port" target="_blank" rel="noopener">这里</a>。</p><p>好了，我们接下来看看<code>internetSocket</code>，该函数在<code>ipsock_posix.go</code>文件，到了<strong>网络层</strong>的范围了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internetSocket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, laddr, raddr sockaddr, sotype, proto <span class="keyword">int</span>, mode <span class="keyword">string</span>)</span> <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (runtime.GOOS == <span class="string">"windows"</span> || runtime.GOOS == <span class="string">"openbsd"</span> || runtime.GOOS == <span class="string">"nacl"</span>) &amp;&amp; mode == <span class="string">"dial"</span> &amp;&amp; raddr.isWildcard() &#123;</span><br><span class="line">raddr = raddr.toLocal(net) </span><br><span class="line">      <span class="comment">// 如果 raddr 是零地址，把它转化成当前系统对应的零地址格式(local system address 127.0.0.1 or ::1)</span></span><br><span class="line">&#125;</span><br><span class="line">family, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode)</span><br><span class="line"><span class="keyword">return</span> socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（sotype 和 proto 是生成 socket 文件d的系统调用时用的）首先判断了运行系统的类型，<code>favoriteAddrFamily</code>返回了当前 dial 最合适的地址族，主要是判断应该用ipv4还是ipv6或者都用，其返回值 family 有两种可能值：<code>AF_INET</code>和<code>AF_INET6</code>，都是int类型，感兴趣的朋友可以参见<a href="https://stackoverflow.com/questions/1593946/what-is-af-inet-and-why-do-i-need-it" target="_blank" rel="noopener">这里</a>。</p><p>让我们接着关注<code>socket</code>,该函数在<code>sock_posix.go</code>文件，意味着接下来将是更加底层的系统调用了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket returns a network file descriptor that is ready for</span></span><br><span class="line"><span class="comment">// asynchronous I/O using the network poller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, family, sotype, proto <span class="keyword">int</span>, ipv6only <span class="keyword">bool</span>, laddr, raddr sockaddr)</span> <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line">s, err := sysSocket(family, sotype, proto)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = setDefaultSockopts(s, family, sotype, ipv6only); err != <span class="literal">nil</span> &#123;</span><br><span class="line">poll.CloseFunc(s)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fd, err = newFD(s, family, sotype, net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">poll.CloseFunc(s)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function makes a network file descriptor for the</span></span><br><span class="line"><span class="comment">// following applications:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens a passive stream</span></span><br><span class="line"><span class="comment">//   connection, known as a stream listener</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens a destination-unspecific</span></span><br><span class="line"><span class="comment">//   datagram connection, known as a datagram listener</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens an active stream or a</span></span><br><span class="line"><span class="comment">//   destination-specific datagram connection, known as a</span></span><br><span class="line"><span class="comment">//   dialer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens the other connection, such</span></span><br><span class="line"><span class="comment">//   as talking to the protocol stack inside the kernel</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For stream and datagram listeners, they will only require</span></span><br><span class="line"><span class="comment">// named sockets, so we can assume that it's just a request</span></span><br><span class="line"><span class="comment">// from stream or datagram listeners when laddr is not nil but</span></span><br><span class="line"><span class="comment">// raddr is nil. Otherwise we assume it's just for dialers or</span></span><br><span class="line"><span class="comment">// the other connection holders.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> laddr != <span class="literal">nil</span> &amp;&amp; raddr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> sotype &#123;</span><br><span class="line"><span class="keyword">case</span> syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:</span><br><span class="line"><span class="keyword">if</span> err := fd.listenStream(laddr, listenerBacklog); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> syscall.SOCK_DGRAM:</span><br><span class="line"><span class="keyword">if</span> err := fd.listenDatagram(laddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := fd.dial(ctx, laddr, raddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码隐含了大量细节，首先看最上面函数的注释，返回值是一个使用了<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener"><code>network poller</code></a>的<strong>异步I/O</strong>的文件描述符。前面三个 if 里，先创建了一个 socket，然后设置基本参数，再 new 一个文件描述符，其中包含了大量的系统调用和底层细节，这里先跳过。我想说的在下面。</p><p>socket 这个函数可以为一下几种应用创建一个文件描述符：</p><ul><li>一个打开了 被动的、流式的 连接的终端，通常叫<code>stream listener</code></li><li>一个打开了 没有具体目的地的、数据报格式的 连接的终端，通常叫<code>datagram listener</code></li><li>一个打开了 主动的、有明确目的地的、数据报格式的 连接的终端，通常叫<code>dialer</code></li><li>一个打开了其他连接的终端，比如与内核中的协议栈通信</li></ul><blockquote><p>通常可以认为当 <code>laddr</code>不为空但<code>raddr</code>为空时的 request 是来自stream or datagram listeners。否则就是来自 dialers 或者其他系统连接。</p></blockquote><p>所以一个dialer和listener的区别就是 laddr， 也就是dialer在一定情况下可以当做listener，到这里就可以解释之前tcp的<code>simultaneous connection</code>同时连接了。</p><p>接下来调用了fd的dial函数，这里才真正通过socket开始发送连接请求。</p><p>(待续)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.littlechao.top/#/index/article?_id=5a9823ceebc087002a3e7259&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt; 我们大致分析了dial.go
      
    
    </summary>
    
    
  </entry>
  
</feed>
