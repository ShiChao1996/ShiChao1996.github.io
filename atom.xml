<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-18T09:06:04.921Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TCP 数据流与窗口管理</title>
    <link href="http://yoursite.com/2018/03/18/tcp_window_management/"/>
    <id>http://yoursite.com/2018/03/18/tcp_window_management/</id>
    <published>2018-03-18T09:06:04.918Z</published>
    <updated>2018-03-18T09:06:04.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-数据流与窗口管理"><a href="#TCP-数据流与窗口管理" class="headerlink" title="TCP 数据流与窗口管理"></a>TCP 数据流与窗口管理</h2><h3 id="交互式通信"><a href="#交互式通信" class="headerlink" title="交互式通信"></a>交互式通信</h3><p>ssh 是一个典型的交互式通信协议，它是加密了的，通常每次按键都会生成一个单独的包。另外，ssh 会在服务端对客户端输入的字符进行回显。因此，服务端收到数据包会先发送一个 ACK，然后发送一个回显报文，再由客户端发送对回显报文段的 ACK，如下左图。</p><p><img src="http://image.littlechao.top/20180317033327000018.jpg" alt=""></p><p>但通常第二段和第三段可以合并来减少传输次数，这种方法称为捎带延时确认，如上右图。我们可以再来看看 wireshark 抓的包:</p><p><img src="http://image.littlechao.top/20180317041434000021.jpg" alt=""></p><p>不难发现，这些包三个为一组，先是客户端(192.168.0.120)发送一个加密的包，然后收到服务端一个加密包，然后客户端回复一个 ACK。看一下服务端发过来的包：</p><p><img src="http://image.littlechao.top/20180317043335000022.jpg" alt=""></p><p>可以看到，标志位的 ACK 置为了 1，ACK 值为 145，PSH 位也置为了 1（表明收到后立刻返回给应用层），并且数据段不为空，说明包含了回显的部分。很明显这里采用了捎带延时确认。</p><h3 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h3><p>在很多情况下，TCP 累计确认可以允许延迟一小会儿发送 ACK，以便结合相同方向的数据一起传送。但是显然，TCP 不能延时任意时长，通常建议：TCP 实现延迟应小于 500 ms，实践中延时应小于 200 ms。该延时值是可以配置的可选值如下：禁用延时，始终延时，每隔一个包回复一个 ACK，自动确认时间；默认值为 3。</p><h3 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h3><p>通常在类似于 ssh 这样的应用里，每次传输的数据包非常小，称为微型报文，这些报文会造成相当高的传输代价。可以采用 Nagle 算法来解决这类问题。</p><p>Nagle 算法规定，当一个 TCP 连接有在传数据时，小的报文段（长度小于 SMSS）不会被发送，直到所有在传数据都收到 ACK。并且收到 ACK 后，会收集小数据并整合到一个报文段发送。</p><p>下图为 ssh 应用中没有开启 Nagle 算法（左图）和开启 Nagle 算法（右图）的差别。</p><p><img src="http://image.littlechao.top/20180317121248000003.jpg" height="400px"></p><p>可以看到，没有开启时，同一时刻有很多包在传输，并且有很多小包（tinygram），总体时间短，但是网络负担大。开启了 Nagle 算法时，同一时刻只有一个方向的传输，并且在合适的情况下，合并小包一起发送，时间较长，但传输次数少，网络负担小。</p><h4 id="延时-ACK-与-Nagle-结合"><a href="#延时-ACK-与-Nagle-结合" class="headerlink" title="延时 ACK 与 Nagle 结合"></a>延时 ACK 与 Nagle 结合</h4><p>无论是延迟 ACK 还是 Nagle 算法，其目的都是减少网络中传输的包，减轻网络负担。但是二者一起使用时，可能会出现问题。</p><p>考虑如下情况：客户端依次要发送一个全长报文段以及若干个小包，服务端收到第一个全长包，然后延迟发送 ACK（延时，或者期待第二个全长报文段到达），而客户端采用了 Nagle 算法，需要等到 ACK 到达才能继续发送。这样就会形成一个短暂的死锁，性能反而变差。所以在有些情况下，如 ssh ，可以禁用 Nagle 算法。</p><h3 id="流量控制与窗口管理"><a href="#流量控制与窗口管理" class="headerlink" title="流量控制与窗口管理"></a>流量控制与窗口管理</h3><p> 每个 TCP 报文段的首部里都包含了一个窗口大小字段，该字段占 16 位，最大表示 65536，也就是 64 KB，但 TCP 选项中的窗口缩放选项可以让它表示更大的窗口。</p><p>一般来说每个连接的接收端会有一个大小固定的缓存，用来暂存发送端发来的数据，然后由应用程序读取。当应用程序来不及处理缓存数据，而发送方又不停的发送数据，超出缓存大小，就会造成数据丢失和不必要的重传。窗口大小字段用于 TCP 的流量控制，用于表示接收端可用缓存大小。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h5 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h5><p>每个 TCP 连接的两端都维护了一个发送窗口，结构如下：</p><p><img src="http://www.tcpipguide.com/free/diagrams/tcpswwindows.png"></p><p>主要分四部分：已经发送并收到确认、已经发送但未收到确认、未发送但可以发送、未发送并且目前不能发送。第三部分称为<strong>可用窗口</strong>，第二部分和第三部分合称<strong>发送窗口</strong>。随着时间推移，窗口可以有几种运动：</p><ul><li>关闭：随着 ACK 到来，发送窗口左边界向右移，窗口减小。</li><li>打开：窗口右边界右移，即接收方可用缓存增大，发送方可用窗口也就增大。</li><li>收缩：右边界左移，主机不支持这种做法，但 TCP 必须能处理这种问题。</li></ul><h5 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h5><p>除了发送窗口，接收方还维护了一个接收窗口。</p><p><img src="http://www.tcpipguide.com/free/diagrams/tcpswpointersreceive.png" alt=""></p><p>接收窗口结构简单，包括已经接收且已经回复 ACK、允许对方发送但还未收到、目前不允许对方发送的部分。</p><h5 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h5><p>接收方收到一个数据包后，返回一个 ACK，根据自己的可用接收缓存大小设置 ACK 报文里的窗口大小。发送方收到这个窗口通告后，根据可用窗口大小调整自己的发送窗口，以达到调节发送速率的目的。</p><h4 id="零窗口与-TCP-持续计时器"><a href="#零窗口与-TCP-持续计时器" class="headerlink" title="零窗口与 TCP 持续计时器"></a>零窗口与 TCP 持续计时器</h4><p>当发送方不停发送，接收方又比较忙的时候，可能会导致可用窗口大小为 0。当出现零窗口时，发送方收到一个 ACK 报文，其中的窗口大小为零，那么就表示暂时不能发送数据。而当接收方应用程序开始处理收到的数据，使得接收缓存里又有了空间，但是我们知道，窗口通告是包含在 ACK 报文里的，没有收到新的数据，就没法发送窗口通告，这时就会造成死锁。</p><p>所以当出现零窗口时，发送方会采用一个<strong>持续计时器</strong>间歇地查询接收端是否有可用窗口，持续计时器会触发<strong>窗口探测</strong>（window probe）的传输。为了保证对方能够收到查询，我们必须要往数据段放一些数据，以保证超时重发，通常会放一个字节的数据 。接收方收到窗口探测后，会被强制返回一个 ACK，并且包含自己当前可用窗口大小（这个大小会有特殊情况）。注意这里采用指数退避来计算持续计时器的超时时间。</p><p>前面谈到，大量数据量较小的包会造成传输速度的下降，也会造成网络负担。当接收端可用缓存从 0 慢慢增大到一个较小的值，这时候收到一个窗口探测，为了避免发送较小的包，接收端可以仍然在 ACK 中回复一个零窗口。</p><p><img src="https://www.brianstorti.com/assets/images/tcp-flow-control/window-probe.png" alt=""></p><h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h4><p>当发送方发送的报文大小不固定时，可能会出现<strong>糊涂窗口综合征</strong>（Silly Window Syndrome，SWS）。当出现该问题时，交换的报文数据段大小较小，耗费的资源较多。</p><p>TCP 连接两端都可能导致 SWS：当接收端的通告窗口较小（或者是还没等到窗口变得够大），或者发送端发送的包较小（或者是没有等待其他小数据组合成大数据包）。为了避免 SWS，发送方要遵循一定规则。</p><p>对于接收方：</p><ul><li>不应通告小的窗口值。在窗口增至 min(MSS，接收端缓存的一半) 之前，不能通告比当前窗口（可能为 0）更大的值</li></ul><p>对于发送方，满足任意一个：</p><ul><li>全长报文段可以发送</li><li>数据段长度 &gt;= 最大窗口通告的一半</li><li>该连接禁用 Nagle 算法</li><li>没有未经确认的在传数据</li></ul><h4 id="大容量缓存与自动调优"><a href="#大容量缓存与自动调优" class="headerlink" title="大容量缓存与自动调优"></a>大容量缓存与自动调优</h4><p>在相似的环境下，较小的接收缓存的 TCP 应用吞吐性能会较低。很多 TCP 协议栈中上层应用不能指定接收缓存大小，由操作系统来指定一个固定的或者动态变化的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;TCP-数据流与窗口管理&quot;&gt;&lt;a href=&quot;#TCP-数据流与窗口管理&quot; class=&quot;headerlink&quot; title=&quot;TCP 数据流与窗口管理&quot;&gt;&lt;/a&gt;TCP 数据流与窗口管理&lt;/h2&gt;&lt;h3 id=&quot;交互式通信&quot;&gt;&lt;a href=&quot;#交互式通信&quot; c
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://yoursite.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>TCP 超时重传</title>
    <link href="http://yoursite.com/2018/03/15/tcp_retransmission/"/>
    <id>http://yoursite.com/2018/03/15/tcp_retransmission/</id>
    <published>2018-03-15T11:43:31.043Z</published>
    <updated>2018-03-15T11:43:31.043Z</updated>
    
    <content type="html"><![CDATA[<p>##TCP超时重传</p><blockquote><p>TCP 提供可靠数据传输服务，为保证传输正确性，TCP 重传其认为已经丢失的包。TCP 有两套重传机制，一是基于定时器（超时），二是基于确认信息的构成（快速重传）。</p></blockquote><p>###基于计时器的重传</p><h4 id="简单的超时重传"><a href="#简单的超时重传" class="headerlink" title="简单的超时重传"></a>简单的超时重传</h4><p><img src="http://image.littlechao.top/20180315023638000003.jpg" alt=""></p><p>图中黑色那条就是因为定时器超时仍没有收到 ACK，所以引起了发送方超时重传。实际上 TCP 有两个阈值来决定如何重传同一个报文段：一是愿意重传的次数 R1、二是应该放弃当前连接的时机 R2。R1 和 R2 的值应分别至少为 3 次和 100 秒，如果超过任何一个但还没能重传成功，会放弃该连接。当然这两个值是可以设置的，在不同系统里默认值也不同。</p><p>那么如何设定一个合适的超时的值呢？假设 TCP 工作在静态环境中，这很容易，但真实网络环境不断变化，需要根据当前状态来设定合适的值。</p><h4 id="超时时间-RTO"><a href="#超时时间-RTO" class="headerlink" title="超时时间 RTO"></a>超时时间 RTO</h4><p>RTO（retransmission timeout）一般是根据RTT（round trip time）也就是往返时间来设置的。若 RTO 小于   RTT，则会造成很多不必要的重传；若 RTO 远大于 RTT，则会降低整体网络利用率，RTO 是保证 TCP 性能的关键。并且不同连接的RTT不相同，同一个连接不同时间的 RTT 也不相同，所以 RTO 的设置一直都是研究热点。</p><p>所以凭我们的直觉，RTO 应该比 RTT 稍大：</p><p>​                                    <strong>RTO=RTT+Δt</strong></p><p>那么，RTT 怎么算呢：</p><p>​                            <strong>SRTT=(1−α)×SRTT+α×RTTnew</strong></p><p>SRTT(smooth RTT)，RTTnew 是新测量的值。如上，为了防止 RTT 抖动太大，给了一个权值 <strong>a</strong> ，也叫平滑因子。a 的值建议在 10%~20%。举个例子，当前 RTTs=200ms，RTTs=200ms，最新一次测量的 RTT=800ms，RTT=800ms，那么更新后的 RTTs=200×0.875+800×0.125=275ms，RTTs=200×0.875+800×0.125=275ms.</p><p><strong>Δt</strong>如何得到呢？RFC 2988 规定：</p><p>​                                <strong>RTO=SRTT+4×RTTD</strong></p><p>因此，按照上面的定义，<strong>Δt=4×RTTD</strong>. 而 RTTD 计算公式如下：</p><p>​                            <strong>RTTD=(1−β)×RTTD+β×|SRTT−RTTnew|</strong></p><p>实际上，RTTD 就是一个均值偏差，它就相当于某个样本到其总体平均值的距离。这就好比你的成绩与你班级平均成绩差了多少。RFC 推荐 β=0.25。</p><h5 id="退避指数"><a href="#退避指数" class="headerlink" title="退避指数"></a>退避指数</h5><p>根据前面的公式，我们可以得到 RTO。一旦超过 RTO 还没收到 ACK，就会引起发送方重传。但如果重传后还是没有在 RTO 时间内收到 ACK，这时候会认为是网络拥堵，会引发 TCP 拥塞控制行为，使 RTO 翻倍。则第 n 次重传的 RTOn 值为：</p><p>​                                <strong>RTOn=2^(n−1)×RTO1</strong></p><p>下图是一个例子：</p><p><img src="http://img.blog.csdn.net/20170422182458581?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcTEwMDc3Mjk5OTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图片来源：http://blog.csdn.net/q1007729991/article/details/70196099"></p><p>如上，在时间为0.22531时开始第一次重传，此后重传时间开始指数增大，（在尝试了8次后停下，说明其 R2 的值可能为8）。</p><h4 id="带时间戳的-RTT-测量"><a href="#带时间戳的-RTT-测量" class="headerlink" title="带时间戳的 RTT 测量"></a>带时间戳的 RTT 测量</h4><p>前面说了 RTO 的公式，它和 RTT 有关，那么每一次的 RTT 是如何得到的呢？在之前 TCP 连接管理的时候讲过，TCP有一个 TSOPT (timestamp option) 选项，它包含两个时间戳值。它允许发送者在报文中带上一个32比特的时间戳值（TSV），然后接收方 将收到的值原封不动的填入 ACK 报文段中 TSOPT 选项的第二部分，时间戳回显字段（TSER）。发送方收到 ACK 以后，将当前时间戳减去 TSOPT 选项的 TSER 就可得到精确的RTT值。</p><blockquote><p>但是这里有很微妙的细节：接收方在收到数据包后，并不是立即发送 ACK，通常会延时“一小会儿”，多等待几个数据包后返回一个累积 ACK。此时接收方将确认时间最近的报文段的 TSV 填入 TSER 发送给发送方。</p></blockquote><h5 id="重传二义性与-Karn-算法"><a href="#重传二义性与-Karn-算法" class="headerlink" title="重传二义性与 Karn 算法"></a>重传二义性与 Karn 算法</h5><p>还有另一个重要的细节，如果测量 RTT 的样本出现了超时重传，但是我们收到了 ACK 时无法分辨是对哪一次的确认，这时候 RTT 的值可能是不正确的。</p><p>因此，Karn 算法规定：<strong>此时不更新 RTTnew 的值</strong>。并且如果发生再次重传，则采用退避后的 RTO 的值，直到发送成功，退避指数重新设定为 1 。</p><h5 id="丢包和失序的情况"><a href="#丢包和失序的情况" class="headerlink" title="丢包和失序的情况"></a>丢包和失序的情况</h5><p>假设有三个数据包依次发送，1号和3号先到达，2号数据包由于网络因素最后到达。接收方收到3号时，会发送一个1号的冗余 ACK，然后2号到达，此时会发送一个3号的累积 ACK 表明这三个到达。在这个例子里，3号 ACK 并没有立即返回，发送方收到3号的 ACK 后，根据其 TSER 计算此时的 RTT，就会导致发送方过高的估计 RTT，降低重传积极性，使得 RTO 相应增大，当然这在失序时是有好处的，因为过分积极会导致大量的伪重传。</p><h4 id="伪超时与重传"><a href="#伪超时与重传" class="headerlink" title="伪超时与重传"></a>伪超时与重传</h4><p>如下图，在发送第四个 ACK 后出现延迟高峰，导致发送方在 RTO 时间内没有收到 5 ~ 8 的 ACK，于是发生重传，然后之前的 ACK 到达，于是又依次发送 6 ~ 8，就导致了不必要的重传。可以用 Eifel 算法来解决（略）。</p><p><img src="http://image.littlechao.top/20180315075511000005.jpg" style="height:400px"></p><h4 id="目的度量"><a href="#目的度量" class="headerlink" title="目的度量"></a>目的度量</h4><p>从前面可以看出，TCP 可以学习链路特征，如 RTT、SRTT 等，但一旦连接关闭，这些信息就会丢失。即使相同的接收方与发送方建立新的连接，也必须从头开始“学习”。较新的 TCP 实现维护了这些值，在 Linux 中可以通过如下命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route show cache [ip]</span><br></pre></td></tr></table></figure><p>###基于确认信息的重传</p><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>在大多数情况下，计时器超时并触发重传是不必要的，也不是期望的，因为 RTO 通常是大于 RTT（约2倍或更大），因此基于计时器的重传会导致网络利用率降低。</p><p>首先我们要知道，接收方收到失序报文段时，应立即生成确认信息（重复 ACK），以便发送方尽快、高效地填补空缺。而发送方在收到重复 ACK 时，无法判断是由于数据包丢失还是仅仅因为延迟，所以发送方等待一定数目的重复 ACK （重复 ACK 阈值，dupthresh），这时可以认为是数据包丢失，即便还未超时，也立即发送丢失的分组。</p><p>所以快速重传概括如下：TCP 发送方在观测到至少 dupthresh ( 通常是 3 ) 个重复 ACK，立即重传，而不必得到计时器超时。当然也可以同时发送新的数据。</p><p>示例如下：<img src="http://image.littlechao.top/20180315024222000004.jpg" alt=""></p><h4 id="包失序与包重复"><a href="#包失序与包重复" class="headerlink" title="包失序与包重复"></a>包失序与包重复</h4><h5 id="失序"><a href="#失序" class="headerlink" title="失序"></a>失序</h5><p>当然快速重传也会造成一些问题。在轻微失序的情况下(左图)，不会有什么影响。但在严重失序时(右图)，4号数据包延迟到达，接收方发送 4 个冗余 ACK ，让发送方认为 4 号分组丢失，造成伪快速重传。</p><p><img src="http://image.littlechao.top/20180315092324000007.jpg" alt=""></p><h5 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h5><p>尽管可能性较小，但 IP 协议也可能将单个包传输多次。假如 IP 协议将一个包传输了 4 次，然后发送方接收到 3 个冗余 ACK ，也会让发送方以为分组丢失，导致伪快速重传。</p><h4 id="带选择确认的重传"><a href="#带选择确认的重传" class="headerlink" title="带选择确认的重传"></a>带选择确认的重传</h4><p>在上一篇文章中提到过 TCP 的 SACK 选项，它通过若干个 SACK 块来帮助发送方知道接收方有哪些空缺，可以减少不必要的重传。</p><h5 id="接收端的-SACK-行为"><a href="#接收端的-SACK-行为" class="headerlink" title="接收端的 SACK 行为"></a>接收端的 SACK 行为</h5><p>接收端在 TCP 连接建立期间收到 SACK 选项即可生成 SACK。通常来说，当收到失序报文段，接收方就会生成 SACK。</p><p>第一个 SACK 块包含的应该是<strong>最近收到的</strong>报文段的序列号范围。由于 SACK 选项空间有限，应尽可能向发送方提供最新信息。其余的 SACK 按先后顺序依次排列，也就是说，该 ACK 报文段除了包含最新接收的序列号信息，还应重复之前的 SACK 信息。这是因为 ACK 报文段是没有重发机制的，可能会丢失，重复提高了其鲁棒性。</p><h5 id="发送端的-SACK-行为"><a href="#发送端的-SACK-行为" class="headerlink" title="发送端的 SACK 行为"></a>发送端的 SACK 行为</h5><p>发送方应该充分利用 SACK 信息来进行重传，称为<strong>选择性重传</strong>。发送方记录累积 ACK 信息和 SACK 信息，当接收到相应序列号范围内的 ACK 时，在其重传缓存中标记该报文段重传成功。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##TCP超时重传&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 提供可靠数据传输服务，为保证传输正确性，TCP 重传其认为已经丢失的包。TCP 有两套重传机制，一是基于定时器（超时），二是基于确认信息的构成（快速重传）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;###
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://yoursite.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>redux your app</title>
    <link href="http://yoursite.com/2018/03/13/redux/"/>
    <id>http://yoursite.com/2018/03/13/redux/</id>
    <published>2018-03-13T14:55:23.372Z</published>
    <updated>2018-03-13T14:55:23.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redux简介"><a href="#redux简介" class="headerlink" title="redux简介"></a>redux简介</h3><p>简单来说，redux 就是帮我们统一管理了 react 组件的 state 状态。</p><p>为什么要使用 redux 统一管理 state 呢？没有 redux 我们依旧可以开发 APP，但是当 APP 的复杂度到达一定程度的时候，摆在我们面前的就是 难以维护 的代码（其中包含组件大量的异步回调，数据处理等等），但是使用 redux 也会增加我们整个项目的复杂度，这就需要我们在两者之间进行权衡了，对于这一部分，redux 开发者给我们下面几个参考点：</p><blockquote><p>以下几种情况不需要使用 redux：</p></blockquote><ul><li><p>整体 UI 很简单，没有太多交互。</p></li><li><p>不需要与服务器进行大量交互，也没有使用 WebSocket。</p></li><li><p>视图层只从单一来源获取数据。</p></li></ul><blockquote><p>以下几种情况可考虑使用 redux：</p></blockquote><ul><li><p>用户的交互复杂。</p></li><li><p>根据层级用户划分功能。</p></li><li><p>多个用户之间协作。</p></li><li><p>与服务器大量交互，或使用了 WebSocket。</p></li><li><p>视图层需要从多个来源获取数据。</p></li></ul><p>总结以上内容：redux 适用于 多交互，多数据源，复杂程度高的工程中。</p><p>也就是说，当我们的组件出现 某个状态需要共享，需要改变另一个组件状态 等传值比较不容易的情况。就可以考虑 redux ，当然还有其他 redux 的替代产品供我们使用。。</p><h3 id="重要内容"><a href="#重要内容" class="headerlink" title="重要内容"></a>重要内容</h3><p><img src="http://upload-images.jianshu.io/upload_images/2041009-06f5967c685f961b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>为了避免混乱，我们不应该直接修改 redux 的状态，需要有特定的办法来修改状态。<br>首先我们需要 <strong>action</strong> 来触发一个行为，告知 redux 我们需要修改状态，<br>然后应由专门生产新状态的 <strong>reducer</strong> 来产生新的状态</p></blockquote><h5 id="action"><a href="#action" class="headerlink" title="action"></a>action</h5><blockquote><p>action 是一个对象，包含这个行为的 <strong>类型</strong> 和必要的参数(可选)。action也可写成一个返回对象的函数(ActionCreator)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testAction</span>(<span class="params">key1, key2, ...keyN</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">              type: <span class="string">"TEST_ACTION"</span>,</span><br><span class="line">              key1: key1,</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">              keyN: keyN</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h5 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h5><blockquote><p>reducer 是一个纯函数，满足以下条件：</p><ul><li>相同输入必须有相同输出</li><li>不能修改传入的参数</li><li>不能包含 random、Date 等非纯函数</li></ul></blockquote><p><strong><em>另外，reducer 每次返回的必须是一个全新的状态</em></strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  article: &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">article</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Actions.ADD_ARTICLE_TAG: &#123;</span><br><span class="line">      <span class="keyword">let</span> article = <span class="built_in">Object</span>.assign(state.article);</span><br><span class="line">      <span class="keyword">if</span>(article.tags)&#123;</span><br><span class="line">        article.tags.push(action.tag);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        article.tags = [action.tag];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">article</span>: article &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="在-react-项目中使用-redux"><a href="#在-react-项目中使用-redux" class="headerlink" title="在 react 项目中使用 redux"></a>在 react 项目中使用 redux</h3><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux</span><br><span class="line">npm install --save react-redux</span><br><span class="line">npm install --save-dev redux-devtools</span><br></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><h6 id="在-index-js-文件："><a href="#在-index-js-文件：" class="headerlink" title="在 index.js 文件："></a>在 index.js 文件：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123;createStore, applyMiddleware&#125; from &apos;redux&apos;;</span><br><span class="line">import &#123;Provider&#125; from &apos;react-redux&apos;;</span><br><span class="line">import thunk from &apos;redux-thunk&apos;;</span><br><span class="line">import reducers from &apos;./src/reducers/index&apos;;</span><br><span class="line"></span><br><span class="line">const createStoreWithMiddleware = applyMiddleware(thunk)(createStore);</span><br><span class="line">const store = createStoreWithMiddleware(reducers);</span><br><span class="line"></span><br><span class="line">const router = (</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;   // 在根组件注入store</span><br><span class="line">    &lt;Router history=&#123;hashHistory&#125;&gt;</span><br><span class="line">      &lt;Route path=&quot;/&quot;&gt;</span><br><span class="line">        &lt;IndexRoute component=&#123;Login&#125; /&gt;</span><br><span class="line">        &lt;Route path=&quot;/articles&quot; component=&#123;Articles&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/articledetail&quot; component=&#123;ArticleDetail&#125;/&gt;</span><br><span class="line">      &lt;/Route&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ReactDOM.render(router, document.getElementById(&apos;root&apos;));</span><br></pre></td></tr></table></figure><p>以上： 我们先引入redux和一些函数，再引入写好的 reducer ，<code>createStoreWithMiddleware</code> 函数创建了<br>一个顶级的管理所有状态的储存器，统一管理状态。然后将生成的 store 通过 <code>Provider</code> 组件注入，<br>这样为 <code>Provider</code> 的子组件提供了状态的获取途径。</p><h6 id="reducers"><a href="#reducers" class="headerlink" title="reducers"></a>reducers</h6><p>index文件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;combineReducers&#125; <span class="keyword">from</span> <span class="string">"redux"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; admin &#125; <span class="keyword">from</span> <span class="string">'./admin'</span>;  <span class="comment">//我自己的 reduce 文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; article &#125; <span class="keyword">from</span> <span class="string">"./article"</span>;  <span class="comment">//同上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = combineReducers( &#123;</span><br><span class="line">  admin: admin,</span><br><span class="line">  article: article</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>reduce 文件(示例):<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">"../actions/config"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  logged: <span class="literal">false</span>,</span><br><span class="line">  token: <span class="string">''</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">admin</span>(<span class="params">state = initialState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> Actions.USER_LOGIN: &#123;</span><br><span class="line">      <span class="keyword">let</span> token = action.token;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">logged</span>: <span class="literal">true</span>, <span class="attr">token</span>: token &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> Actions.USER_LOGOUT: &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">logged</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h6><p>index:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; admin &#125; <span class="keyword">from</span> <span class="string">"./admin"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; article &#125; <span class="keyword">from</span> <span class="string">"./article"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...admin,</span><br><span class="line">  ...article</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>admin action:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Actions <span class="keyword">from</span> <span class="string">"./config"</span>;   <span class="comment">//储存常量字符串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: Actions.USER_LOGIN,</span><br><span class="line">    token: token</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logOut</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: Actions.USER_LOGOUT,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> admin = &#123;</span><br><span class="line">  login,</span><br><span class="line">  logOut,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>config：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//user</span></span><br><span class="line">  USER_LOGIN: <span class="string">"USER_LOGIN"</span>,</span><br><span class="line">  USER_LOGOUT:<span class="string">"USER_LOGOUT"</span>,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//article</span></span><br><span class="line">  ADD_ARTICLE_TAG: <span class="string">"ADD_ARTICLE_TAG"</span>,</span><br><span class="line">  REMOVE_ARTICLE_TAG: <span class="string">"REMOVE_ARTICLE_TAG"</span>,</span><br><span class="line">  SAVE_CONTENT: <span class="string">"SAVE_CONTENT"</span>,</span><br><span class="line">  EDIT_ARTICLE: <span class="string">"EDIT_ARTICLE"</span>,</span><br><span class="line">  CLEAR: <span class="string">"CLEAR"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//http</span></span><br><span class="line">  GET_PERSONAL_PAGE_INFO: <span class="string">"GET_PERSONAL_PAGE_INFO"</span>,</span><br><span class="line">  GET_USER_INFO: <span class="string">"GET_USER_INFO"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="使用redux"><a href="#使用redux" class="headerlink" title="使用redux"></a>使用redux</h5><blockquote><p>以上步骤已经配置好了。接下来在组件中使用redux</p><p>首先要用到的是高阶函数 <code>connect</code></p></blockquote><p>引入 <code>connect</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">"react-redux"</span>;</span><br></pre></td></tr></table></figure></p><p>连接：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params">store</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    logged: store.admin.logged,  <span class="comment">// 这里写你当前组件要用到的redux里的状态</span></span><br><span class="line">    token: store.admin.token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(select)(componentName);  <span class="comment">//componentName 是你的组件名称</span></span><br><span class="line"><span class="comment">//如果不需要redux的数据，可以这样写：</span></span><br><span class="line"><span class="comment">//export default connect()(componentName);</span></span><br></pre></td></tr></table></figure></p><p>这一步把当前组件和 redux 连在一起，把 <code>logged</code>、<code>token</code>传到当前组件的 props 里。<br>需要注意的是：还会隐藏的将 <code>dispatch</code> 方法一起注入到 props </p><p>使用：<br>使用属性的时候，只需要：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.propName</span><br></pre></td></tr></table></figure></p><p>如果要修改状态，不能直接赋值，应该使用在 actions 里的行为来触发 reducer 的纯函数来修改状态：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  login</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../actions/index'</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">this</span>.props.dispatch(login());</span><br></pre></td></tr></table></figure></p><p>这里的 dispatch 意为 分发、派遣、调度，发起一个行为（action），由reducer接收并处理</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>本文只是对redux的一个入门了解，要想学的更深入还是拜读官方文档，或者去看看源码。<br>另外，redux 有一个最佳实践写法，是由阿里前辈推出的 <a href="https://github.com/dvajs/dva" target="_blank" rel="noopener">dva</a> 框架，包含了更多的理解与应用，<br>让redux 强化了处理异步操作的能力。推荐去看看。</p><h5 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h5><p>本文是对自己写博客以及管理后台的时候遇到的问题的总结，有很多问题说的不太对，也没有仔细深究，<br>如果有不对的地方，还请指出。示例代码不详细的话，可以戳<a href="https://github.com/ShiChao1996/BlogAdmin" target="_blank" rel="noopener">这里</a>获取项目源码.</p><h6 id="欢迎来访，手动笔芯"><a href="#欢迎来访，手动笔芯" class="headerlink" title="欢迎来访，手动笔芯~"></a>欢迎来访，手动笔芯~</h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redux简介&quot;&gt;&lt;a href=&quot;#redux简介&quot; class=&quot;headerlink&quot; title=&quot;redux简介&quot;&gt;&lt;/a&gt;redux简介&lt;/h3&gt;&lt;p&gt;简单来说，redux 就是帮我们统一管理了 react 组件的 state 状态。&lt;/p&gt;
&lt;p&gt;为
      
    
    </summary>
    
    
      <category term="redux" scheme="http://yoursite.com/tags/redux/"/>
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式入门</title>
    <link href="http://yoursite.com/2018/03/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/03/13/正则表达式入门/</id>
    <published>2018-03-13T14:52:54.755Z</published>
    <updated>2018-03-13T14:52:54.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="http://upload-images.jianshu.io/upload_images/2463524-dcbd871af2bc547d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2" alt=""></p><h4 id="正则引擎"><a href="#正则引擎" class="headerlink" title="正则引擎"></a>正则引擎</h4><blockquote><p>为什么正则能有效，因为有引擎，这和为什么JS能执行一样，有JS引擎</p></blockquote><p>正则的引擎大致可分为两类：DFA和NFA</p><ul><li>DFA (Deterministic finite automaton) 确定型有穷自动机</li><li>NFA (Non-deterministic finite automaton) 非确定型有穷自动机，大部分都是NFA</li></ul><p>这里的“确定型”指，对于某个确定字符的输入，这台机器的状态会确定地从a跳到b，“非确定型”指，对于某个确定字符的输入，这台机器可能有好几种状态的跳法；这里的“有穷”指，状态是有限的，可以在有限的步数内确定某个字符串是被接受还是发好人卡的；这里的“自动机”，可以理解为，一旦这台机器的规则设定完成，就可以自行判断了，不要人看。</p><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p><img src="http://upload-images.jianshu.io/upload_images/2463524-8ddaddee044d96fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><blockquote><p>正则眼中的字符串——n个字符，n+1个位置</p><p>为什么要有字符还要有位置呢？因为位置是可以被匹配的。</p></blockquote><p>“占有字符”和“零宽度”:</p><ul><li>如果一个子正则表达式匹配到的是字符，而不是位置，而且会被保存到最终的结果中，那个这个子表达式就是占有字符的，比如  /ha/  （匹配   ha  ）就是占有字符的；</li><li>如果一个子正则匹配的是位置，而不是字符，或者匹配到的内容不保存在结果中（其实也可以看做一个位置），那么这个子表达式是零宽度的，比如     /read(?=ing)/   （匹配     reading     ，但是只将read放入结果中，下文会详述语法，此处仅仅举例用），其中的(?=ing)就是零宽度的，它本质代表一个位置。</li></ul><blockquote><p>占有字符是互斥的，零宽度是非互斥的。也就是一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。举个栗子，比如/aa/是匹配不了a的，这个字符串中的a只能由正则的第一个a字符匹配，而不能同时由第二个a匹配（废话）；但是位置是可以多个匹配的，比如/\b\ba/是可以匹配a的，虽然正则表达式里有2个表示单词开头位置的\b元字符，这两个\b是可以同时匹配位置0（在这个例子中）的</p></blockquote><h5 id="控制权和传动"><a href="#控制权和传动" class="headerlink" title="控制权和传动"></a>控制权和传动</h5><p>控制权是指哪一个正则子表达式（可能为一个普通字符、元字符或元字符序列组成）在匹配字符串，那么控制权就在哪。</p><p>传动是指正则引擎的一种机制，传动装置将定位正则从字符串的哪里开始匹配。</p><blockquote><p>正则表达式当开始匹配的时候，一般是由一个子表达式获取控制权，从字符串中的某一个位置开始尝试匹配，一个子表达式开始尝试匹配的位置，是从前一子表达匹配成功的结束位置开始的</p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><img src="http://upload-images.jianshu.io/upload_images/2463524-62ea8063e4cf5821.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="要用某类常见字符——简单元字符"><a href="#要用某类常见字符——简单元字符" class="headerlink" title="要用某类常见字符——简单元字符"></a>要用某类常见字符——简单元字符</h4><ul><li>‘.’ 匹配除了换行符以外的任意字符，也即是[^\n]，如果要包含任意字符，可使用(.|\n)</li><li>\w    (whatever) 匹配任意字母、数字或者下划线，等价于[a-zA-Z0-9_]，在deerchao的文中还指出可匹配汉字，但是\w在JS中是不能匹配汉字的</li><li>\s     (space)  匹配任意空白符，包含换页符\f、换行符\n、回车符\r、水平制表符\t、垂直制表符\v</li><li>\d    匹配数字</li><li>\un   (Unicode) 匹配n，这里的n是一个有4个十六进制数字表示的Unicode字符，比如\u597d表示中文字符“好”，那么超过\uffff编号的字符怎么表示呢？ES6的u修饰符会帮你。</li></ul><h4 id="要表示出现次数（重复）——限定符"><a href="#要表示出现次数（重复）——限定符" class="headerlink" title="要表示出现次数（重复）——限定符"></a>要表示出现次数（重复）——限定符</h4><ul><li>a*表示字符a连续出现次数 &gt;= 0 次</li><li>a+表示字符a连续出现次数 &gt;= 1 次</li><li>a?表示字符a出现次数 0 或 1 次</li><li>a{5}表示字符a连续出现次数 5 次</li><li>a{5,}表示字符a连续出现次数 &gt;= 5次</li><li>a{5,10}表示字符a连续出现次数为 5到10次 ，包括5和10</li></ul><h4 id="匹配位置——定位符和零宽断言"><a href="#匹配位置——定位符和零宽断言" class="headerlink" title="匹配位置——定位符和零宽断言"></a>匹配位置——定位符和零宽断言</h4><ul><li>\b  匹配单词边界位置，准确的描述是它匹配一个位置，这个位置前后不全是\w能描述的字符，所以像\u597d\babc是可以匹配“好abc”的。</li><li>^   匹配字符串开始位置，也就是位置0，如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置</li><li>$   匹配字符串结束位置，如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置</li></ul><h4 id="想表达“或”的意思——字符簇和分歧"><a href="#想表达“或”的意思——字符簇和分歧" class="headerlink" title="想表达“或”的意思——字符簇和分歧"></a>想表达“或”的意思——字符簇和分歧</h4><blockquote><p>字符簇可用来表达字符级别的“或”语义，表示的是方括号中的字符任选一：</p></blockquote><ul><li>[abc]表示a、b、c这3个字符中的任意一个，如果字母或者数字是连续的，那么可以用-连起来表示，[b-f]代表从b到f这么多字符中任选一个</li><li>[(ab)(cd)]并不会用来匹配字符串“ab”或“cd”，而是匹配a、b、c、d、(、)这6个字符中的任一个，也就是想表达“匹配字符串ab或者cd”这样的需求不能这么做，要这么写ab|cd。但这里要匹配圆括号本身，讲道理是要反斜杠转义的，但是在方括号中，圆括号被当成普通字符看待，即便如此，仍然建议显式地转义</li><li>分歧用来表达表达式级别的“或”语义，表示的是匹配|左右任一表达就可：<br>ab|cd会匹配字符串“ab”或者“cd”</li><li>会短路，回想下编程语言中逻辑或的短路，所以用(ab|abc)去匹配字符串“abc”，结果会是“ab”，因为竖线左边的已经满足了，就用左边的匹配结果代表整个正则的结果</li></ul><h4 id="想表达“非”的意思——反义"><a href="#想表达“非”的意思——反义" class="headerlink" title="想表达“非”的意思——反义"></a>想表达“非”的意思——反义</h4><ul><li>\W、\D、\S、\B 用大写字母的这几个元字符表示就是对应小写字母匹配内容的反义，这几个依次匹配“除了字母、数字、下划线外的字符”、“非数字字符”、“非空白符”、“非单词边界位置”</li><li>[^aeiou]表示除了a、e、i、o、u外的任一字符，在方括号中且出现在开头位置的^表示排除，如果^在方括号中不出现在开头位置，那么它仅仅代表^字符本身</li></ul><h4 id="贪婪和非贪婪"><a href="#贪婪和非贪婪" class="headerlink" title="贪婪和非贪婪"></a>贪婪和非贪婪</h4><p>在限定符中，除了{n}确切表示重复几次，其余的都是一个有下限的范围。</p><p>在默认的模式（贪婪）下，会尽可能多的匹配内容。比如用ab*去匹配字符串“abbb”，结果是“abbb”。</p><p>而通过在限定符后面加问号?可以进行非贪婪匹配，会尽可能少地匹配。用ab*?去匹配“abbb”，结果会是“a”。</p><p>不带问号的限定符也称匹配优先量词，带问号的限定符也称忽略匹配优先量词。</p><h2 id="JS-中的正则"><a href="#JS-中的正则" class="headerlink" title="JS 中的正则"></a>JS 中的正则</h2><blockquote><p>字面量, 构造函数和工厂符号都是可以的：</p></blockquote><pre><code>/pattern/flagsnew RegExp(pattern [, flags])RegExp(pattern [, flags])</code></pre><p>参数<br>pattern<br>正则表达式的文本。<br>flags<br>如果指定，标志可以具有以下值的任意组合：</p><ul><li><p>g 全局匹配;找到所有匹配，而不是在第一个匹配后停止</p></li><li><p>i 忽略大小写</p></li><li><p>m 多行; 将开始和结束字符（^和$）视为在多行上工作（例如，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。</p></li><li><p>u Unicode; 将模式视为Unicode序列点的序列</p></li><li><p>y 粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)。</p></li></ul><blockquote><p>有两种方法来创建一个RegExp对象：一是字面量、二是构造函数。要指示字符串，字面量的参数不使用引号，而构造函数的参数使用引号。因此，以下表达式创建相同的正则表达式</p></blockquote><pre><code>/ab+c/i;new RegExp(&apos;ab+c&apos;, &apos;i&apos;);new RegExp(/ab+c/, &apos;i&apos;);</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><blockquote><p>RegExp.prototype.exec()</p></blockquote><p>exec() 方法在一个指定字符串中执行一个搜索匹配。返回一个结果数组或 null。</p><pre><code>var matches = /h./.exec(&apos;This is a hello world!&apos;);console.log(matches);        // [ &apos;hi&apos;, index: 1, input: &apos;This is a hello world!&apos; ]</code></pre><blockquote><p>RegExp.prototype.test()</p></blockquote><p>test() 方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false。</p><p>当你想要知道一个模式是否存在于一个字符串中时，就可以使用 test()（类似于 String.prototype.search() 方法），差别在于test返回一个布尔值，而 search 返回索引（如果找到）或者-1（如果没找到）</p><pre><code>let str = &apos;hello world!&apos;;let result = /hello/.test(str);console.log(result);// true</code></pre><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><blockquote><p>使用正则改变数据结构</p></blockquote><p>下例使用 replace 方法 （继承自 String）去匹配姓名 first last 输出新的格式 last, first。脚本中使用 $1 和 $2 指明括号里先前的匹配.</p><pre><code>var re = /(\w+)\s(\w+)/;var str = &quot;John Smith&quot;;var newstr = str.replace(re, &quot;$2, $1&quot;);print(newstr);          //&quot;Smith, John&quot;</code></pre><blockquote><p>在多行中使用正则表达式</p></blockquote><pre><code>var s = &quot;Please yes\nmake my day!&quot;;s.match(/yes.*day/);// Returns nulls.match(/yes[^]*day/);// Returns &apos;yes\nmake my day&apos;</code></pre><blockquote><p>使用正则表达式和 Unicode 字符</p></blockquote><p>\w 或 \W 只会匹配基本的 ASCII 字符；如 ‘a’ 到 ‘z’、 ‘A’ 到 ‘Z’、 0 到 9 及 ‘_’。为了匹配其他语言中的字符，如西里尔（Cyrillic）或 希伯来语（Hebrew），要使用 \uhhhh，”hhhh” 表示以十六进制表示的字符的 Unicode 值</p><pre><code>var text = &quot;Образец text на русском языке&quot;;var regex = /[\u0400-\u04FF]+/g;var match = regex.exec(text);print(match[1]);  // prints &quot;Образец&quot;print(regex.lastIndex);  // prints &quot;7&quot;var match2 = regex.exec(text);print(match2[1]);  // prints &quot;на&quot; [did not print &quot;text&quot;]print(regex.lastIndex);  // prints &quot;15&quot;// and so on</code></pre><blockquote><p>从 URL 中提取子域名</p></blockquote><pre><code>var url = &quot;http://xxx.domain.com&quot;;print(/[^.]+/.exec(url)[0].substr(7)); // prints &quot;xxx&quot;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2463524-dcbd87
      
    
    </summary>
    
    
      <category term="regex" scheme="http://yoursite.com/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>dart 语法基础</title>
    <link href="http://yoursite.com/2018/03/13/dart%20%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/03/13/dart 语法基础/</id>
    <published>2018-03-13T14:49:13.901Z</published>
    <updated>2018-03-13T14:49:13.901Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是对 Dart 语言的官方文档做了简单的翻译和总结，有不当之处敬请指正。<br>如果有时间和精力建议通读<a href="https://www.dartlang.org/guides/language/language-tour" target="_blank" rel="noopener">官方文档</a></p></blockquote><h3 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h3><pre><code>// Define a function.printNumber(num aNumber) {  print(&apos;The number is $aNumber.&apos;); // Print to console.}// This is where the app starts executing.main() {  var number = 42; // Declare and initialize a variable.  printNumber(number); // Call a function.}</code></pre><hr><h3 id="重要的概念"><a href="#重要的概念" class="headerlink" title="重要的概念"></a>重要的概念</h3><ul><li>能赋值给变量的所以东西都是对象，包括 numbers, null, function, 都是继承自 Object 内置类</li><li>尽量给变量定义一个类型，会更安全，没有显示定义类型的变量在 debug 模式下会类型会是  dynamic（动态的）</li><li>dart 在 running 之前解析你的所有代码，指定数据类型和编译时的常量，可以提高运行速度</li><li>dart 提供了顶级函数(如：main())</li><li>dart 没有 public、private、protected 这些关键字，变量名以”_”开头意味着对它的 lib 是私有的</li></ul><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>没有初始化的变量都会被赋予默认值 null</p></blockquote><pre><code>var name = &apos;Bob&apos;;var unInitializeValue1;   //未给初值的变量，默认值为 nullInt unInitializeValue2;   //即使是Int 型，默认值也是 null</code></pre><p>程序中只当数据类型是为了指出自己的使用意图，并帮助语言进行语法检查。但是，指定类型不是必须的</p><h6 id="num"><a href="#num" class="headerlink" title="num"></a>num</h6><ul><li><p>int 取值范围：-2^53 to 2^53</p><pre><code>// String -&gt; intvar one = int.parse(&apos;1&apos;);// String -&gt; doublevar onePointOne = double.parse(&apos;1.1&apos;);// int -&gt; StringString oneAsString = 1.toString();// double -&gt; String 注意括号中要有小数点位数，否则报错String piAsString = 3.14159.toStringAsFixed(2);</code></pre></li></ul><h6 id="string"><a href="#string" class="headerlink" title="string"></a>string</h6><ul><li>‘’’…’’’，”””…”””表示多行字符串</li><li>r’…’,r”…”表示“raw”字符串</li><li>用 $ 或 ${} 来计算字符串中变量的值</li></ul><h6 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h6><ul><li>Dart 是强 bool 类型检查，<strong>只有bool 类型的值是true 才被认为是true</strong></li></ul><h6 id="list"><a href="#list" class="headerlink" title="list"></a>list</h6><blockquote><p>list 基本和 JavaScript 数组一样，它的方法如下：</p></blockquote><pre><code>// 使用List的构造函数，也可以添加int参数，表示List固定长度，不能进行添加 删除操作var vegetables = new List();// 或者简单的用List来赋值var fruits = [&apos;apples&apos;, &apos;oranges&apos;];// 添加元素fruits.add(&apos;kiwis&apos;);// 添加多个元素fruits.addAll([&apos;grapes&apos;, &apos;bananas&apos;]);// 获取第一个元素fruits.first;// 获取元素最后一个元素fruits.last;// 查找某个元素的索引号assert(fruits.indexOf(&apos;apples&apos;) == 0);// 删除指定位置的元素，返回删除的元素fruits.removeAt(index);// 删除指定元素,成功返回true，失败返回falsefruits.remove(&apos;apples&apos;);// 删除最后一个元素，返回删除的元素fruits.removeLast();// 删除指定范围元素，含头不含尾，成功返回nullfruits.removeRange(start,end);// 删除指定条件的元素，成功返回nullfruits.removeWhere((item) =&gt; item.length &gt;6)；// 删除所有的元素fruits.clear();// sort()对元素进行排序，传入一个函数作为参数，return &lt;0表示由小到大， &gt;0表示由大到小fruits.sort((a, b) =&gt; a.compareTo(b));</code></pre><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><blockquote><p>类似 JavaScript map</p></blockquote><pre><code>// Map的声明var hawaiianBeaches = {    &apos;oahu&apos; : [&apos;waikiki&apos;, &apos;kailua&apos;, &apos;waimanalo&apos;],    &apos;big island&apos; : [&apos;wailea bay&apos;, &apos;pololu beach&apos;],    &apos;kauai&apos; : [&apos;hanalei&apos;, &apos;poipu&apos;]};var searchTerms = new Map();// 指定键值对的参数类型var nobleGases = new Map&lt;int, String&gt;();// Map的赋值，中括号中是Key，这里可不是数组nobleGase[54] = &apos;dart&apos;;//Map中的键值对是唯一的//同Set不同，第二次输入的Key如果存在，Value会覆盖之前的数据nobleGases[54] = &apos;xenon&apos;;assert(nobleGases[54] == &apos;xenon&apos;);// 检索Map是否含有某Keyassert(nobleGases.containsKey(54));//删除某个键值对nobleGases.remove(54);assert(!nobleGases.containsKey(54));</code></pre><p>注：如果定义了一个 map 常量，那么value 也必须是常量</p><h6 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h6><h2 id="gt-symbol字面量是编译时常量，在标识符前面加-。如果是动态确定，则使用Symbol构造函数，通过new来实例化"><a href="#gt-symbol字面量是编译时常量，在标识符前面加-。如果是动态确定，则使用Symbol构造函数，通过new来实例化" class="headerlink" title="&gt;symbol字面量是编译时常量，在标识符前面加#。如果是动态确定，则使用Symbol构造函数，通过new来实例化"></a>&gt;symbol字面量是编译时常量，在标识符前面加#。如果是动态确定，则使用Symbol构造函数，通过new来实例化</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><p>所有的函数都会有返回值。如果没有指定函数返回值，则默认的返回值是null。没有返回值的函数，系统会在最后添加隐式的return 语句。</p></blockquote><h6 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h6><p>函数可以有两种类型的参数：</p><ul><li>必须的——必须的参数放在参数列表的前面。</li><li>可选的——可选的参数跟在必须的参数后面。</li></ul><p>注：可选参数必须放在最后</p><blockquote><p>通过【】来表示可选参数</p></blockquote><pre><code>String say(String from, String msg, [String device]) {  var result = &apos;$from says $msg&apos;;  if (device != null) {    result = &apos;$result with a $device&apos;;  }  return result;}</code></pre><blockquote><p>还可以设置默认参数值</p></blockquote><pre><code>String say(String from, String msg,    [String device = &apos;carrier pigeon&apos;, String mood]) {  var result = &apos;$from says $msg&apos;;  if (device != null) {    result = &apos;$result with a $device&apos;;  }  if (mood != null) {    result = &apos;$result (in a $mood mood)&apos;;  }  return result;}</code></pre><blockquote><p>函数还可以作为另一个函数的参数</p></blockquote><pre><code>printElement(element) {  print(element);}var list = [1, 2, 3];// Pass printElement as a parameter.list.forEach(printElement);</code></pre><blockquote><p>函数可以匿名，但是不像 JavaScript， 匿名函数不用加上 function 关键字</p></blockquote><pre><code>var list = [&apos;apples&apos;, &apos;oranges&apos;, &apos;grapes&apos;, &apos;bananas&apos;, &apos;plums&apos;];list.forEach((i) {  print(list.indexOf(i).toString() + &apos;: &apos; + i);});</code></pre><h6 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h6><pre><code>Function makeAdder(num addBy) {  return (num i) =&gt; addBy + i;}main() {  // Create a function that adds 2.  var add2 = makeAdder(2);  // Create a function that adds 4.  var add4 = makeAdder(4);  assert(add2(3) == 5);  assert(add4(3) == 7);}</code></pre><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>除了常见的，还有如下运算符：</p><ul><li>is 运算符，a is b，用于判断 a 对象是否是 b 类的实例，返回 bool 值</li><li>is！意义与上面相反</li><li><p>as 运算符；用于检查类型</p><pre><code>(emp as Person).firstName = &apos;Bob&apos;;</code></pre></li></ul><p>如果 emp 为空或者不是 Person 的实例，会抛出异常</p><ul><li><p>??= 运算符</p><pre><code>b ??= value; // 如果 b 为空，把 value 赋值给 b;             // 否则，b 不变</code></pre></li><li><p>?? 运算符</p><pre><code>String toString() =&gt; msg ?? super.toString();//如果 msg 不为空，返回 msg；否则返回后面的</code></pre></li><li><p>.. 运算符，把对同一对象的不同操作串联起来</p><pre><code>final addressBook = (new AddressBookBuilder()      ..name = &apos;jenny&apos;      ..email = &apos;jenny@example.com&apos;      ..phone = (new PhoneNumberBuilder()            ..number = &apos;415-555-0100&apos;            ..label = &apos;home&apos;)          .build())    .build();</code></pre></li></ul><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><ul><li>if…else</li><li>for</li><li>while do-while</li><li>break continue</li><li>switch…case  如果 case 后面有表达式但是没有 break，会抛出异常</li><li>assert（仅在checked模式有效），如果条件为假，抛出异常</li></ul><hr><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><ul><li><p>抛出固定类型的异常：</p><pre><code>throw new FormatException(&apos;Expected at least 1 section&apos;);</code></pre></li><li><p>抛出任意类型的异常：</p><pre><code>throw &apos;out of llamas！&apos;</code></pre></li><li><p>因为抛出异常属于表达式，可以将throw语句放在=&gt;语句中，或者其它可以出现表达式的地方：</p><pre><code>distanceTo(Point other) =&gt;    throw new UnimplementedError();</code></pre><h5 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h5></li><li><p>可以通过 on语句来指定需要捕获的异常类型，使用catch来处理异常</p><pre><code>try {  breedMoreLlamas();} on OutOfLlamasException {  // A specific exception  buyMoreLlamas();} on Exception catch (e) {  // Anything else that is an exception  print(&apos;Unknown exception: $e&apos;);} catch (e, s) {  print(&apos;Exception details:\n $e&apos;);  print(&apos;Stack trace:\n $s&apos;);}</code></pre></li></ul><p>可以向catch()传递1个或2个参数。第一个参数表示：捕获的异常的具体信息，第二个参数表示：异常的堆栈跟踪(stack trace)</p><h5 id="rethrow"><a href="#rethrow" class="headerlink" title="rethrow"></a>rethrow</h5><blockquote><p>rethrow语句用来处理一个异常，同时希望这个异常能够被其它调用的部分使用</p></blockquote><h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><blockquote><p>Dart 的finally用来执行那些无论异常是否发生都执行的操作。</p></blockquote><hr><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><blockquote><p>使用new语句来构造一个类。构造函数的名字可能是ClassName，也可以是ClassName.identifier</p></blockquote><pre><code>var jsonData = JSON.decode(&apos;{&quot;x&quot;:1, &quot;y&quot;:2}&apos;);// Create a Point using Point().var p1 = new Point(2, 2);// Create a Point using Point.fromJson().var p2 = new Point.fromJson(jsonData);</code></pre><ul><li>使用.来调用实例的变量或者方法。</li><li>使用 ?. 来避免左边操作数为null引发异常。</li><li>使用const替代new来创建编译时的常量构造函数。</li><li>两个使用const构建的同一个构造函数，实例相等。</li><li>获取对象的运行时类型使用：o.runtimeType</li></ul><blockquote><p>所有实例变量会生成一个隐式的getter方法，不是final或const的实例变量也会生成一个隐式的setter方法</p></blockquote><h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><pre><code>class Point {  num x;  num y;  // 推荐方式  Point(this.x, this.y);}</code></pre><blockquote><p>构造函数不能被继承</p></blockquote><p>子类不会继承父类的构造函数。如果不显式提供子类的构造函数，系统就提供默认的构造函数。</p><blockquote><p>命名构造函数</p></blockquote><pre><code>class Point {  num x;  num y;  Point(this.x, this.y);  // 命名构造函数  Point.fromJson(Map json) {    x = json[&apos;x&apos;];    y = json[&apos;y&apos;];  }}</code></pre><p>使用命名构造函数可以实现一个类多个构造函数。构造函数不能被继承，父类中的命名构造函数不能被子类继承。如果想要子类也拥有一个父类一样名字的构造函数，必须在子类实现这个构造函数</p><blockquote><p>如果父类不显式提供无参的非命名构造函数，在子类中必须手动调用父类的一个构造函数。在子类构造函数名后，大括号{前，使用super.调用父类的构造函数，中间使用:分割</p></blockquote><pre><code>class Person {  String firstName;  Person.fromJson(Map data) {    print(&apos;in Person&apos;);  }}class Employee extends Person {  // 父类没有无参数的非命名构造函数，必须手动调用一个构造函数 super.fromJson(data)  Employee.fromJson(Map data) : super.fromJson(data) {    print(&apos;in Employee&apos;);  }}</code></pre><blockquote><p>当在构造函数初始化列表中使用super()时，要把它放在最后。</p></blockquote><pre><code>View(Style style, List children)    : _children = children,      super(style) {}</code></pre><blockquote><p>除了调用父类的构造函数，也可以通过初始化列表 在子类的构造函数体前（大括号前）来初始化实例的变量值，使用逗号,分隔</p></blockquote><pre><code>class Point {  num x;  num y;  Point(this.x, this.y);  // 在构造函数体前 初始化列表 设置实例变量  Point.fromJson(Map jsonMap)      : x = jsonMap[&apos;x&apos;],        y = jsonMap[&apos;y&apos;] {    print(&apos;In Point.fromJson(): ($x, $y)&apos;);  }}</code></pre><h5 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h5><blockquote><p>当实例化了一个构造函数后，不想每次都创建该类的一个新的实例的时候使用factory关键字，定义工厂构造函数，从缓存中返回一个实例，或返回一个子类型的实例</p></blockquote><pre><code>class Logger {  final String name;  bool mute = false;  static final Map&lt;String, Logger&gt; _cache = &lt;String, Logger&gt;{}; // 缓存保存对象  factory Logger(String name) {    if (_cache.containsKey(name)) {      return _cache[name];    } else {      final logger = new Logger._internal(name);      _cache[name] = logger;      return logger;    }  }  Logger._internal(this.name);// 命名构造函数  void log(String msg) {    if (!mute) {      print(msg);    }  }}main() {  var p1 = new Logger(&quot;1&quot;);  p1.log(&quot;2&quot;);  var p2 = new Logger(&apos;22&apos;);  p2.log(&apos;3&apos;);  var p3 = new Logger(&apos;1&apos;);// 相同对象直接访问缓存}</code></pre><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><h6 id="Getters-and-setters"><a href="#Getters-and-setters" class="headerlink" title="Getters and setters"></a>Getters and setters</h6><blockquote><p>get()和set()方法是Dart 语言提供的专门用来读取和写入对象的属性的方法。每一个类的实例变量都有一个隐式的getter和可能的setter（如果字段为final或const，只有getter）</p></blockquote><h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><blockquote><p>使用abstract关键字定义一个抽象类，抽象类不能实例化。抽象类通常用来定义接口。</p></blockquote><h5 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h5><blockquote><p>每一个类都隐式的定义一个接口，这个接口包含了这个类的所有实例成员和它实现的所有接口</p><p>一个类可以实现一个或多个（用,隔开）接口，通过implements关键字。</p></blockquote><pre><code>class Person {  final _name;  Person(this._name);  String greet(who) =&gt; &apos;hello,$who,i am $_name&apos;;}class Imposter implements Person {  final _name = &apos;&apos;;  String greet(who) =&gt; &apos;hi $who.do you know who i am.&apos;;}greetBob(Person p) =&gt; p.greet(&apos;bob&apos;);main(List&lt;String&gt; args) {  print(greetBob(new Person(&apos;lili&apos;)));  print(greetBob(new Imposter()));}</code></pre><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><blockquote><p>使用extends来创造子类，使用super来指向父类</p></blockquote><h5 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h5><blockquote><p>枚举类型是一种特殊的类，通常用来表示一组固定数字的常量值。</p><p>每个枚举类型都有一个index的getter，返回以0开始的位置索引，每次加1。</p><p>在switch语句中使用枚举，必须在case语句中判断所有的枚举，否则会获得警告。</p></blockquote><p>枚举类型有以下限制：</p><ul><li>不能继承，mixin，或实现一个枚举。</li><li>不能显式的实例化一个枚举。</li></ul><hr><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><blockquote><p>使用&lt;…&gt; 的方式来定义泛型</p><p>虽然Dart 语言中类型是可选的，但是明确的指明使用的是泛型，会让代码更好理解</p></blockquote><pre><code>abstract class Cache&lt;T&gt; {   T getByKey(String key);   setByKey(String key, T value); }</code></pre><h5 id="用于集合类型"><a href="#用于集合类型" class="headerlink" title="用于集合类型"></a>用于集合类型</h5><blockquote><p>泛型用于List 和 Map 类型参数化</p></blockquote><pre><code>var names = &lt;String&gt;[&apos;Seth&apos;, &apos;Kathy&apos;, &apos;Lars&apos;];var pages = &lt;String, String&gt;{  &apos;index.html&apos;: &apos;Homepage&apos;,  &apos;robots.txt&apos;: &apos;Hints for web robots&apos;,  &apos;humans.txt&apos;: &apos;We are people, not machines&apos;};</code></pre><h5 id="泛型集合及它们所包含的类型"><a href="#泛型集合及它们所包含的类型" class="headerlink" title="泛型集合及它们所包含的类型"></a>泛型集合及它们所包含的类型</h5><blockquote><p>dart的泛型类型是具体的，在运行时包含它们的类型信息。</p></blockquote><hr><h3 id="库和可见性"><a href="#库和可见性" class="headerlink" title="库和可见性"></a>库和可见性</h3><blockquote><p>使用import 和 library 指令可以方便的创建一个模块或分享代码。一个Dart 库不仅能够提供相应的API，还可以包含一些以_开头的私有变量仅在库内部可见</p><p>如果导入的库拥有相互冲突的名字，使用as为其中一个或几个指定不一样的前缀。</p></blockquote><pre><code>import &apos;package:lib1/lib1.dart&apos;;import &apos;package:lib2/lib2.dart&apos; as lib2;// ...Element element1 = new Element();           // Uses Element from lib1.lib2.Element element2 = new lib2.Element(); // Uses Element from lib2.</code></pre><blockquote><p>如果只需要使用库的一部分内容，使用show或hide有选择的导入。</p></blockquote><pre><code>// 仅导入foo.import &apos;package:lib1/lib1.dart&apos; show foo;// 除了foo都导入import &apos;package:lib2/lib2.dart&apos; hide foo;</code></pre><blockquote><p>要延迟加载一个库，首先必须使用deferred as导入它。</p></blockquote><pre><code>import &apos;package:deferred/hello.dart&apos; deferred as hello;greet() async {  // 使用await关键字暂停执行，直到库加载  await hello.loadLibrary();  hello.printGreeting();}</code></pre><p>可以在代码中多次调用loadLibrary()方法。但是实际上它只会被执行一次。</p><p>使用延迟加载的注意事项：</p><ul><li>延迟加载的内容只有在加载后才存在。</li><li>Dart 隐式的将deferred as改为了deferred as namespace。loadLibrary()返回值是Future</li></ul><hr><h3 id="异步支持"><a href="#异步支持" class="headerlink" title="异步支持"></a>异步支持</h3><p>使用async函数和await表达式实现异步操作。</p><p>当需要使用一个从Future返回的值时，有两个选择：</p><ul><li>使用async和await。</li><li>使用Future API。</li></ul><p>当需要从一个Stream获取值时，有两个选择：</p><ul><li>使用async和异步的循环(await for)。</li><li><p>使用Stream API。<br>代码使用了async和await就是异步的，虽然看起来像同步代码。</p><pre><code>checkVersion() async {          //注意这里 async 在小括号后面，和 JavaScript 不一样  var version = await lookUpVersion();  if (version == expectedVersion) {    // Do something.  } else {    // Do something else.  }}</code></pre></li></ul><blockquote><p>给函数添加async关键字将使函数返回一个Future类型。</p></blockquote><pre><code>// 修改前是同步的String lookUpVersionSync() =&gt; &apos;1.0.0&apos;;// 修改后 是异步的 函数体不需要使用Future API// dart会在必要的时候创建Future对象Future&lt;String&gt; lookUpVersion() async =&gt; &apos;1.0.0&apos;;</code></pre><blockquote><p>在Stream中使用异步循环</p></blockquote><pre><code> // expression的值必须是Stram类型await for (variable declaration in expression) {  // Executes each time the stream emits a value.}</code></pre><p>异步循环的执行流程如下：</p><ul><li>等待 stream 发出数据。</li><li>执行循环体，并将变量的值设置为发出的数据。</li><li>重复1.，2.直到stream 对象被关闭</li></ul><p>注：这个过程类似于 JavaScript 的 Rxjs</p><hr><h3 id="可调用类"><a href="#可调用类" class="headerlink" title="可调用类"></a>可调用类</h3><blockquote><p>Dart 语言中为了能够让类像函数一样能够被调用，可以实现call()方法。</p></blockquote><pre><code>class WannabeFunction {  call(String a, String b, String c) =&gt; &apos;$a $b $c!&apos;;}main() {  var wf = new WannabeFunction();  var out = wf(&quot;Hi&quot;,&quot;there,&quot;,&quot;gang&quot;);  print(&apos;$out&apos;); // Hi there, gang!  print(wf.runtimeType); // WannabeFunction  print(out.runtimeType); // String  print(wf is Function); // true}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文是对 Dart 语言的官方文档做了简单的翻译和总结，有不当之处敬请指正。&lt;br&gt;如果有时间和精力建议通读&lt;a href=&quot;https://www.dartlang.org/guides/language/language-tour&quot; targe
      
    
    </summary>
    
    
      <category term="dart" scheme="http://yoursite.com/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>Go bytes.go</title>
    <link href="http://yoursite.com/2018/03/13/byte/"/>
    <id>http://yoursite.com/2018/03/13/byte/</id>
    <published>2018-03-13T13:37:56.646Z</published>
    <updated>2018-03-13T13:37:56.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习bytes的时候，网上找了很多文章，但基本上是用法，很少对代码的分析。这篇文章对bytes.go 做了简要的分析。</p></blockquote><p>首先从 <code>import</code> 的包来看，只引入了<code>unicode</code> 包的部分函数，所以这个文件代码主要是对字节切片做字符处理。从主要的功能来分，bytes.go 分为几个部分：</p><ul><li>index/contain 系列函数</li><li>splite、fields 拆分函数</li><li>Map 遍历函数</li></ul><h3 id="prepare"><a href="#prepare" class="headerlink" title="prepare"></a>prepare</h3><p>开始对每个部分分析前，先来看一下 <code>unicode</code> 包里用的比较多的内容。</p><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">RuneError = <span class="string">'\uFFFD'</span>     <span class="comment">// 这是一个特殊的字符，用于表示“非法”的unicode</span></span><br><span class="line">RuneSelf  = <span class="number">0x80</span>         <span class="comment">// 十六进制的80，等于十进制的127，0~127刚好表示128个ASCII码。一个字符的字节码大于127，表示不是ASCII，可能是unicode</span></span><br><span class="line">MaxRune   = <span class="string">'\U0010FFFF'</span> <span class="comment">// 最大的unicode编码</span></span><br><span class="line">UTFMax    = <span class="number">4</span>            <span class="comment">// 一个unicode码最大的字节长度</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>utf8.DecodeRune(p []byte)(r rune, size int):从字节切片中解析出第一个完整的unicode码，<br>返回一个<code>rune</code>类型的<code>r</code>（第一个unicode），和<code>r</code>的真实长度size，从代码中可看出，size的值是0~4。简单看一下返回值就好，这不是本文的重点：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecodeRune</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(r <span class="keyword">rune</span>, size <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(p)</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> RuneError, <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">p0 := p[<span class="number">0</span>]</span><br><span class="line">x := first[p0]</span><br><span class="line"><span class="keyword">if</span> x &gt;= as &#123;</span><br><span class="line"><span class="comment">// The following code simulates an additional check for x == xx and</span></span><br><span class="line"><span class="comment">// handling the ASCII and invalid cases accordingly. This mask-and-or</span></span><br><span class="line"><span class="comment">// approach prevents an additional branch.</span></span><br><span class="line">mask := <span class="keyword">rune</span>(x) &lt;&lt; <span class="number">31</span> &gt;&gt; <span class="number">31</span> <span class="comment">// Create 0x0000 or 0xFFFF.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">rune</span>(p[<span class="number">0</span>])&amp;^mask | RuneError&amp;mask, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">sz := x &amp; <span class="number">7</span></span><br><span class="line">accept := acceptRanges[x&gt;&gt;<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="keyword">int</span>(sz) &#123;</span><br><span class="line"><span class="keyword">return</span> RuneError, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">b1 := p[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> b1 &lt; accept.lo || accept.hi &lt; b1 &#123;</span><br><span class="line"><span class="keyword">return</span> RuneError, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sz == <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">rune</span>(p0&amp;mask2)&lt;&lt;<span class="number">6</span> | <span class="keyword">rune</span>(b1&amp;maskx), <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">b2 := p[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> b2 &lt; locb || hicb &lt; b2 &#123;</span><br><span class="line"><span class="keyword">return</span> RuneError, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sz == <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">rune</span>(p0&amp;mask3)&lt;&lt;<span class="number">12</span> | <span class="keyword">rune</span>(b1&amp;maskx)&lt;&lt;<span class="number">6</span> | <span class="keyword">rune</span>(b2&amp;maskx), <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">b3 := p[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> b3 &lt; locb || hicb &lt; b3 &#123;</span><br><span class="line"><span class="keyword">return</span> RuneError, <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">rune</span>(p0&amp;mask4)&lt;&lt;<span class="number">18</span> | <span class="keyword">rune</span>(b1&amp;maskx)&lt;&lt;<span class="number">12</span> | <span class="keyword">rune</span>(b2&amp;maskx)&lt;&lt;<span class="number">6</span> | <span class="keyword">rune</span>(b3&amp;maskx), <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>注意以上函数返回值， rune 是一个 int32， 占4字节，size则是返回的unicode占的真实长度</strong>。这里统一用四个字节来表示一个unicode。</p><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>这里有一系列的index的函数:</p><ul><li>func Contains(b, subslice []byte) bool</li><li>func Count(s, sep []byte) int</li><li>func Index(s, sep []byte) int</li><li>func IndexByte(s []byte, c byte) int</li><li>func IndexRune(s []byte, r rune) int</li><li>func IndexAny(s []byte, chars string) int</li><li>func IndexFunc(s []byte, f func(r rune) bool) int</li><li>func LastIndex(s, sep []byte) int</li><li>func LastIndexAny(s []byte, chars string) int</li><li>func LastIndexFunc(s []byte, f func(r rune) bool) int</li><li>…</li></ul><p>但是基本上是在调用同一个函数： <code>func Index(s, sep []byte) int</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(s, sep []<span class="keyword">byte</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(sep)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> n == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">case</span> n == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> IndexByte(s, sep[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">case</span> n == <span class="built_in">len</span>(s):</span><br><span class="line"><span class="keyword">if</span> Equal(sep, s) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">case</span> n &gt; <span class="built_in">len</span>(s):</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">case</span> n &lt;= shortStringLen:</span><br><span class="line"><span class="comment">// Use brute force when s and sep both are small</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">64</span> &#123;</span><br><span class="line"><span class="keyword">return</span> indexShortStr(s, sep)</span><br><span class="line">&#125;</span><br><span class="line">c := sep[<span class="number">0</span>]</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line">t := s[:<span class="built_in">len</span>(s)-n+<span class="number">1</span>]</span><br><span class="line">fails := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(t) &#123;</span><br><span class="line"><span class="keyword">if</span> t[i] != c &#123;</span><br><span class="line"><span class="comment">// IndexByte skips 16/32 bytes per iteration,</span></span><br><span class="line"><span class="comment">// so it's faster than indexShortStr.</span></span><br><span class="line">o := IndexByte(t[i:], c)</span><br><span class="line"><span class="keyword">if</span> o &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">i += o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> Equal(s[i:i+n], sep) &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">fails++</span><br><span class="line">i++</span><br><span class="line"><span class="comment">// Switch to indexShortStr when IndexByte produces too many false positives.</span></span><br><span class="line"><span class="comment">// Too many means more that 1 error per 8 characters.</span></span><br><span class="line"><span class="comment">// Allow some errors in the beginning.</span></span><br><span class="line"><span class="keyword">if</span> fails &gt; (i+<span class="number">16</span>)/<span class="number">8</span> &#123;</span><br><span class="line">r := indexShortStr(s[i:], sep)</span><br><span class="line"><span class="keyword">if</span> r &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r + i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> indexRabinKarp(s, sep)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，是几个 case，主要是排除掉一些简单的情况。从<code>s</code>中找到第一次出现<code>sep</code>的位置，当sep长度为1，sep就是一个字节，<br>直接调用<code>IndexByte（s, sep[0]）</code>,就是把<code>s</code>里的字节挨个取出和sep[0]对比。<br><code>case n &lt;= shortStringLen:</code>表示最普遍的情况，这里使用了相关匹配算法，就不深入谈论了。</p><p>再简单看下<code>func IndexAny(s []byte, chars string) int</code>函数，返回<code>s</code>中第一次出现<code>chars</code>中任一字符的位置。<br>注意chars是string类型，可能包含ASCII和unicode，所以要先对<code>chars</code>做处理：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IndexAny</span><span class="params">(s []<span class="keyword">byte</span>, chars <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> chars == <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// Avoid scanning all of s.</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">8</span> &#123;<span class="comment">// 为什么这里判断len(s) &gt; 8,我也不知道，如果你知道麻烦告诉我哦</span></span><br><span class="line">      <span class="comment">// 这里 `makeASCIISet(chars)` 尝试将chars解析成ASCII码并生成集合，如果chars全都是ASCII码，isAscii 为 TRUE，反之为false</span></span><br><span class="line"><span class="keyword">if</span> as, isASCII := makeASCIISet(chars); isASCII &#123;</span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">if</span> as.contains(c) &#123;<span class="comment">//找到第一个元素，返回下标</span></span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当len(s)&lt;=8 或者 chars中包含unicode码会执行到这里。以下这段请仔细看，这样的套路会在bytes包里广泛使用。</span></span><br><span class="line"><span class="keyword">var</span> width <span class="keyword">int</span>  <span class="comment">//记录每个字符长度</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i += width &#123;</span><br><span class="line">r := <span class="keyword">rune</span>(s[i])</span><br><span class="line"><span class="keyword">if</span> r &lt; utf8.RuneSelf &#123;<span class="comment">// 表示r是一个ASCII码，则长度为一字节</span></span><br><span class="line">width = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r, width = utf8.DecodeRune(s[i:]) <span class="comment">// 从第 i 个开始到第 i+width 个字节，可能解析成一个unicode</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, ch := <span class="keyword">range</span> chars &#123;<span class="comment">//依次取出chars中每一个rune，和r比较</span></span><br><span class="line"><span class="keyword">if</span> r == ch &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基本上<code>index</code>类的函数理解以上两个就够了，其余的是在他们的基础上有小的调节。</p><h3 id="splite"><a href="#splite" class="headerlink" title="splite"></a>splite</h3><ul><li><a href="https://wizardforcel.gitbooks.io/golang-stdlib-ref/content/7.html#Split" target="_blank" rel="noopener">func Split(s, sep []byte) [][]byte</a></li><li><a href="https://wizardforcel.gitbooks.io/golang-stdlib-ref/content/7.html#SplitN" target="_blank" rel="noopener">func SplitN(s, sep []byte, n int) [][]byte</a></li><li><a href="https://wizardforcel.gitbooks.io/golang-stdlib-ref/content/7.html#SplitAfter" target="_blank" rel="noopener">func SplitAfter(s, sep []byte) [][]byte</a></li><li><a href="https://wizardforcel.gitbooks.io/golang-stdlib-ref/content/7.html#SplitAfterN" target="_blank" rel="noopener">func SplitAfterN(s, sep []byte, n int) [][]byte</a></li><li>…</li></ul><p>Splite 函数根据sep将字节切片切分成很多小切片，然后组成新的切片的切片。</p><p>和index函数一样，splite基本上是在调用<code>func genSplit(s, sep []byte, sepSave, n int) [][]byte</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">genSplit</span><span class="params">(s, sep []<span class="keyword">byte</span>, sepSave, n <span class="keyword">int</span>)</span> [][]<span class="title">byte</span></span> &#123;</span><br><span class="line">  <span class="comment">//s是源切片，sep是分割切片，sepSave表示分割后要保留sep中的多少位，n表示取前n-1个分段，超出n个的部分不分割，直接返回</span></span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sep) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> explode(s, n) <span class="comment">//长度为0，则按照“空”分割，也就是每个字符都分割，explode函数的功能是将切片分割成字符切片</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">n = Count(s, sep) + <span class="number">1</span> <span class="comment">//重新计算n，表示有多少sep段就分多少次</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, n)</span><br><span class="line">n--</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">m := Index(s, sep)</span><br><span class="line"><span class="keyword">if</span> m &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">a[i] = s[: m+sepSave : m+sepSave]  <span class="comment">//m + sepSave</span></span><br><span class="line">s = s[m+<span class="built_in">len</span>(sep):]</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">a[i] = s</span><br><span class="line"><span class="keyword">return</span> a[:i+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fields 的功能也是分段，先来看一下<code>FieldsFunc</code>,该函数通过f()得返回值来判断是否应该在某个字符处分段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func FieldsFunc(s []byte, f func(rune) bool) [][]byte &#123;</span><br><span class="line">// A span is used to record a slice of s of the form s[start:end].</span><br><span class="line">// The start index is inclusive and the end index is exclusive.</span><br><span class="line">type span struct &#123;//用于记录每一段的起始和终点下标</span><br><span class="line">start int</span><br><span class="line">end   int</span><br><span class="line">&#125;</span><br><span class="line">spans := make([]span, 0, 32)</span><br><span class="line"></span><br><span class="line">// Find the field start and end indices.</span><br><span class="line">wasField := false// wasField 表示从fromIndex开始到当前的字符是否应该出现在结果中</span><br><span class="line">fromIndex := 0</span><br><span class="line">for i := 0; i &lt; len(s); &#123;</span><br><span class="line">size := 1</span><br><span class="line">r := rune(s[i])</span><br><span class="line">if r &gt;= utf8.RuneSelf &#123;</span><br><span class="line">r, size = utf8.DecodeRune(s[i:])</span><br><span class="line">&#125;</span><br><span class="line">if f(r) &#123;// r 应该分段</span><br><span class="line">if wasField &#123;// 从fromIndex到当前(i)应该出现在结果中</span><br><span class="line">spans = append(spans, span&#123;start: fromIndex, end: i&#125;)</span><br><span class="line">wasField = false</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">if !wasField &#123;// 从fromIndex到当前(i)不应该出现在结果中</span><br><span class="line">fromIndex = i</span><br><span class="line">wasField = true</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">i += size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Last field might end at EOF.</span><br><span class="line">if wasField &#123;</span><br><span class="line">spans = append(spans, span&#123;fromIndex, len(s)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Create subslices from recorded field indices.</span><br><span class="line">a := make([][]byte, len(spans))</span><br><span class="line">for i, span := range spans &#123;</span><br><span class="line">a[i] = s[span.start:span.end:span.end]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个<code>Fields</code>函数，其实就是调用<code>FieldsFunc</code>函数，只不过传入的<code>f</code>参数是一个判断字符是否是空白符的函数，就不展示代码了</p><h3 id="Map函数"><a href="#Map函数" class="headerlink" title="Map函数"></a>Map函数</h3><p><code>func Map(mapping func(r rune) rune, s []byte) []byte</code>是对字节切片中每个字符进行遍历，并且根据传入的<code>mapping</code>函数对每个字符进行修改然后存到新的切片中，最后返回新的切片。</p><p><code>ToUpper</code>,<code>ToLower</code>,<code>ToTitle</code>…等函数都调用了Map函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Map</span><span class="params">(mapping <span class="keyword">func</span>(r <span class="keyword">rune</span>)</span> <span class="title">rune</span>, <span class="title">s</span> []<span class="title">byte</span>) []<span class="title">byte</span></span> &#123;</span><br><span class="line">   <span class="comment">// In the worst case, the slice can grow when mapped, making</span></span><br><span class="line">   <span class="comment">// things unpleasant. But it's so rare we barge in assuming it's</span></span><br><span class="line">   <span class="comment">// fine. It could also shrink but that falls out naturally.</span></span><br><span class="line">   maxbytes := <span class="built_in">len</span>(s) <span class="comment">// length of b</span></span><br><span class="line">   nbytes := <span class="number">0</span>        <span class="comment">// number of bytes encoded in b</span></span><br><span class="line">   b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, maxbytes)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); &#123;</span><br><span class="line">      wid := <span class="number">1</span></span><br><span class="line">      r := <span class="keyword">rune</span>(s[i])</span><br><span class="line">      <span class="keyword">if</span> r &gt;= utf8.RuneSelf &#123;</span><br><span class="line">         r, wid = utf8.DecodeRune(s[i:])</span><br><span class="line">      &#125;</span><br><span class="line">      r = mapping(r) <span class="comment">//r 即修改后的字符</span></span><br><span class="line">      <span class="keyword">if</span> r &gt;= <span class="number">0</span> &#123;</span><br><span class="line">         rl := utf8.RuneLen(r)</span><br><span class="line">         <span class="keyword">if</span> rl &lt; <span class="number">0</span> &#123;</span><br><span class="line">            rl = <span class="built_in">len</span>(<span class="keyword">string</span>(utf8.RuneError))</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> nbytes+rl &gt; maxbytes &#123;</span><br><span class="line">            <span class="comment">// Grow the buffer.</span></span><br><span class="line">            maxbytes = maxbytes*<span class="number">2</span> + utf8.UTFMax</span><br><span class="line">            nb := <span class="built_in">make</span>([]<span class="keyword">byte</span>, maxbytes)</span><br><span class="line">            <span class="built_in">copy</span>(nb, b[<span class="number">0</span>:nbytes])</span><br><span class="line">            b = nb</span><br><span class="line">         &#125;</span><br><span class="line">         nbytes += utf8.EncodeRune(b[nbytes:maxbytes], r)</span><br><span class="line">      &#125;</span><br><span class="line">      i += wid</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> b[<span class="number">0</span>:nbytes]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（完）"><a href="#（完）" class="headerlink" title="（完）"></a>（完）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;学习bytes的时候，网上找了很多文章，但基本上是用法，很少对代码的分析。这篇文章对bytes.go 做了简要的分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先从 &lt;code&gt;import&lt;/code&gt; 的包来看，只引入了&lt;code&gt;unic
      
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>JS call &amp; bind &amp; apply（I）</title>
    <link href="http://yoursite.com/2018/03/13/learn-into-javaScript_call&amp;bind&amp;apply/"/>
    <id>http://yoursite.com/2018/03/13/learn-into-javaScript_call&amp;bind&amp;apply/</id>
    <published>2018-03-13T13:37:56.638Z</published>
    <updated>2018-03-13T13:37:56.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>先给一个官方描述吧：</p><blockquote><p>call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。</p><p>可以让call()中的对象调用当前对象所拥有的function。你可以使用call()来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。</p></blockquote><h4 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h4><h5 id="使用call方法调用匿名函数"><a href="#使用call方法调用匿名函数" class="headerlink" title="使用call方法调用匿名函数"></a>使用call方法调用匿名函数</h5><p>在下例中的for循环体内，我们创建了一个匿名函数，然后通过调用该函数的call方法，将每个数组元素作为指定的this值执行了那个匿名函数。这个匿名函数的主要目的是给每个数组元素对象添加一个print方法，这个print方法可以打印出各元素在数组中的正确索引号<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123;<span class="attr">species</span>: <span class="string">'Lion'</span>, <span class="attr">name</span>: <span class="string">'King'</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">species</span>: <span class="string">'Whale'</span>, <span class="attr">name</span>: <span class="string">'Fail'</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; animals.length; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'#'</span> + i  + <span class="string">' '</span> + <span class="keyword">this</span>.species + <span class="string">': '</span> + <span class="keyword">this</span>.name); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">this</span>.print();</span><br><span class="line">  &#125;).call(animals[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用call方法调用函数并且指定上下文的-this"><a href="#使用call方法调用函数并且指定上下文的-this" class="headerlink" title="使用call方法调用函数并且指定上下文的 this"></a>使用call方法调用函数并且指定上下文的 <code>this</code></h5><p>举个栗子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p><h4 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h4><h5 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h5><p>在上面的第二个例子里，注意两点：</p><ul><li>call 改变了 this 的指向，指向到 foo</li><li>bar 函数执行了</li></ul><p>试想当调用 call 的时候，把 foo 对象改造成如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>这个时候 this 就指向了 foo，是不是很简单呢？</p><p>所以我们模拟的步骤可以分为：</p><ul><li>将函数设为对象的属性</li><li>执行该函数</li><li>删除该函数<h5 id="模拟第一步"><a href="#模拟第一步" class="headerlink" title="模拟第一步"></a>模拟第一步</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;    <span class="comment">//this 指向调用 call1 的函数</span></span><br><span class="line">  context.fn();</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一下</span></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar.call2(foo); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><h5 id="模拟第二步：指定参数"><a href="#模拟第二步：指定参数" class="headerlink" title="模拟第二步：指定参数"></a>模拟第二步：指定参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>); </span><br><span class="line">  <span class="comment">//获取arguments（传进来的所有参数），变成数组，并去掉第一个参数（context）</span></span><br><span class="line">  context.fn(...args);   </span><br><span class="line">  <span class="comment">// ...是es6的语法，意思是展开后面的对象或数组</span></span><br><span class="line">  <span class="comment">// 例如： ...[1,2,3,4,5] =&gt; 1,2,3,4,5</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是没有 es6 时的替代方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="string">'arguments['</span> + i + <span class="string">']'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>);</span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="模拟实现第三步"><a href="#模拟实现第三步" class="headerlink" title="模拟实现第三步"></a>模拟实现第三步</h5><p>模拟代码已经完成 80%，还有两个小点要注意：</p><p>1.this 参数可以传 null，当为 null 的时候，视为指向 window</p><p>2.函数是可以有返回值的！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.call1 = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>).slice(<span class="number">1</span>); </span><br><span class="line">  <span class="comment">//获取arguments（传进来的所有参数），变成数组，并去掉第一个参数（context）</span></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args);   </span><br><span class="line">  <span class="comment">// ...是es6的语法，意思是展开后面的对象或数组</span></span><br><span class="line">  <span class="comment">// 例如： ...[1,2,3,4,5] =&gt; 1,2,3,4,5</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大功告成！ｂ（￣▽￣）ｄ</p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><blockquote><p>和 call 一样，只是参数是以数组的形式给出</p><h5 id="模拟实现-1"><a href="#模拟实现-1" class="headerlink" title="模拟实现"></a>模拟实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="built_in">Object</span>(context) || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">            args.push(<span class="string">'arr['</span> + i + <span class="string">']'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="built_in">eval</span>(<span class="string">'context.fn('</span> + args + <span class="string">')'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> context.fn;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><blockquote><p>MDN 的解释：bind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当新函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">oThis</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">   <span class="comment">// closest thing possible to the ECMAScript 5 internal IsCallable function</span></span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> aArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>), </span><br><span class="line">     fToBind = <span class="keyword">this</span>, </span><br><span class="line">     fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">     fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> fToBind.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP &amp;&amp; oThis</span><br><span class="line">                              ? <span class="keyword">this</span></span><br><span class="line">                              : oThis || <span class="built_in">window</span>,</span><br><span class="line">                            aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line"> fNOP.prototype = <span class="keyword">this</span>.prototype;</span><br><span class="line"> fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call apply bind 区别"></a>call apply bind 区别</h2><p>call和apply，bind都是用来改变函数中this的指向<br>不同的是call和apply不仅改变了函数中this的指向并且立即调用了函数而bind仅仅是替换了this没有调用</p><p>apply和call的区别在于当Parent有参数的时候call只能一个一个的赋值 apply可以以数组的方式传递<br>bind体验了js的预处理，预先处理数据 稍后之行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;call&quot;&gt;&lt;a href=&quot;#call&quot; class=&quot;headerlink&quot; title=&quot;call&quot;&gt;&lt;/a&gt;call&lt;/h2&gt;&lt;p&gt;先给一个官方描述吧：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;call() 方法调用一个函数, 其具有一个指定的this值和
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Go net/dial.go（I）</title>
    <link href="http://yoursite.com/2018/03/13/golang%20net:dial.go/"/>
    <id>http://yoursite.com/2018/03/13/golang net:dial.go/</id>
    <published>2018-03-13T13:31:06.745Z</published>
    <updated>2018-03-13T13:31:06.746Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>实际上dial.go这个文件中并没有实际发起连接的部分，基本上是在为真正发起连接做一系列的准备，比如：解析网络类型、从addr解析ip地址。。。实际发起连接的函数在<code>tcpsock_posix.go</code>、<code>udpsock_posix.go</code>。。。</p></blockquote><p>首先看一下最主要的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Dialer <span class="keyword">struct</span> &#123;</span><br><span class="line">Timeout time.Duration</span><br><span class="line">  </span><br><span class="line">Deadline time.Time</span><br><span class="line"></span><br><span class="line">  LocalAddr Addr <span class="comment">//真正dial时的本地地址，兼容各种类型(TCP、UDP...),如果为nil，则系统自动选择一个地址</span></span><br><span class="line"></span><br><span class="line">DualStack <span class="keyword">bool</span> <span class="comment">// 双协议栈，即是否同时支持ipv4和ipv6.当network值为tcp时，dial函数会向host主机的v4和v6地址都发起连接</span></span><br><span class="line"></span><br><span class="line">FallbackDelay time.Duration <span class="comment">// 当DualStack为真，ipv6会延后于ipv4发起，此字段即为延迟时间，默认为300ms</span></span><br><span class="line"></span><br><span class="line">KeepAlive time.Duration </span><br><span class="line"></span><br><span class="line">Resolver *Resolver</span><br><span class="line"></span><br><span class="line">  Cancel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; <span class="comment">// 用于取消dial</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dial是最主要的函数，看一下源码注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dial connects to the address on the named network.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only),</span></span><br><span class="line"><span class="comment">// "udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4"</span></span><br><span class="line"><span class="comment">// (IPv4-only), "ip6" (IPv6-only), "unix", "unixgram" and</span></span><br><span class="line"><span class="comment">// "unixpacket".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For TCP and UDP networks, the address has the form "host:port".</span></span><br><span class="line"><span class="comment">// The host must be a literal IP address, or a host name that can be</span></span><br><span class="line"><span class="comment">// resolved to IP addresses.</span></span><br><span class="line"><span class="comment">// The port must be a literal port number or a service name.</span></span><br><span class="line"><span class="comment">// If the host is a literal IPv6 address it must be enclosed in square</span></span><br><span class="line"><span class="comment">// brackets, as in "[2001:db8::1]:80" or "[fe80::1%zone]:80".</span></span><br><span class="line"><span class="comment">// The zone specifies the scope of the literal IPv6 address as defined</span></span><br><span class="line"><span class="comment">// in RFC 4007.</span></span><br><span class="line"><span class="comment">// The functions JoinHostPort and SplitHostPort manipulate a pair of</span></span><br><span class="line"><span class="comment">// host and port in this form.</span></span><br><span class="line"><span class="comment">// When using TCP, and the host resolves to multiple IP addresses,</span></span><br><span class="line"><span class="comment">// Dial will try each IP address in order until one succeeds.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//Dial("tcp", "golang.org:http")</span></span><br><span class="line"><span class="comment">//Dial("tcp", "192.0.2.1:http")</span></span><br><span class="line"><span class="comment">//Dial("tcp", "198.51.100.1:80")</span></span><br><span class="line"><span class="comment">//Dial("udp", "[2001:db8::1]:domain")</span></span><br><span class="line"><span class="comment">//Dial("udp", "[fe80::1%lo0]:53")</span></span><br><span class="line"><span class="comment">//Dial("tcp", ":80")</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For IP networks, the network must be "ip", "ip4" or "ip6" followed</span></span><br><span class="line"><span class="comment">// by a colon and a literal protocol number or a protocol name, and</span></span><br><span class="line"><span class="comment">// the address has the form "host". The host must be a literal IP</span></span><br><span class="line"><span class="comment">// address or a literal IPv6 address with zone.</span></span><br><span class="line"><span class="comment">// It depends on each operating system how the operating system</span></span><br><span class="line"><span class="comment">// behaves with a non-well known protocol number such as "0" or "255".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Examples:</span></span><br><span class="line"><span class="comment">//Dial("ip4:1", "192.0.2.1")</span></span><br><span class="line"><span class="comment">//Dial("ip6:ipv6-icmp", "2001:db8::1")</span></span><br><span class="line"><span class="comment">//Dial("ip6:58", "fe80::1%lo0")</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For TCP, UDP and IP networks, if the host is empty or a literal</span></span><br><span class="line"><span class="comment">// unspecified IP address, as in ":80", "0.0.0.0:80" or "[::]:80" for</span></span><br><span class="line"><span class="comment">// TCP and UDP, "", "0.0.0.0" or "::" for IP, the local system is</span></span><br><span class="line"><span class="comment">// assumed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For Unix networks, the address must be a file system path.</span></span><br></pre></td></tr></table></figure><blockquote><p>从注释可以看出，Dial 支持多种网络类型；支持ipv4、ipv6；还支持用host名代替ip地址。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> d Dialer</span><br><span class="line"><span class="keyword">return</span> d.Dial(network, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DialTimeout</span><span class="params">(network, address <span class="keyword">string</span>, timeout time.Duration)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">d := Dialer&#123;Timeout: timeout&#125;</span><br><span class="line"><span class="keyword">return</span> d.Dial(network, address)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dialer)</span> <span class="title">Dial</span><span class="params">(network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> d.DialContext(context.Background(), network, address)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上前两个是导出的主要函数，都调用了d.dial()，d.DialContext()。d.DialContext()可以传入一个context，如果context的生命周期在connect完成之前结束，那么会立即返回错误。如果context在连接建立完成之后结束，则不会影响连接。另外如果addr是一组ip地址的话，会把当前剩下的所有时间均分到每个ip上去尝试连接。只要有一个成功，就会立即返回成功的连接并取消其他尝试。具体看代码(有删减)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dialer)</span> <span class="title">DialContext</span><span class="params">(ctx context.Context, network, address <span class="keyword">string</span>)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">  deadline := d.deadline(ctx, time.Now()) </span><br><span class="line">  <span class="comment">//d.deadline() 比较d.deadline、ctx.deadline、now+timeout，返回其中最小.如果都为空，返回0</span></span><br><span class="line">  ...</span><br><span class="line">  subCtx, cancel := context.WithDeadline(ctx, deadline) <span class="comment">//设置新的超时context</span></span><br><span class="line">  <span class="keyword">defer</span> cancel()</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// Shadow the nettrace (if any) during resolve so Connect events don't fire for DNS lookups.</span></span><br><span class="line">resolveCtx := ctx</span><br><span class="line">...<span class="comment">//给resolveCtx带上一些value</span></span><br><span class="line"></span><br><span class="line">addrs, err := d.resolver().resolveAddrList(resolveCtx, <span class="string">"dial"</span>, network, address, d.LocalAddr) <span class="comment">// 解析IP地址，返回值是一个切片</span></span><br><span class="line"></span><br><span class="line">dp := &amp;dialParam&#123;</span><br><span class="line">Dialer:  *d,</span><br><span class="line">network: network,</span><br><span class="line">address: address,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> primaries, fallbacks addrList</span><br><span class="line"><span class="keyword">if</span> d.DualStack &amp;&amp; network == <span class="string">"tcp"</span> &#123; <span class="comment">//表示同时支持ipv4和ipv6</span></span><br><span class="line">primaries, fallbacks = addrs.partition(isIPv4) <span class="comment">// 将addrs分成两个切片，前者包含ipv4地址，后者包含ipv6地址</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">primaries = addrs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c Conn</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fallbacks) &gt; <span class="number">0</span> &#123;<span class="comment">//有ipv6的情况，v4和v6一起dial</span></span><br><span class="line">c, err = dialParallel(ctx, dp, primaries, fallbacks)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c, err = dialSerial(ctx, dp, primaries)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码看到，DialContext最终调用的是<code>dialParallel</code>和<code>dialSerial</code>,先看dialParallel，该函数将v4地址和v6地址分开，先尝试v4地址组，在dialer.fallbackDelay 时间后开始尝试v6地址组，每一组都是调用dialSerial(),让两组竞争：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialParallel</span><span class="params">(ctx context.Context, dp *dialParam, primaries, fallbacks addrList)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fallbacks) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> dialSerial(ctx, dp, primaries)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dialResult <span class="keyword">struct</span> &#123;</span><br><span class="line">Conn</span><br><span class="line">error</span><br><span class="line">primary <span class="keyword">bool</span></span><br><span class="line">done    <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> dialResult) <span class="comment">// unbuffered</span></span><br><span class="line"></span><br><span class="line">startRacer := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, primary <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">ras := primaries <span class="comment">// ras 意思是 remote addresses</span></span><br><span class="line"><span class="keyword">if</span> !primary &#123;</span><br><span class="line">ras = fallbacks</span><br><span class="line">&#125;</span><br><span class="line">c, err := dialSerial(ctx, dp, ras)</span><br><span class="line">      ...</span><br><span class="line">results &lt;- dialResult&#123;Conn: c, error: err, primary: primary, done: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> primary, fallback dialResult</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the main racer.</span></span><br><span class="line">primaryCtx, primaryCancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> primaryCancel()</span><br><span class="line"><span class="keyword">go</span> startRacer(primaryCtx, <span class="literal">true</span>)<span class="comment">//先尝试ipv4地址组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Start the timer for the fallback racer.</span></span><br><span class="line">fallbackTimer := time.NewTimer(dp.fallbackDelay())</span><br><span class="line"><span class="keyword">defer</span> fallbackTimer.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-fallbackTimer.C: <span class="comment">// ipv6延迟时间到，开始尝试ipv6地址组</span></span><br><span class="line">fallbackCtx, fallbackCancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> fallbackCancel()</span><br><span class="line"><span class="keyword">go</span> startRacer(fallbackCtx, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> res := &lt;-results: <span class="comment">//表示至少有一组已经建立连接</span></span><br><span class="line"><span class="keyword">if</span> res.error == <span class="literal">nil</span> &#123; <span class="comment">//</span></span><br><span class="line"><span class="keyword">return</span> res.Conn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.primary &#123;</span><br><span class="line">primary = res</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fallback = res</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> primary.done &amp;&amp; fallback.done &#123;<span class="comment">//同时建立连接，抛弃</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, primary.error</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.primary &amp;&amp; fallbackTimer.Stop() &#123;</span><br><span class="line"><span class="comment">// If we were able to stop the timer, that means it</span></span><br><span class="line"><span class="comment">// was running (hadn't yet started the fallback), but</span></span><br><span class="line"><span class="comment">// we just got an error on the primary path, so start</span></span><br><span class="line"><span class="comment">// the fallback immediately (in 0 nanoseconds).</span></span><br><span class="line">fallbackTimer.Reset(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看<code>dialSerial</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialSerial</span><span class="params">(ctx context.Context, dp *dialParam, ras addrList)</span> <span class="params">(Conn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> firstErr error <span class="comment">// The error from the first address is most relevant.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, ra := <span class="keyword">range</span> ras &#123; <span class="comment">// ra =&gt; remote address</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">//表示</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: dp.LocalAddr, Addr: ra, Err: mapErr(ctx.Err())&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deadline, _ := ctx.Deadline()</span><br><span class="line">partialDeadline, err := partialDeadline(time.Now(), deadline, <span class="built_in">len</span>(ras)-i)</span><br><span class="line">        <span class="comment">// 这里表示前 i 个IP地址的连接失败，然后将剩下的时间均分到剩余的IP地址</span></span><br><span class="line">...<span class="comment">//判断是否超时并处理</span></span><br><span class="line">      </span><br><span class="line">dialCtx := ctx</span><br><span class="line">        dialCtx, cancel := context.WithDeadline(ctx, partialDeadline)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">c, err := dialSingle(dialCtx, dp, ra)<span class="comment">// 对单个IP地址发起连接</span></span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> firstErr == <span class="literal">nil</span> &#123;</span><br><span class="line">firstErr = err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> firstErr == <span class="literal">nil</span> &#123;</span><br><span class="line">firstErr = &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: <span class="literal">nil</span>, Addr: <span class="literal">nil</span>, Err: errMissingAddress&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, firstErr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终所有的对单个IP地址发起链接的任务是由dialSingle分配的（此处简单看下就好），该函数解决了兼容不同网络类型的问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialSingle</span><span class="params">(ctx context.Context, dp *dialParam, ra Addr)</span> <span class="params">(c Conn, err error)</span></span> &#123;</span><br><span class="line">trace, _ := ctx.Value(nettrace.TraceKey&#123;&#125;).(*nettrace.Trace)</span><br><span class="line"><span class="keyword">if</span> trace != <span class="literal">nil</span> &#123;</span><br><span class="line">raStr := ra.String()</span><br><span class="line"><span class="keyword">if</span> trace.ConnectStart != <span class="literal">nil</span> &#123;</span><br><span class="line">trace.ConnectStart(dp.network, raStr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> trace.ConnectDone != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; trace.ConnectDone(dp.network, raStr, err) &#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">la := dp.LocalAddr</span><br><span class="line"><span class="keyword">switch</span> ra := ra.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *TCPAddr:</span><br><span class="line">la, _ := la.(*TCPAddr)</span><br><span class="line">c, err = dialTCP(ctx, dp.network, la, ra)</span><br><span class="line"><span class="keyword">case</span> *UDPAddr:</span><br><span class="line">la, _ := la.(*UDPAddr)</span><br><span class="line">c, err = dialUDP(ctx, dp.network, la, ra)</span><br><span class="line"><span class="keyword">case</span> *IPAddr:</span><br><span class="line">la, _ := la.(*IPAddr)</span><br><span class="line">c, err = dialIP(ctx, dp.network, la, ra)</span><br><span class="line"><span class="keyword">case</span> *UnixAddr:</span><br><span class="line">la, _ := la.(*UnixAddr)</span><br><span class="line">c, err = dialUnix(ctx, dp.network, la, ra)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: la, Addr: ra, Err: &amp;AddrError&#123;Err: <span class="string">"unexpected address type"</span>, Addr: dp.address&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, &amp;OpError&#123;Op: <span class="string">"dial"</span>, Net: dp.network, Source: la, Addr: ra, Err: err&#125; <span class="comment">// c is non-nil interface containing nil pointer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，dial.go基本就这么多内容，真正通过socket建立连接的部分下篇再写吧(其实是偷懒)。</p><h4 id="待续"><a href="#待续" class="headerlink" title="(待续)"></a>(待续)</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;实际上dial.go这个文件中并没有实际发起连接的部分，基本上是在为真正发起连接做一系列的准备，比如：解析网络类型、从addr解析ip地址。。。实际发起连接的函数在&lt;code&gt;tcpsock_posix.go&lt;/code&gt;、&lt;code&gt;udpsoc
      
    
    </summary>
    
    
      <category term="golang" scheme="http://yoursite.com/tags/golang/"/>
    
      <category term="net" scheme="http://yoursite.com/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>Go net/dial.go (II)</title>
    <link href="http://yoursite.com/2018/03/13/Go%20net:dial.go%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://yoursite.com/2018/03/13/Go net:dial.go 阅读笔记(二)/</id>
    <published>2018-03-13T13:28:50.339Z</published>
    <updated>2018-03-13T13:28:50.339Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.littlechao.top/#/index/article?_id=5a9823ceebc087002a3e7259" target="_blank" rel="noopener">上一篇文章</a> 我们大致分析了dial.go中的代码，起主要的功能就是为真正发起连接做一些准备，起到了应用层的作用（DNS解析等）。但是一个连接完整的连接还需要更深层次的网络协议来完成协作，所以我们接着上篇来分析，由于篇(懒)幅原因，只将<code>dialTcp</code>作为传输层的例子。。。话不多说，上代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialTCP</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, laddr, raddr *TCPAddr)</span> <span class="params">(*TCPConn, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> testHookDialTCP != <span class="literal">nil</span> &#123; <span class="comment">//testHookDialTCP 是语言开发者为了测试留的钩子函数，不用管</span></span><br><span class="line"><span class="keyword">return</span> testHookDialTCP(ctx, net, laddr, raddr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> doDialTCP(ctx, net, laddr, raddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意现在所在文件是在<code>tcpsock_posix.go</code> 这部分是<strong>传输层</strong>的内容了。</p></blockquote><p>来看<code>doDialTCP</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doDialTCP</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, laddr, raddr *TCPAddr)</span> <span class="params">(*TCPConn, error)</span></span> &#123;</span><br><span class="line">fd, err := internetSocket(ctx, net, laddr, raddr, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">"dial"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; (laddr == <span class="literal">nil</span> || laddr.Port == <span class="number">0</span>) &amp;&amp; (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line">&#125;</span><br><span class="line">fd, err = internetSocket(ctx, net, laddr, raddr, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">"dial"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newTCPConn(fd), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数里的ctx自然不言而喻了，是为了控制请求超时取消请求释放资源的；<code>laddr</code>是 local address ， <code>raddr</code>是指 remote address；返回值这里会得到 <code>TCPConn</code>。代码不长，就是调用了 <code>internetSocket</code>得到一个文件描述符，并用其新建一个conn返回。但这里我想多说几句，因为不难发现， <code>internetSocket</code>可能会被调用多次，为什么呢？</p><p>首先我们需要知道 Tcp 有一个极少使用的机制，叫<code>simultaneous connection</code>（同时连接）。正常的连接是：A主机 dial B主机，B主机 listen。 而同时连接则是： A 向 B dial 同时 B 向 A dial，那么 A 和 B 都不需要监听。</p><p>我们知道，当 传入 dial  函数的参数<code>laddr</code>==<code>raddr</code>时，内核会拒绝dial。但如果传入的<code>laddr</code>为nil，kernel 会自动选择一个本机端口，这时候有可能会使得新的<code>laddr</code>==<code>raddr</code>,这个时候，kernel不会拒绝dial，并且这个dial会成功，原因是就<code>simultaneous connection</code>，这可能是kernel的bug。所以会判断是否是 <code>selfConnect</code>或者<code>spuriousENOTAVAIL</code>(spurious error not avail)来判断上一次调用<code>internetSocket</code>返回的 err 类型，在特定的情况下重新尝试<code>internetSocket</code>.关于这个问题的讨论参见<a href="https://stackoverflow.com/questions/4949858/how-can-you-have-a-tcp-connection-back-to-the-same-port" target="_blank" rel="noopener">这里</a>。</p><p>好了，我们接下来看看<code>internetSocket</code>，该函数在<code>ipsock_posix.go</code>文件，到了<strong>网络层</strong>的范围了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">internetSocket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, laddr, raddr sockaddr, sotype, proto <span class="keyword">int</span>, mode <span class="keyword">string</span>)</span> <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> (runtime.GOOS == <span class="string">"windows"</span> || runtime.GOOS == <span class="string">"openbsd"</span> || runtime.GOOS == <span class="string">"nacl"</span>) &amp;&amp; mode == <span class="string">"dial"</span> &amp;&amp; raddr.isWildcard() &#123;</span><br><span class="line">raddr = raddr.toLocal(net) </span><br><span class="line">      <span class="comment">// 如果 raddr 是零地址，把它转化成当前系统对应的零地址格式(local system address 127.0.0.1 or ::1)</span></span><br><span class="line">&#125;</span><br><span class="line">family, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode)</span><br><span class="line"><span class="keyword">return</span> socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（sotype 和 proto 是生成 socket 文件d的系统调用时用的）首先判断了运行系统的类型，<code>favoriteAddrFamily</code>返回了当前 dial 最合适的地址族，主要是判断应该用ipv4还是ipv6或者都用，其返回值 family 有两种可能值：<code>AF_INET</code>和<code>AF_INET6</code>，都是int类型，感兴趣的朋友可以参见<a href="https://stackoverflow.com/questions/1593946/what-is-af-inet-and-why-do-i-need-it" target="_blank" rel="noopener">这里</a>。</p><p>让我们接着关注<code>socket</code>,该函数在<code>sock_posix.go</code>文件，意味着接下来将是更加底层的系统调用了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// socket returns a network file descriptor that is ready for</span></span><br><span class="line"><span class="comment">// asynchronous I/O using the network poller.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">socket</span><span class="params">(ctx context.Context, net <span class="keyword">string</span>, family, sotype, proto <span class="keyword">int</span>, ipv6only <span class="keyword">bool</span>, laddr, raddr sockaddr)</span> <span class="params">(fd *netFD, err error)</span></span> &#123;</span><br><span class="line">s, err := sysSocket(family, sotype, proto)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = setDefaultSockopts(s, family, sotype, ipv6only); err != <span class="literal">nil</span> &#123;</span><br><span class="line">poll.CloseFunc(s)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> fd, err = newFD(s, family, sotype, net); err != <span class="literal">nil</span> &#123;</span><br><span class="line">poll.CloseFunc(s)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function makes a network file descriptor for the</span></span><br><span class="line"><span class="comment">// following applications:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens a passive stream</span></span><br><span class="line"><span class="comment">//   connection, known as a stream listener</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens a destination-unspecific</span></span><br><span class="line"><span class="comment">//   datagram connection, known as a datagram listener</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens an active stream or a</span></span><br><span class="line"><span class="comment">//   destination-specific datagram connection, known as a</span></span><br><span class="line"><span class="comment">//   dialer</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - An endpoint holder that opens the other connection, such</span></span><br><span class="line"><span class="comment">//   as talking to the protocol stack inside the kernel</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For stream and datagram listeners, they will only require</span></span><br><span class="line"><span class="comment">// named sockets, so we can assume that it's just a request</span></span><br><span class="line"><span class="comment">// from stream or datagram listeners when laddr is not nil but</span></span><br><span class="line"><span class="comment">// raddr is nil. Otherwise we assume it's just for dialers or</span></span><br><span class="line"><span class="comment">// the other connection holders.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> laddr != <span class="literal">nil</span> &amp;&amp; raddr == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> sotype &#123;</span><br><span class="line"><span class="keyword">case</span> syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:</span><br><span class="line"><span class="keyword">if</span> err := fd.listenStream(laddr, listenerBacklog); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> syscall.SOCK_DGRAM:</span><br><span class="line"><span class="keyword">if</span> err := fd.listenDatagram(laddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := fd.dial(ctx, laddr, raddr); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fd, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码隐含了大量细节，首先看最上面函数的注释，返回值是一个使用了<a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener"><code>network poller</code></a>的<strong>异步I/O</strong>的文件描述符。前面三个 if 里，先创建了一个 socket，然后设置基本参数，再 new 一个文件描述符，其中包含了大量的系统调用和底层细节，这里先跳过。我想说的在下面。</p><p>socket 这个函数可以为一下几种应用创建一个文件描述符：</p><ul><li>一个打开了 被动的、流式的 连接的终端，通常叫<code>stream listener</code></li><li>一个打开了 没有具体目的地的、数据报格式的 连接的终端，通常叫<code>datagram listener</code></li><li>一个打开了 主动的、有明确目的地的、数据报格式的 连接的终端，通常叫<code>dialer</code></li><li>一个打开了其他连接的终端，比如与内核中的协议栈通信</li></ul><blockquote><p>通常可以认为当 <code>laddr</code>不为空但<code>raddr</code>为空时的 request 是来自stream or datagram listeners。否则就是来自 dialers 或者其他系统连接。</p></blockquote><p>所以一个dialer和listener的区别就是 laddr， 也就是dialer在一定情况下可以当做listener，到这里就可以解释之前tcp的<code>simultaneous connection</code>同时连接了。</p><p>接下来调用了fd的dial函数，这里才真正通过socket开始发送连接请求。</p><p>(待续)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.littlechao.top/#/index/article?_id=5a9823ceebc087002a3e7259&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt; 我们大致分析了dial.go中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go http/server.go</title>
    <link href="http://yoursite.com/2018/03/13/Go%20net:http:serve.go%20%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/03/13/Go net:http:serve.go 阅读笔记/</id>
    <published>2018-03-13T13:28:50.332Z</published>
    <updated>2018-03-13T13:28:50.332Z</updated>
    
    <content type="html"><![CDATA[<p>先从一个简单的例子开始吧：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启web服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, sayHello)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"ListenAndServer:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">"Hello Guest!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码，此时浏览器访问<code>localhost:9090</code>就会看到输出“Hello Guest!”，其实访问<code>localhost:9090/</code>+任意字符串，都能得到结果。这段代码先用<code>http.HandleFunc</code>注册了一个处理函数，然后调用<code>http.ListenAndServe</code>监听端口，当有请求到来时，会根据访问路径找到并执行对应的处理函数。</p><p>我们通常还能看到另一种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启web服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.Handle(<span class="string">"/"</span>, &amp;handler&#123;&#125;)</span><br><span class="line">err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"ListenAndServer:"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> handler <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *handler)</span> <span class="title">ServeHTTP</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">sayHello(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码效果一样。区别就是<code>http.HandleFunc</code>和<code>http.Handle</code>需要的第二个参数，前者要一个<code>func (w http.ResponseWriter, r *http.Request)</code>函数，后者要一个实现了该函数的结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">mux.Handle(pattern, HandlerFunc(handler))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123; DefaultServeMux.Handle(pattern, handler) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，两个函数都会调用<code>mux.handle</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span></span><br></pre></td></tr></table></figure><p>第二个参数是Handler，是一个接口:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回到上面的<code>HandleFunc</code>,注意这个：<code>HandlerFunc(handler)</code>,这里很容易让人误以为HandlerFunc是一个函数并且包装了传入的handler，再返回一个<code>Handler</code>类型。而实际上这里是<strong>类型转换</strong>，来看HandlerFunc的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ServeHTTP</span> <span class="title">calls</span> <span class="title">f</span><span class="params">(w, r)</span>.</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">ServeHTTP</span><span class="params">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class="line">f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然<code>HandlerFunc</code>的类型是一个函数，但它是一种类型，因为是以<code>type</code>来定义而不是<code>func</code>，并且实现了<code>ServeHTTP(w ResponseWriter, r *Request)</code>，在这个函数里，它又调用了自身。这个细节是十分重要的，因为这一步关乎到当路由规则匹配时，相应的响应方法是否会被调用的问题！这里的类型转换用法使一个函数自身实现了一个接口，就不用每次都要先写一个本身无用结构体，再用结构体实现接口。请仔细体会这种技巧！</p><p>接着看<code>mux.Handle</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mux *ServeMux)</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">mux.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mux.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern == <span class="string">""</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: invalid pattern "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: nil handler"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> mux.m[pattern].explicit &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"http: multiple registrations for "</span> + pattern)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> mux.m == <span class="literal">nil</span> &#123;</span><br><span class="line">mux.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry)</span><br><span class="line">&#125;</span><br><span class="line">mux.m[pattern] = muxEntry&#123;explicit: <span class="literal">true</span>, h: handler, pattern: pattern&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line">mux.hosts = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下是很有用的功能:当pattern == “/tree/”时,</span></span><br><span class="line">  <span class="comment">// 会插入一条永久的重定向到“/tree”,注意最后的斜杠。</span></span><br><span class="line">  <span class="comment">// 当然前提是在这之前没有“/tree”这条路由</span></span><br><span class="line">n := <span class="built_in">len</span>(pattern)</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">0</span> &amp;&amp; pattern[n<span class="number">-1</span>] == <span class="string">'/'</span> &amp;&amp; !mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]].explicit &#123;</span><br><span class="line"><span class="comment">//如果包含host，</span></span><br><span class="line">path := pattern</span><br><span class="line"><span class="keyword">if</span> pattern[<span class="number">0</span>] != <span class="string">'/'</span> &#123;</span><br><span class="line"><span class="comment">// In pattern, at least the last character is a '/', so</span></span><br><span class="line"><span class="comment">// strings.Index can't be -1.</span></span><br><span class="line">path = pattern[strings.Index(pattern, <span class="string">"/"</span>):]</span><br><span class="line">&#125;</span><br><span class="line">url := &amp;url.URL&#123;Path: path&#125;</span><br><span class="line">mux.m[pattern[<span class="number">0</span>:n<span class="number">-1</span>]] = muxEntry&#123;h: RedirectHandler(url.String(), StatusMovedPermanently), pattern: pattern&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码挺多，其实主要就做了一件事，向<code>DefaultServeMux</code>的<code>map[string]muxEntry</code>中增加对应的路由规则和<code>handler</code>。那什么是<code>DefaultServeMux</code>的<code>muxEntry</code>?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServeMux <span class="keyword">struct</span> &#123;</span><br><span class="line">mu    sync.RWMutex</span><br><span class="line">m     <span class="keyword">map</span>[<span class="keyword">string</span>]muxEntry</span><br><span class="line">  <span class="comment">//路由规则，一个string对应一个mux实例对象，map的key就是注册的路由表达式(string类型的)</span></span><br><span class="line">hosts <span class="keyword">bool</span> <span class="comment">// whether any patterns contain hostnames</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaultServeMux ServeMux</span><br><span class="line"><span class="keyword">var</span> DefaultServeMux = &amp;defaultServeMux</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> muxEntry <span class="keyword">struct</span> &#123; <span class="comment">// 代表着一个 路由-处理函数 组合</span></span><br><span class="line">explicit <span class="keyword">bool</span> <span class="comment">//表示patern是否是明确清晰的</span></span><br><span class="line">h        Handler</span><br><span class="line">pattern  <span class="keyword">string</span> <span class="comment">//路由表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先从一个简单的例子开始吧：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP 连接管理</title>
    <link href="http://yoursite.com/2018/03/13/TCPConn/"/>
    <id>http://yoursite.com/2018/03/13/TCPConn/</id>
    <published>2018-03-13T09:36:40.995Z</published>
    <updated>2018-03-13T09:36:40.996Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP-连接的建立和终止"><a href="#TCP-连接的建立和终止" class="headerlink" title="TCP 连接的建立和终止"></a>TCP 连接的建立和终止</h3><p>一个TCP连接由一个四元组构成：源IP、源端口、目的IP、目的端口。一个连接通常分为三个阶段：启动、数据传输（也称“连接已建立”）、关闭。以下是建立连接是三步握手和关闭时四步挥手的过程。</p><p><img src="https://notes.shichao.io/tcpv1/figure_13-1.png" alt=""></p><h6 id="握手："><a href="#握手：" class="headerlink" title="握手："></a>握手：</h6><ul><li>客户端先发一个SYN（synchronous）报文段，并指明客户端的初始序列号（Initial Sequence Number），图中值为ISN(c)。（注意这里可能出现超时或报文丢失的情况）</li><li>服务端收到后返回一个ACK（acknowledgement）,并指明ACK确认号的值为ISN(c) + 1来表明已经收到Seq值为ISN(c)的SYN报文段。服务端在同一个报文段还发送了一个SYN并指明自己的初始序列号ISN(s).</li><li>客户端收到ACK+SYN，发送ACK向服务端确认收到来自服务端的SYN，并指明Seq=ISN(s) + 1.</li></ul><blockquote><p>重要的细节：对于client来说，第三步似乎是多余的，但是对服务端来说，是一个防止SYN泛洪攻击的手段：服务端在建立连接后需要为该连接分配变量和内存，如果没有第三步，恶意客户端通过不停伪造IP和端口发起SYN（客户端没有太大内存消耗），导致服务端不停分配变量，最后内存消耗完崩溃。所以第三步可以让服务端辨别恶意客户端。</p></blockquote><p>######挥手：</p><ul><li>关闭发起者（TCP连接是双向的，任何一方都可以主动断开连接）向另一方发送一个FIN（final）段表示要开始关闭连接。此时的ACK值是确认最近一次发来的数据。</li><li>被动方接收FIN，发回一个ACK。</li><li>被动方向发起方发送一个FIN，同时再次确认之前的FIN，ACK和上次相同。</li><li>发起方收到FIN，发回ACK</li></ul><p>挥手断开这里同样有很多重要细节：</p><ul><li>前两步完成后，发起方到被动方的连接已经关闭，但TCP是双向的，此时由于被动方还没有发送FIN，所以被动方到发起方的连接还打开着，TCP连接目前处于<strong>半关闭</strong>状态，此时被动方仍然可以向发起方发送数据，发起方也可以正常接受数据。但是如果被动方既不再发送数据，也不发送最后的FIN，就会出现问题。所以发起方收到FIN的ACK时，设置了一个定时器，在规定时间内没有数据发过来，就自动断开连接。</li><li>另一个问题是，如果发起方发送了最后一个ACK用于确认被动方的FIN之后立刻关闭，但是此ACK超时未达或者丢失了，就会造成问题—被动方的FIN得不到确认。这时被动方会在超时后重新发送FIN，直到收到ACK为止。所以发起方发送完最后一个ACK后不能马上离开，而要等一段时间，用于确保对方收到ACK，这段时间叫<strong>静默时间</strong>，并且这个时间是强制的。静默时间大小一般为2*MSL（Max Segment Lifetime,报文段在被丢弃前允许的最长存活时间）所以它还有另一个重要的作用，就是让属于这个已经关闭连接的报文段过期，以免相同的客户端和服务端再次建立连接时受到之前已经关闭连接的影响。</li></ul><h3 id="TCP-FSM"><a href="#TCP-FSM" class="headerlink" title="TCP FSM"></a>TCP FSM</h3><p>以下是TCP三步握手和四步挥手的有限状态机。应该掌握。</p><p><img src="http://image.littlechao.top/20180313081609000002.jpg" alt=""></p><h3 id="TCP-选项"><a href="#TCP-选项" class="headerlink" title="TCP 选项"></a>TCP 选项</h3><p>TCP有若干选项，每个选项的头一个字节表示“种类”，指明了选项的类型。</p><h5 id="MSS-最大段大小选项"><a href="#MSS-最大段大小选项" class="headerlink" title="MSS 最大段大小选项"></a>MSS 最大段大小选项</h5><p>Max segment size。当一条TCP连接建立时，通信双方都要在SYN报文段的MSS选项说明自己允许的最大段大小。注意最大段大小不是双方协商的结果，而是表明自己不愿意接收任何大于该尺寸的报文段。</p><h5 id="SACK-选择确认段"><a href="#SACK-选择确认段" class="headerlink" title="SACK 选择确认段"></a>SACK 选择确认段</h5><p>Select ACK。在滑动窗口中，TCP采用累计ACK确认，不能正确的确认已经收到的但是是失序的报文段，接收方的数据队列就会出现空洞。SACK能够使发送方了解到空洞出现并进行更有效的重传工作。通过接收SYN报文段中的“允许确认选项”，TCP通信方会知道自身拥有了发布SACK的能力。SACK选项由n个SACK块构成，每个SACK块是一对32位的序列号（a，b），表明已经接受a到b的数据。</p><h5 id="WSOPT"><a href="#WSOPT" class="headerlink" title="WSOPT"></a>WSOPT</h5><p>Window scale option。窗口本来大小只有16位，若wsopt值为s，则窗口大小为16*2^s,最大值为1G</p><p>#####TSOPT</p><p>timestamp option。发送方发出的报文段带有发出时的时间戳，接收方收到后将该值写入ACK报文段发回给发送方。发送方据此可以精确地计算RTT（round trip time）。同时该选项还可用于防回绕：假如存在一个过期了的报文段恰好和下一次要接受的报文段序列号相同，这时候可以通过时间戳来判断，如果该报文时间戳小于最近一次收到的报文段，说明改报文段是过期了的。</p><h3 id="TCP服务器选项"><a href="#TCP服务器选项" class="headerlink" title="TCP服务器选项"></a>TCP服务器选项</h3><p>TCP服务端会为每一个客户端分配一个新的进程或线程，这样负责监听的服务器就能始终准备着处理下一个到来的连接请求。但是如果服务器正在创建一个新进程（线程）时有更多的连接到来，应该如何处理？</p><p>在被用于应用程序之前，新的连接可能会有两种状态：1、SYN_RCVD 状态         2、    ESTABLISHED 状态 但未被应用程序所接受。</p><p>TCP为这两种状态的连接准备了两个队列，可以通过限制它们的大小来管理连接。</p><ul><li>当一个SYN报文段到达，将会检查SYN_RCVD队列是否已满（Linux中默认为1000），未满则加入队列，否则拒绝连接。</li><li>ESTABLISHED状态的队列通常被称为<strong>未完成连接</strong>（backlog，虽然叫未完成，但是三次握手已经完成，只是还没被应用程序处理），backlog队列最大长度默认为128</li><li>如果backlog队列未满，则会根据SYN_RCVD队列应答SYN并完成握手，握手完成后，加入backlog队列，由负责监听的服务器依次分配线程。注意当客户端发送ACK后，会认为服务端已经做好接收数据的准备来，所以会立即发送数据，但此时连接可能还处于backlog队列，还未被应用程序处理，所以TCP还有一个专门的数据队列。</li><li>如果backlog已满，则会延迟应答SYN。正常的TCP机制里，客户端会等待SYN超时，但在Linux客户端中，既不超时也不重置。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP-连接的建立和终止&quot;&gt;&lt;a href=&quot;#TCP-连接的建立和终止&quot; class=&quot;headerlink&quot; title=&quot;TCP 连接的建立和终止&quot;&gt;&lt;/a&gt;TCP 连接的建立和终止&lt;/h3&gt;&lt;p&gt;一个TCP连接由一个四元组构成：源IP、源端口、目的IP、目
      
    
    </summary>
    
    
      <category term="tcp" scheme="http://yoursite.com/tags/tcp/"/>
    
  </entry>
  
</feed>
